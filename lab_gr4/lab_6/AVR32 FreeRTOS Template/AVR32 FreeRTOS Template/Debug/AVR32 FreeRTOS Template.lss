
AVR32 FreeRTOS Template.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00003b30  80002024  80002024  00002424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005c00  80005c00  00006000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005e00  80005e00  00006200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000184  80005e18  80005e18  00006218  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .lalign       00000004  80005f9c  80005f9c  0000639c  2**0
                  ALLOC
  8 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  9 .ctors        00000008  00000008  80005fa0  00006408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  00000010  80005fa8  00006410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .jcr          00000004  00000018  80005fb0  00006418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .got          0000000c  0000001c  80005fb4  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .data         000005d8  00000028  80005fc0  00006428  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          00000430  00000600  00000600  00000000  2**2
                  ALLOC
 15 .heap         0000e5d0  00000a30  00000a30  00000000  2**0
                  ALLOC
 16 .comment      00000030  00000000  00000000  00006a00  2**0
                  CONTENTS, READONLY
 17 .debug_aranges 00000ce8  00000000  00000000  00006a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_pubnames 000019df  00000000  00000000  00007718  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_info   00025c2c  00000000  00000000  000090f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_abbrev 000047d5  00000000  00000000  0002ed23  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_line   0000e781  00000000  00000000  000334f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_frame  00001e04  00000000  00000000  00041c7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    00007ec7  00000000  00000000  00043a80  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    000044aa  00000000  00000000  0004b947  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_macinfo 014ad906  00000000  00000000  0004fdf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 27 .debug_ranges 00000d70  00000000  00000000  014fd6f7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	48 1f       	lddpc	pc,80002004 <program_start+0x4>
80002002:	00 00       	add	r0,r0
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	20 24       	sub	r4,2

Disassembly of section .init:

80002008 <_init>:
80002008:	eb cd 40 40 	pushm	r6,lr
8000200c:	48 26       	lddpc	r6,80002014 <_init+0xc>
8000200e:	1e 26       	rsub	r6,pc
80002010:	c0 48       	rjmp	80002018 <_init+0x10>
80002012:	00 00       	add	r0,r0
80002014:	80 00       	ld.sh	r0,r0[0x0]
80002016:	1f f2       	ld.ub	r2,pc[0x7]
80002018:	f0 16 00 01 	mcall	r6[4]
8000201c:	f0 16 00 00 	mcall	r6[0]
80002020:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002024 <_stext>:
80002024:	30 07       	mov	r7,0
80002026:	49 5a       	lddpc	r10,80002078 <_stext+0x54>
80002028:	5b fa       	cp.w	r10,-1
8000202a:	f4 0d 17 10 	movne	sp,r10
8000202e:	49 4b       	lddpc	r11,8000207c <_stext+0x58>
80002030:	49 4c       	lddpc	r12,80002080 <_stext+0x5c>
80002032:	18 3b       	cp.w	r11,r12
80002034:	c0 60       	breq	80002040 <_stext+0x1c>
80002036:	49 4a       	lddpc	r10,80002084 <_stext+0x60>
80002038:	b7 09       	ld.d	r8,r11++
8000203a:	b9 28       	st.d	r12++,r8
8000203c:	14 3c       	cp.w	r12,r10
8000203e:	cf d5       	brlt	80002038 <_stext+0x14>
80002040:	49 2a       	lddpc	r10,80002088 <_stext+0x64>
80002042:	49 1c       	lddpc	r12,80002084 <_stext+0x60>
80002044:	30 08       	mov	r8,0
80002046:	30 09       	mov	r9,0
80002048:	b9 28       	st.d	r12++,r8
8000204a:	14 3c       	cp.w	r12,r10
8000204c:	cf e5       	brlt	80002048 <_stext+0x24>
8000204e:	f0 1f 00 10 	mcall	8000208c <_stext+0x68>
80002052:	49 0c       	lddpc	r12,80002090 <_stext+0x6c>
80002054:	f0 1f 00 10 	mcall	80002094 <_stext+0x70>
80002058:	f0 1f 00 10 	mcall	80002098 <_stext+0x74>
8000205c:	1a 9c       	mov	r12,sp
8000205e:	30 0b       	mov	r11,0
80002060:	f0 1f 00 0f 	mcall	8000209c <_stext+0x78>
80002064:	5b fc       	cp.w	r12,-1
80002066:	f9 bc 00 00 	moveq	r12,0
8000206a:	f9 ba 00 00 	moveq	r10,0
8000206e:	14 1d       	sub	sp,r10
80002070:	f0 1f 00 0c 	mcall	800020a0 <_stext+0x7c>
80002074:	f0 1f 00 0c 	mcall	800020a4 <_stext+0x80>
80002078:	00 01       	add	r1,r0
8000207a:	00 00       	add	r0,r0
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	5f a0       	srle	r0
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	00 00       	add	r0,r0
80002086:	06 00       	add	r0,r3
80002088:	00 00       	add	r0,r0
8000208a:	0a 30       	cp.w	r0,r5
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	43 34       	lddsp	r4,sp[0xcc]
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	5e 00       	reteq	r0
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	4b 8c       	lddpc	r12,80002174 <gpio_configure_pin+0x38>
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	20 08       	sub	r8,0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	51 dc       	stdsp	sp[0x74],r12
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	4a a4       	lddpc	r4,80002148 <gpio_configure_pin+0xc>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	4b a0       	lddpc	r0,8000218c <gpio_configure_pin+0x50>

800020a8 <__do_global_dtors_aux>:
800020a8:	d4 21       	pushm	r4-r7,lr
800020aa:	48 e8       	lddpc	r8,800020e0 <__do_global_dtors_aux+0x38>
800020ac:	11 89       	ld.ub	r9,r8[0x0]
800020ae:	30 08       	mov	r8,0
800020b0:	f0 09 18 00 	cp.b	r9,r8
800020b4:	c1 41       	brne	800020dc <__do_global_dtors_aux+0x34>
800020b6:	48 c8       	lddpc	r8,800020e4 <__do_global_dtors_aux+0x3c>
800020b8:	48 c6       	lddpc	r6,800020e8 <__do_global_dtors_aux+0x40>
800020ba:	10 95       	mov	r5,r8
800020bc:	10 16       	sub	r6,r8
800020be:	48 c7       	lddpc	r7,800020ec <__do_global_dtors_aux+0x44>
800020c0:	a3 46       	asr	r6,0x2
800020c2:	20 16       	sub	r6,1
800020c4:	c0 68       	rjmp	800020d0 <__do_global_dtors_aux+0x28>
800020c6:	2f f8       	sub	r8,-1
800020c8:	8f 08       	st.w	r7[0x0],r8
800020ca:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ce:	5d 18       	icall	r8
800020d0:	6e 08       	ld.w	r8,r7[0x0]
800020d2:	0c 38       	cp.w	r8,r6
800020d4:	cf 93       	brcs	800020c6 <__do_global_dtors_aux+0x1e>
800020d6:	30 19       	mov	r9,1
800020d8:	48 28       	lddpc	r8,800020e0 <__do_global_dtors_aux+0x38>
800020da:	b0 89       	st.b	r8[0x0],r9
800020dc:	d8 22       	popm	r4-r7,pc
800020de:	00 00       	add	r0,r0
800020e0:	00 00       	add	r0,r0
800020e2:	06 00       	add	r0,r3
800020e4:	00 00       	add	r0,r0
800020e6:	00 10       	sub	r0,r0
800020e8:	00 00       	add	r0,r0
800020ea:	00 14       	sub	r4,r0
800020ec:	00 00       	add	r0,r0
800020ee:	06 04       	add	r4,r3

800020f0 <frame_dummy>:
800020f0:	d4 01       	pushm	lr
800020f2:	48 5c       	lddpc	r12,80002104 <frame_dummy+0x14>
800020f4:	78 08       	ld.w	r8,r12[0x0]
800020f6:	58 08       	cp.w	r8,0
800020f8:	c0 50       	breq	80002102 <frame_dummy+0x12>
800020fa:	48 48       	lddpc	r8,80002108 <frame_dummy+0x18>
800020fc:	58 08       	cp.w	r8,0
800020fe:	c0 20       	breq	80002102 <frame_dummy+0x12>
80002100:	5d 18       	icall	r8
80002102:	d8 02       	popm	pc
80002104:	00 00       	add	r0,r0
80002106:	00 18       	sub	r8,r0
80002108:	00 00       	add	r0,r0
	...

8000210c <board_init>:
#endif



void board_init (void)
{
8000210c:	d4 01       	pushm	lr
    gpio_configure_pin (LED0_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000210e:	30 3b       	mov	r11,3
80002110:	32 3c       	mov	r12,35
80002112:	f0 1f 00 0a 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED1_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002116:	30 3b       	mov	r11,3
80002118:	34 9c       	mov	r12,73
8000211a:	f0 1f 00 08 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED2_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000211e:	30 3b       	mov	r11,3
80002120:	32 2c       	mov	r12,34
80002122:	f0 1f 00 06 	mcall	80002138 <board_init+0x2c>
    gpio_configure_pin (LED3_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002126:	30 3b       	mov	r11,3
80002128:	32 6c       	mov	r12,38
8000212a:	f0 1f 00 04 	mcall	80002138 <board_init+0x2c>

    gpio_configure_pin (GPIO_PUSH_BUTTON_0, (GPIO_DIR_INPUT | GPIO_PULL_UP));
8000212e:	30 4b       	mov	r11,4
80002130:	32 1c       	mov	r12,33
80002132:	f0 1f 00 02 	mcall	80002138 <board_init+0x2c>
     * the platform Xplained board has configured basic clock settings,
     * GPIO pin mapping, interrupt controller options, etc.
     */
    sensor_board_init ();
#endif
}
80002136:	d8 02       	popm	pc
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	21 3c       	sub	r12,19

8000213c <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{  
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];  
8000213c:	f8 08 16 05 	lsr	r8,r12,0x5
80002140:	a9 68       	lsl	r8,0x8
80002142:	e0 28 f0 00 	sub	r8,61440
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif    
    if (flags & GPIO_PULL_UP)
80002146:	16 99       	mov	r9,r11
80002148:	e2 19 00 04 	andl	r9,0x4,COH
8000214c:	c0 70       	breq	8000215a <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
8000214e:	30 19       	mov	r9,1
80002150:	f2 0c 09 49 	lsl	r9,r9,r12
80002154:	f1 49 00 74 	st.w	r8[116],r9
80002158:	c0 68       	rjmp	80002164 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
8000215a:	30 19       	mov	r9,1
8000215c:	f2 0c 09 49 	lsl	r9,r9,r12
80002160:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
80002164:	16 99       	mov	r9,r11
80002166:	e2 19 00 80 	andl	r9,0x80,COH
8000216a:	c2 40       	breq	800021b2 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
8000216c:	16 99       	mov	r9,r11
8000216e:	e2 19 01 80 	andl	r9,0x180,COH
80002172:	c0 90       	breq	80002184 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
80002174:	30 19       	mov	r9,1
80002176:	f2 0c 09 49 	lsl	r9,r9,r12
8000217a:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
8000217e:	f1 49 00 b8 	st.w	r8[184],r9
80002182:	c1 88       	rjmp	800021b2 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
80002184:	16 99       	mov	r9,r11
80002186:	e2 19 02 80 	andl	r9,0x280,COH
8000218a:	c0 90       	breq	8000219c <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
8000218c:	30 19       	mov	r9,1
8000218e:	f2 0c 09 49 	lsl	r9,r9,r12
80002192:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
80002196:	f1 49 00 b8 	st.w	r8[184],r9
8000219a:	c0 c8       	rjmp	800021b2 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
8000219c:	16 99       	mov	r9,r11
8000219e:	e2 19 03 80 	andl	r9,0x380,COH
800021a2:	c0 80       	breq	800021b2 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
800021a4:	30 19       	mov	r9,1
800021a6:	f2 0c 09 49 	lsl	r9,r9,r12
800021aa:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
800021ae:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
800021b2:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
800021b6:	c1 50       	breq	800021e0 <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
800021b8:	e2 1b 00 02 	andl	r11,0x2,COH
800021bc:	c0 70       	breq	800021ca <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
800021be:	30 19       	mov	r9,1
800021c0:	f2 0c 09 49 	lsl	r9,r9,r12
800021c4:	f1 49 00 54 	st.w	r8[84],r9
800021c8:	c0 68       	rjmp	800021d4 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
800021ca:	30 19       	mov	r9,1
800021cc:	f2 0c 09 49 	lsl	r9,r9,r12
800021d0:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
800021d4:	30 19       	mov	r9,1
800021d6:	f2 0c 09 49 	lsl	r9,r9,r12
800021da:	f1 49 00 44 	st.w	r8[68],r9
800021de:	c0 68       	rjmp	800021ea <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
800021e0:	30 19       	mov	r9,1
800021e2:	f2 0c 09 49 	lsl	r9,r9,r12
800021e6:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
800021ea:	30 19       	mov	r9,1
800021ec:	f2 0c 09 4c 	lsl	r12,r9,r12
800021f0:	91 1c       	st.w	r8[0x4],r12
}
800021f2:	5e fc       	retal	r12

800021f4 <gpio_get_pin_value>:
    gpio_port->gpers = mask;
}

int gpio_get_pin_value(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800021f4:	f8 08 16 05 	lsr	r8,r12,0x5
800021f8:	a9 68       	lsl	r8,0x8
800021fa:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800021fe:	71 88       	ld.w	r8,r8[0x60]
80002200:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80002204:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002208:	5e fc       	retal	r12

8000220a <gpio_set_pin_high>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_set_pin_high(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000220a:	f8 08 16 05 	lsr	r8,r12,0x5
8000220e:	a9 68       	lsl	r8,0x8
80002210:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
80002214:	30 19       	mov	r9,1
80002216:	f2 0c 09 4c 	lsl	r12,r9,r12
8000221a:	f1 4c 00 54 	st.w	r8[84],r12
}
8000221e:	5e fc       	retal	r12

80002220 <gpio_set_pin_low>:
}


void gpio_set_pin_low(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002220:	f8 08 16 05 	lsr	r8,r12,0x5
80002224:	a9 68       	lsl	r8,0x8
80002226:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
8000222a:	30 19       	mov	r9,1
8000222c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002230:	f1 4c 00 58 	st.w	r8[88],r12
}
80002234:	5e fc       	retal	r12

80002236 <gpio_toggle_pin>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_toggle_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002236:	f8 08 16 05 	lsr	r8,r12,0x5
8000223a:	a9 68       	lsl	r8,0x8
8000223c:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrt  = 1 << (pin & 0x1F); // Toggle the I/O line.
80002240:	30 19       	mov	r9,1
80002242:	f2 0c 09 4c 	lsl	r12,r9,r12
80002246:	f1 4c 00 5c 	st.w	r8[92],r12
}
8000224a:	5e fc       	retal	r12

8000224c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000224c:	c0 08       	rjmp	8000224c <_unhandled_interrupt>
8000224e:	d7 03       	nop

80002250 <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002250:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
80002254:	48 99       	lddpc	r9,80002278 <INTC_register_interrupt+0x28>
80002256:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000225a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000225e:	72 19       	ld.w	r9,r9[0x4]
80002260:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_level & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
80002264:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80002268:	48 59       	lddpc	r9,8000227c <INTC_register_interrupt+0x2c>
8000226a:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
8000226e:	fe 79 08 00 	mov	r9,-63488
80002272:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
80002276:	5e fc       	retal	r12
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	5e 18       	retne	r8
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	5d 3c       	musfr	r12

80002280 <INTC_init_interrupts>:
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
}

void INTC_init_interrupts(void)
{
80002280:	d4 21       	pushm	r4-r7,lr
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
80002282:	49 18       	lddpc	r8,800022c4 <INTC_init_interrupts+0x44>
80002284:	e3 b8 00 01 	mtsr	0x4,r8
80002288:	49 0e       	lddpc	lr,800022c8 <INTC_init_interrupts+0x48>
8000228a:	30 07       	mov	r7,0
8000228c:	0e 94       	mov	r4,r7
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000228e:	49 0c       	lddpc	r12,800022cc <INTC_init_interrupts+0x4c>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80002290:	49 08       	lddpc	r8,800022d0 <INTC_init_interrupts+0x50>
80002292:	70 05       	ld.w	r5,r8[0x0]
80002294:	fe 76 08 00 	mov	r6,-63488
80002298:	c1 08       	rjmp	800022b8 <INTC_init_interrupts+0x38>
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
8000229a:	08 98       	mov	r8,r4
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000229c:	7c 1b       	ld.w	r11,lr[0x4]

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000229e:	7c 0a       	ld.w	r10,lr[0x0]
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
800022a0:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022a4:	2f f8       	sub	r8,-1
800022a6:	10 3a       	cp.w	r10,r8
800022a8:	fe 9b ff fc 	brhi	800022a0 <INTC_init_interrupts+0x20>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
800022ac:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
  unsigned int int_grp, int_req;

  INTC_init_evba();

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800022b0:	2f f7       	sub	r7,-1
800022b2:	2f 8e       	sub	lr,-8
800022b4:	59 e7       	cp.w	r7,30
800022b6:	c0 50       	breq	800022c0 <INTC_init_interrupts+0x40>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022b8:	7c 08       	ld.w	r8,lr[0x0]
800022ba:	58 08       	cp.w	r8,0
800022bc:	ce f1       	brne	8000229a <INTC_init_interrupts+0x1a>
800022be:	cf 7b       	rjmp	800022ac <INTC_init_interrupts+0x2c>
800022c0:	d8 22       	popm	r4-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	5c 00       	acr	r0
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	5e 18       	retne	r8
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	22 4c       	sub	r12,36
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	5d 3c       	musfr	r12

800022d4 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_level)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
  // pass a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800022d4:	fe 78 08 00 	mov	r8,-63488
800022d8:	e0 69 00 83 	mov	r9,131
800022dc:	f2 0c 01 0c 	sub	r12,r9,r12
800022e0:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
800022e4:	f2 ca ff c0 	sub	r10,r9,-64
800022e8:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
800022ec:	58 08       	cp.w	r8,0
800022ee:	c0 21       	brne	800022f2 <_get_interrupt_handler+0x1e>
800022f0:	5e fd       	retal	0
800022f2:	f0 08 12 00 	clz	r8,r8
800022f6:	48 5a       	lddpc	r10,80002308 <_get_interrupt_handler+0x34>
800022f8:	f4 09 00 39 	add	r9,r10,r9<<0x3
800022fc:	f0 08 11 1f 	rsub	r8,r8,31
80002300:	72 19       	ld.w	r9,r9[0x4]
80002302:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
80002306:	5e fc       	retal	r12
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	5e 18       	retne	r8

8000230c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000230c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000230e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002312:	99 a8       	st.w	r12[0x28],r8
}
80002314:	5e fc       	retal	r12
80002316:	d7 03       	nop

80002318 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002318:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000231a:	ec 5b bb 9f 	cp.w	r11,899999
8000231e:	e0 8b 00 04 	brhi	80002326 <pm_enable_osc0_crystal+0xe>
80002322:	30 4b       	mov	r11,4
80002324:	c1 38       	rjmp	8000234a <pm_enable_osc0_crystal+0x32>
80002326:	e0 68 c6 bf 	mov	r8,50879
8000232a:	ea 18 00 2d 	orh	r8,0x2d
8000232e:	10 3b       	cp.w	r11,r8
80002330:	e0 8b 00 04 	brhi	80002338 <pm_enable_osc0_crystal+0x20>
80002334:	30 5b       	mov	r11,5
80002336:	c0 a8       	rjmp	8000234a <pm_enable_osc0_crystal+0x32>
80002338:	e0 68 12 00 	mov	r8,4608
8000233c:	ea 18 00 7a 	orh	r8,0x7a
80002340:	10 3b       	cp.w	r11,r8
80002342:	f9 bb 03 06 	movlo	r11,6
80002346:	f9 bb 02 07 	movhs	r11,7
8000234a:	f0 1f 00 02 	mcall	80002350 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000234e:	d8 02       	popm	pc
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	23 0c       	sub	r12,48

80002354 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002354:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002356:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000235a:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
8000235c:	78 08       	ld.w	r8,r12[0x0]
8000235e:	a3 a8       	sbr	r8,0x2
80002360:	99 08       	st.w	r12[0x0],r8
}
80002362:	5e fc       	retal	r12

80002364 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002364:	79 58       	ld.w	r8,r12[0x54]
80002366:	e2 18 00 80 	andl	r8,0x80,COH
8000236a:	cf d0       	breq	80002364 <pm_wait_for_clk0_ready>
}
8000236c:	5e fc       	retal	r12
8000236e:	d7 03       	nop

80002370 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002376:	f0 1f 00 04 	mcall	80002384 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
8000237a:	0e 9c       	mov	r12,r7
8000237c:	f0 1f 00 03 	mcall	80002388 <pm_enable_clk0+0x18>
}
80002380:	e3 cd 80 80 	ldm	sp++,r7,pc
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	23 54       	sub	r4,53
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	23 64       	sub	r4,54

8000238c <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000238c:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000238e:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002392:	99 08       	st.w	r12[0x0],r8
}
80002394:	5e fc       	retal	r12
80002396:	d7 03       	nop

80002398 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002398:	eb cd 40 c0 	pushm	r6-r7,lr
8000239c:	18 97       	mov	r7,r12
8000239e:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800023a0:	f0 1f 00 06 	mcall	800023b8 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800023a4:	0c 9b       	mov	r11,r6
800023a6:	0e 9c       	mov	r12,r7
800023a8:	f0 1f 00 05 	mcall	800023bc <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800023ac:	30 1b       	mov	r11,1
800023ae:	0e 9c       	mov	r12,r7
800023b0:	f0 1f 00 04 	mcall	800023c0 <pm_switch_to_osc0+0x28>
}
800023b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	23 18       	sub	r8,49
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	23 70       	sub	r0,55
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	23 8c       	sub	r12,56

800023c4 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3C device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
800023c4:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
800023c6:	58 0c       	cp.w	r12,0
800023c8:	c0 40       	breq	800023d0 <pcl_switch_to_osc+0xc>
800023ca:	fe 7c d8 f0 	mov	r12,-10000
800023ce:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
800023d0:	fe 7c 0c 00 	mov	r12,-62464
800023d4:	f0 1f 00 02 	mcall	800023dc <pcl_switch_to_osc+0x18>
800023d8:	d8 0a       	popm	pc,r12=0
800023da:	00 00       	add	r0,r0
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	23 98       	sub	r8,57

800023e0 <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
800023e0:	5e ff       	retal	1

800023e2 <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
800023e2:	5e fd       	retal	0

800023e4 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
800023e4:	fe 68 00 00 	mov	r8,-131072
800023e8:	70 09       	ld.w	r9,r8[0x0]
800023ea:	a7 d9       	cbr	r9,0x7
800023ec:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
800023ee:	70 09       	ld.w	r9,r8[0x0]
800023f0:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
800023f4:	e0 19 ff 80 	andl	r9,0xff80
800023f8:	f9 e9 10 09 	or	r9,r12,r9
800023fc:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
800023fe:	70 09       	ld.w	r9,r8[0x0]
80002400:	a7 b9       	sbr	r9,0x7
80002402:	91 09       	st.w	r8[0x0],r9
}
80002404:	5e fc       	retal	r12

80002406 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
80002406:	fe 68 00 00 	mov	r8,-131072
8000240a:	70 0c       	ld.w	r12,r8[0x0]
}
8000240c:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80002410:	5e fc       	retal	r12

80002412 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
80002412:	fe 68 00 00 	mov	r8,-131072
80002416:	70 8c       	ld.w	r12,r8[0x20]
}
80002418:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
8000241c:	5e fc       	retal	r12

8000241e <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
8000241e:	fe 68 00 00 	mov	r8,-131072
80002422:	70 8c       	ld.w	r12,r8[0x20]
}
80002424:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
80002428:	5e fc       	retal	r12
8000242a:	d7 03       	nop

8000242c <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload,	uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
8000242c:	48 28       	lddpc	r8,80002434 <udd_set_setup_payload+0x8>
8000242e:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
80002430:	b0 6b       	st.h	r8[0xc],r11
}
80002432:	5e fc       	retal	r12
80002434:	00 00       	add	r0,r0
80002436:	0a 00       	add	r0,r5

80002438 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
80002438:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000243c:	a3 68       	lsl	r8,0x2
8000243e:	e0 38 fe 40 	sub	r8,130624
80002442:	70 0c       	ld.w	r12,r8[0x0]
}
80002444:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
80002448:	5e fc       	retal	r12
8000244a:	d7 03       	nop

8000244c <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
8000244c:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index)
80002450:	30 38       	mov	r8,3
80002452:	f0 0c 18 00 	cp.b	r12,r8
80002456:	e0 8b 00 35 	brhi	800024c0 <udd_ep_set_halt+0x74>
		return false;

	ptr_job = &udd_ep_job[index - 1];
8000245a:	18 99       	mov	r9,r12
8000245c:	f8 c8 00 01 	sub	r8,r12,1
80002460:	a5 68       	lsl	r8,0x4
80002462:	49 9a       	lddpc	r10,800024c4 <udd_ep_set_halt+0x78>
80002464:	f4 08 00 08 	add	r8,r10,r8
	if (ptr_job->busy == true) {
80002468:	70 0a       	ld.w	r10,r8[0x0]
8000246a:	58 0a       	cp.w	r10,0
8000246c:	c2 a5       	brlt	800024c0 <udd_ep_set_halt+0x74>
		return false;	// Job on going, stall impossible
	}
	
	if (0 != udd_nb_busy_bank(index)) {
8000246e:	a3 69       	lsl	r9,0x2
80002470:	fe 6b 01 30 	mov	r11,-130768
80002474:	f2 0b 00 0a 	add	r10,r9,r11
80002478:	74 0a       	ld.w	r10,r10[0x0]
8000247a:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
8000247e:	c1 10       	breq	800024a0 <udd_ep_set_halt+0x54>
		// Wait end of transfer on USB line before stall endpoint
		// Flag a stall requested
		ptr_job->stall_requested = true;
80002480:	70 0b       	ld.w	r11,r8[0x0]
80002482:	30 1a       	mov	r10,1
80002484:	f7 da d3 81 	bfins	r11,r10,0x1c,0x1
80002488:	91 0b       	st.w	r8[0x0],r11
		udd_enable_bank_interrupt(index);
8000248a:	e0 39 fe 10 	sub	r9,130576
8000248e:	e0 68 10 00 	mov	r8,4096
80002492:	93 08       	st.w	r9[0x0],r8
		udd_enable_endpoint_interrupt(index);
80002494:	f0 0c 09 4c 	lsl	r12,r8,r12
80002498:	fe 69 00 00 	mov	r9,-131072
8000249c:	93 6c       	st.w	r9[0x18],r12
8000249e:	5e fa       	retal	r10
	} else {
		// Stall endpoint
		udd_disable_endpoint_bank_autoswitch(index);
800024a0:	fe 6a 01 00 	mov	r10,-130816
800024a4:	f2 0a 00 08 	add	r8,r9,r10
800024a8:	70 0a       	ld.w	r10,r8[0x0]
800024aa:	a9 da       	cbr	r10,0x9
800024ac:	91 0a       	st.w	r8[0x0],r10
		udd_enable_stall_handshake(index);
800024ae:	e0 39 fe 10 	sub	r9,130576
800024b2:	e8 68 00 00 	mov	r8,524288
800024b6:	93 08       	st.w	r9[0x0],r8
		udd_reset_data_toggle(index);
800024b8:	e4 68 00 00 	mov	r8,262144
800024bc:	93 08       	st.w	r9[0x0],r8
800024be:	5e ff       	retal	1
800024c0:	5e fd       	retal	0
800024c2:	00 00       	add	r0,r0
800024c4:	00 00       	add	r0,r0
800024c6:	07 18       	ld.sh	r8,r3++

800024c8 <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
800024c8:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
800024ca:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800024ce:	30 38       	mov	r8,3
800024d0:	f0 0c 18 00 	cp.b	r12,r8
800024d4:	e0 88 00 03 	brls	800024da <udd_ep_clear_halt+0x12>
800024d8:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];
800024da:	f8 c8 00 01 	sub	r8,r12,1
800024de:	a5 68       	lsl	r8,0x4
800024e0:	49 69       	lddpc	r9,80002538 <udd_ep_clear_halt+0x70>
800024e2:	f2 08 00 08 	add	r8,r9,r8

	if (Is_udd_endpoint_stall_requested(ep)	// Endpoint stalled
800024e6:	a3 6c       	lsl	r12,0x2
800024e8:	fe 6a 01 c0 	mov	r10,-130624
800024ec:	f8 0a 00 09 	add	r9,r12,r10
800024f0:	72 09       	ld.w	r9,r9[0x0]
800024f2:	e6 19 00 08 	andh	r9,0x8,COH
800024f6:	c0 51       	brne	80002500 <udd_ep_clear_halt+0x38>
			|| ptr_job->stall_requested) {	// Endpoint stall is requested
800024f8:	70 09       	ld.w	r9,r8[0x0]
800024fa:	e6 19 10 00 	andh	r9,0x1000,COH
800024fe:	c1 c0       	breq	80002536 <udd_ep_clear_halt+0x6e>
		// Remove request to stall
		ptr_job->stall_requested = false;
80002500:	70 09       	ld.w	r9,r8[0x0]
80002502:	30 0a       	mov	r10,0
80002504:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
80002508:	91 09       	st.w	r8[0x0],r9
		// Remove stall
		udd_disable_stall_handshake(ep);
8000250a:	fe 6a 02 20 	mov	r10,-130528
8000250e:	f8 0a 00 09 	add	r9,r12,r10
80002512:	e8 6a 00 00 	mov	r10,524288
80002516:	93 0a       	st.w	r9[0x0],r10
		udd_enable_endpoint_bank_autoswitch(ep);	
80002518:	e0 3c ff 00 	sub	r12,130816
8000251c:	78 09       	ld.w	r9,r12[0x0]
8000251e:	a9 b9       	sbr	r9,0x9
80002520:	99 09       	st.w	r12[0x0],r9
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
80002522:	70 09       	ld.w	r9,r8[0x0]
80002524:	58 09       	cp.w	r9,0
80002526:	c0 84       	brge	80002536 <udd_ep_clear_halt+0x6e>
			ptr_job->busy = false;
80002528:	30 0a       	mov	r10,0
8000252a:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
8000252e:	91 09       	st.w	r8[0x0],r9
			ptr_job->call_nohalt();
80002530:	70 38       	ld.w	r8,r8[0xc]
80002532:	5d 18       	icall	r8
80002534:	da 0a       	popm	pc,r12=1
80002536:	da 0a       	popm	pc,r12=1
80002538:	00 00       	add	r0,r0
8000253a:	07 18       	ld.sh	r8,r3++

8000253c <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
8000253c:	30 59       	mov	r9,5
8000253e:	48 58       	lddpc	r8,80002550 <udd_ctrl_stall_data+0x14>
80002540:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
80002542:	e8 69 00 00 	mov	r9,524288
80002546:	fe 68 01 f0 	mov	r8,-130576
8000254a:	91 09       	st.w	r8[0x0],r9
}
8000254c:	5e fc       	retal	r12
8000254e:	00 00       	add	r0,r0
80002550:	00 00       	add	r0,r0
80002552:	07 4c       	ld.w	r12,--r3

80002554 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
80002554:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
80002556:	48 48       	lddpc	r8,80002564 <udd_ctrl_endofrequest+0x10>
80002558:	70 48       	ld.w	r8,r8[0x10]
8000255a:	58 08       	cp.w	r8,0
8000255c:	c0 20       	breq	80002560 <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
8000255e:	5d 18       	icall	r8
80002560:	d8 02       	popm	pc
80002562:	00 00       	add	r0,r0
80002564:	00 00       	add	r0,r0
80002566:	0a 00       	add	r0,r5

80002568 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort)
{
80002568:	d4 01       	pushm	lr
8000256a:	16 99       	mov	r9,r11
	if (ptr_job->busy == false)
8000256c:	78 08       	ld.w	r8,r12[0x0]
8000256e:	58 08       	cp.w	r8,0
80002570:	c0 b4       	brge	80002586 <udd_ep_finish_job+0x1e>
		return;	// No on-going job
	ptr_job->busy = false;
80002572:	30 0a       	mov	r10,0
80002574:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80002578:	99 08       	st.w	r12[0x0],r8
	if (NULL == ptr_job->call_trans)
8000257a:	78 38       	ld.w	r8,r12[0xc]
8000257c:	58 08       	cp.w	r8,0
8000257e:	c0 40       	breq	80002586 <udd_ep_finish_job+0x1e>
		return;	// No callback linked to job
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
80002580:	78 2b       	ld.w	r11,r12[0x8]
80002582:	12 9c       	mov	r12,r9
80002584:	5d 18       	icall	r8
80002586:	d8 02       	popm	pc

80002588 <udd_ep_abort_job>:
	}
}


static void udd_ep_abort_job(udd_ep_id_t ep)
{
80002588:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
8000258a:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
8000258e:	20 18       	sub	r8,1
80002590:	a5 68       	lsl	r8,0x4
80002592:	30 1b       	mov	r11,1
80002594:	48 3c       	lddpc	r12,800025a0 <udd_ep_abort_job+0x18>
80002596:	10 0c       	add	r12,r8
80002598:	f0 1f 00 03 	mcall	800025a4 <udd_ep_abort_job+0x1c>
}
8000259c:	d8 02       	popm	pc
8000259e:	00 00       	add	r0,r0
800025a0:	00 00       	add	r0,r0
800025a2:	07 18       	ld.sh	r8,r3++
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	25 68       	sub	r8,86

800025a8 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
800025a8:	d4 01       	pushm	lr
	udd_disable_endpoint(ep & USB_EP_ADDR_MASK);
800025aa:	fe 69 00 00 	mov	r9,-131072
800025ae:	72 7b       	ld.w	r11,r9[0x1c]
800025b0:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
800025b4:	30 1a       	mov	r10,1
800025b6:	f4 08 09 4a 	lsl	r10,r10,r8
800025ba:	5c da       	com	r10
800025bc:	16 6a       	and	r10,r11
800025be:	93 7a       	st.w	r9[0x1c],r10
	udd_unallocate_memory(ep & USB_EP_ADDR_MASK);
800025c0:	a3 68       	lsl	r8,0x2
800025c2:	e0 38 ff 00 	sub	r8,130816
800025c6:	70 09       	ld.w	r9,r8[0x0]
800025c8:	a1 d9       	cbr	r9,0x1
800025ca:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
800025cc:	f0 1f 00 02 	mcall	800025d4 <udd_ep_free+0x2c>
}
800025d0:	d8 02       	popm	pc
800025d2:	00 00       	add	r0,r0
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	25 88       	sub	r8,88

800025d8 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
800025d8:	eb cd 40 fc 	pushm	r2-r7,lr
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
	ep &= USB_EP_ADDR_MASK;
800025dc:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
800025e0:	30 37       	mov	r7,3
800025e2:	ee 0e 18 00 	cp.b	lr,r7
800025e6:	e0 8b 00 99 	brhi	80002718 <udd_ep_run+0x140>
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
800025ea:	fe 67 00 00 	mov	r7,-131072
800025ee:	6e 76       	ld.w	r6,r7[0x1c]
800025f0:	1c 95       	mov	r5,lr
800025f2:	30 17       	mov	r7,1
800025f4:	ee 0e 09 47 	lsl	r7,r7,lr
800025f8:	0c 67       	and	r7,r6
800025fa:	e0 80 00 8f 	breq	80002718 <udd_ep_run+0x140>
			|| Is_udd_endpoint_stall_requested(ep)
800025fe:	fc 06 15 02 	lsl	r6,lr,0x2
80002602:	fe 64 01 c0 	mov	r4,-130624
80002606:	ec 04 00 07 	add	r7,r6,r4
8000260a:	6e 07       	ld.w	r7,r7[0x0]
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
8000260c:	e6 17 00 08 	andh	r7,0x8,COH
80002610:	e0 81 00 84 	brne	80002718 <udd_ep_run+0x140>
	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
80002614:	fc c7 00 01 	sub	r7,lr,1
80002618:	a5 67       	lsl	r7,0x4
8000261a:	4c 14       	lddpc	r4,8000271c <udd_ep_run+0x144>
8000261c:	e8 07 00 07 	add	r7,r4,r7

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested)
80002620:	6e 04       	ld.w	r4,r7[0x0]
80002622:	e6 14 10 00 	andh	r4,0x1000,COH
80002626:	c7 91       	brne	80002718 <udd_ep_run+0x140>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002628:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
8000262c:	d3 03       	ssrf	0x10
		return false;	// Endpoint is halted

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
8000262e:	6e 03       	ld.w	r3,r7[0x0]
80002630:	58 03       	cp.w	r3,0
80002632:	c0 54       	brge	8000263c <udd_ep_run+0x64>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002634:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
80002638:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
	bool b_dir_in;
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
8000263c:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false;	// Job already on going
	}
	ptr_job->busy = true;
80002640:	6e 03       	ld.w	r3,r7[0x0]
80002642:	30 12       	mov	r2,1
80002644:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
80002648:	8f 03       	st.w	r7[0x0],r3
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000264a:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);
	ptr_job->buf = buf;
8000264e:	8f 1a       	st.w	r7[0x4],r10
	ptr_job->call_trans = callback;
80002650:	8f 38       	st.w	r7[0xc],r8
	ptr_job->b_raise_dma = false;
80002652:	6e 08       	ld.w	r8,r7[0x0]
80002654:	30 04       	mov	r4,0
80002656:	f1 d4 d3 a1 	bfins	r8,r4,0x1d,0x1
8000265a:	8f 08       	st.w	r7[0x0],r8

	// The USBB supports a maximum transfer size of 64KB
	if (0x10000 <= buf_size) {
8000265c:	e0 49 ff ff 	cp.w	r9,65535
80002660:	e0 88 00 07 	brls	8000266e <udd_ep_run+0x96>
		// Transfer size = 64KB
		ptr_job->buf_size = 0x10000;
80002664:	e0 78 00 00 	mov	r8,65536
80002668:	8f 28       	st.w	r7[0x8],r8
8000266a:	08 99       	mov	r9,r4
8000266c:	c3 58       	rjmp	800026d6 <udd_ep_run+0xfe>
		buf_size = 0;
	} else {
		ptr_job->buf_size = buf_size;
8000266e:	8f 29       	st.w	r7[0x8],r9
		if (b_dir_in) {
80002670:	58 0c       	cp.w	r12,0
80002672:	c3 20       	breq	800026d6 <udd_ep_run+0xfe>
			if (buf_size==0) {
80002674:	58 09       	cp.w	r9,0
80002676:	c1 71       	brne	800026a4 <udd_ep_run+0xcc>
				// The USB DMA can't send a empty buffer
				// thus we raise the DMA interrupt end of transfert 
				// to execute ZLP process
				ptr_job->b_raise_dma = true;
80002678:	6e 08       	ld.w	r8,r7[0x0]
8000267a:	30 1c       	mov	r12,1
				ptr_job->b_send_zlp = true;
8000267c:	bd b8       	sbr	r8,0x1d
8000267e:	f1 dc d3 c1 	bfins	r8,r12,0x1e,0x1
80002682:	8f 08       	st.w	r7[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002684:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002688:	d3 03       	ssrf	0x10
				flags = cpu_irq_save();
				udd_enable_endpoint_dma_interrupt(ep);
8000268a:	20 15       	sub	r5,1
8000268c:	fc 19 02 00 	movh	r9,0x200
80002690:	f2 05 09 49 	lsl	r9,r9,r5
80002694:	fe 68 00 00 	mov	r8,-131072
80002698:	91 69       	st.w	r8[0x18],r9
				udd_raise_endpoint_dma_interrupt(ep);
8000269a:	91 39       	st.w	r8[0xc],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000269c:	e3 ba 00 00 	mtsr	0x0,r10
				cpu_irq_restore(flags);
				return true;
800026a0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			}
			if (0 != buf_size % udd_get_endpoint_size(ep)) {
800026a4:	e0 36 ff 00 	sub	r6,130816
800026a8:	6c 08       	ld.w	r8,r6[0x0]
800026aa:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
800026ae:	30 86       	mov	r6,8
800026b0:	ec 08 09 48 	lsl	r8,r6,r8
800026b4:	20 18       	sub	r8,1
800026b6:	12 68       	and	r8,r9
800026b8:	c0 b0       	breq	800026ce <udd_ep_run+0xf6>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
800026ba:	6e 08       	ld.w	r8,r7[0x0]
800026bc:	30 0b       	mov	r11,0
800026be:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
800026c2:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
800026c4:	a5 6e       	lsl	lr,0x4
800026c6:	e0 3e fd 00 	sub	lr,130304
800026ca:	9d 1a       	st.w	lr[0x4],r10
800026cc:	c1 18       	rjmp	800026ee <udd_ep_run+0x116>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
			}else{
				ptr_job->b_send_zlp = b_shortpacket;
800026ce:	6e 08       	ld.w	r8,r7[0x0]
800026d0:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
800026d4:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
800026d6:	a5 6e       	lsl	lr,0x4
800026d8:	e0 3e fd 00 	sub	lr,130304
800026dc:	9d 1a       	st.w	lr[0x4],r10
	if (b_shortpacket) {
800026de:	58 0b       	cp.w	r11,0
800026e0:	c0 31       	brne	800026e6 <udd_ep_run+0x10e>
800026e2:	30 08       	mov	r8,0
800026e4:	c0 68       	rjmp	800026f0 <udd_ep_run+0x118>
		if (b_dir_in) {
800026e6:	58 0c       	cp.w	r12,0
800026e8:	c0 31       	brne	800026ee <udd_ep_run+0x116>
800026ea:	31 48       	mov	r8,20
800026ec:	c0 28       	rjmp	800026f0 <udd_ep_run+0x118>
800026ee:	30 88       	mov	r8,8
		} else {
			udd_dma_ctrl = AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
					| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
		}
	}
	udd_dma_ctrl |= (buf_size <<
800026f0:	e8 18 00 21 	orl	r8,0x21
			AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
			& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
	udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
800026f4:	f1 e9 11 09 	or	r9,r8,r9<<0x10
			AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;
	udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
800026f8:	9d 29       	st.w	lr[0x8],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026fa:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800026fe:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_endpoint_dma_interrupt(ep);
80002700:	20 15       	sub	r5,1
80002702:	fc 19 02 00 	movh	r9,0x200
80002706:	f2 05 09 45 	lsl	r5,r9,r5
8000270a:	fe 69 00 00 	mov	r9,-131072
8000270e:	93 65       	st.w	r9[0x18],r5
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002710:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
80002714:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
	cpu_irq_restore(flags);

	return true;
80002718:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
8000271c:	00 00       	add	r0,r0
8000271e:	07 18       	ld.sh	r8,r3++

80002720 <udd_sleep_mode>:
 * 
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
80002720:	58 0c       	cp.w	r12,0
80002722:	c1 11       	brne	80002744 <udd_sleep_mode+0x24>
80002724:	49 18       	lddpc	r8,80002768 <udd_sleep_mode+0x48>
80002726:	11 89       	ld.ub	r9,r8[0x0]
80002728:	30 08       	mov	r8,0
8000272a:	f0 09 18 00 	cp.b	r9,r8
8000272e:	c1 a0       	breq	80002762 <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002730:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002734:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002736:	48 e8       	lddpc	r8,8000276c <udd_sleep_mode+0x4c>
80002738:	11 9a       	ld.ub	r10,r8[0x1]
8000273a:	2f fa       	sub	r10,-1
8000273c:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000273e:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002742:	c1 08       	rjmp	80002762 <udd_sleep_mode+0x42>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
80002744:	48 98       	lddpc	r8,80002768 <udd_sleep_mode+0x48>
80002746:	11 89       	ld.ub	r9,r8[0x0]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c0 a1       	brne	80002762 <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002750:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002754:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
80002756:	48 68       	lddpc	r8,8000276c <udd_sleep_mode+0x4c>
80002758:	11 9a       	ld.ub	r10,r8[0x1]
8000275a:	20 1a       	sub	r10,1
8000275c:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000275e:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
80002762:	48 28       	lddpc	r8,80002768 <udd_sleep_mode+0x48>
80002764:	b0 8c       	st.b	r8[0x0],r12
}
80002766:	5e fc       	retal	r12
80002768:	00 00       	add	r0,r0
8000276a:	07 48       	ld.w	r8,--r3
8000276c:	00 00       	add	r0,r0
8000276e:	0a 18       	sub	r8,r5

80002770 <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
80002770:	d4 01       	pushm	lr
	otg_unfreeze_clock();
80002772:	fe 68 00 00 	mov	r8,-131072
80002776:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000277a:	af c9       	cbr	r9,0xe
8000277c:	f1 49 08 00 	st.w	r8[2048],r9
	// Detach device from the bus
	udd_detach_device();
80002780:	70 09       	ld.w	r9,r8[0x0]
80002782:	a9 a9       	sbr	r9,0x8
80002784:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
80002786:	30 0c       	mov	r12,0
80002788:	f0 1f 00 02 	mcall	80002790 <udd_detach+0x20>
}
8000278c:	d8 02       	popm	pc
8000278e:	00 00       	add	r0,r0
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	27 20       	sub	r0,114

80002794 <udd_ctrl_init>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002794:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002798:	d3 03       	ssrf	0x10
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI), 
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI 
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
8000279a:	30 1a       	mov	r10,1
8000279c:	fe 69 02 20 	mov	r9,-130528
800027a0:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027a2:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
800027a6:	30 29       	mov	r9,2
800027a8:	fe 68 01 60 	mov	r8,-130720
800027ac:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
800027ae:	48 59       	lddpc	r9,800027c0 <udd_ctrl_init+0x2c>
800027b0:	30 08       	mov	r8,0
800027b2:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
800027b4:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
800027b6:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
800027b8:	48 39       	lddpc	r9,800027c4 <udd_ctrl_init+0x30>
800027ba:	93 08       	st.w	r9[0x0],r8
}
800027bc:	5e fc       	retal	r12
800027be:	00 00       	add	r0,r0
800027c0:	00 00       	add	r0,r0
800027c2:	0a 00       	add	r0,r5
800027c4:	00 00       	add	r0,r0
800027c6:	07 4c       	ld.w	r12,--r3

800027c8 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
800027c8:	30 39       	mov	r9,3
800027ca:	48 a8       	lddpc	r8,800027f0 <udd_ctrl_send_zlp_in+0x28>
800027cc:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027ce:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
800027d2:	d3 03       	ssrf	0x10
	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
800027d4:	fe 6a 01 60 	mov	r10,-130720
800027d8:	30 19       	mov	r9,1
800027da:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
800027dc:	fe 68 01 f0 	mov	r8,-130576
800027e0:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
800027e2:	30 89       	mov	r9,8
800027e4:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
800027e6:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027e8:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
800027ec:	5e fc       	retal	r12
800027ee:	00 00       	add	r0,r0
800027f0:	00 00       	add	r0,r0
800027f2:	07 4c       	ld.w	r12,--r3

800027f4 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
800027f4:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027f8:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800027fc:	d3 03       	ssrf	0x10
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
800027fe:	30 1a       	mov	r10,1
80002800:	fe 69 02 20 	mov	r9,-130528
80002804:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002806:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
8000280a:	4c 38       	lddpc	r8,80002914 <udd_ctrl_in_sent+0x120>
8000280c:	70 08       	ld.w	r8,r8[0x0]
8000280e:	58 38       	cp.w	r8,3
80002810:	c0 71       	brne	8000281e <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
80002812:	f0 1f 00 42 	mcall	80002918 <udd_ctrl_in_sent+0x124>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002816:	f0 1f 00 42 	mcall	8000291c <udd_ctrl_in_sent+0x128>
		return;
8000281a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
8000281e:	4c 18       	lddpc	r8,80002920 <udd_ctrl_in_sent+0x12c>
80002820:	90 68       	ld.sh	r8,r8[0xc]
80002822:	4c 19       	lddpc	r9,80002924 <udd_ctrl_in_sent+0x130>
80002824:	92 07       	ld.sh	r7,r9[0x0]
80002826:	f0 07 01 07 	sub	r7,r8,r7
8000282a:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
8000282c:	c3 b1       	brne	800028a2 <udd_ctrl_in_sent+0xae>
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
8000282e:	4b f9       	lddpc	r9,80002928 <udd_ctrl_in_sent+0x134>
80002830:	13 8a       	ld.ub	r10,r9[0x0]
80002832:	30 09       	mov	r9,0
80002834:	f2 0a 18 00 	cp.b	r10,r9
80002838:	c1 21       	brne	8000285c <udd_ctrl_in_sent+0x68>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
8000283a:	30 49       	mov	r9,4
8000283c:	4b 68       	lddpc	r8,80002914 <udd_ctrl_in_sent+0x120>
8000283e:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002840:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002844:	d3 03       	ssrf	0x10
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
80002846:	31 08       	mov	r8,16
80002848:	fe 6a 01 60 	mov	r10,-130720
8000284c:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
8000284e:	fe 6a 01 f0 	mov	r10,-130576
80002852:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002854:	e3 b9 00 00 	mtsr	0x0,r9
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
80002858:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
8000285c:	4b 19       	lddpc	r9,80002920 <udd_ctrl_in_sent+0x12c>
8000285e:	92 b9       	ld.uh	r9,r9[0x6]
80002860:	5c 78       	castu.h	r8
80002862:	4b 3a       	lddpc	r10,8000292c <udd_ctrl_in_sent+0x138>
80002864:	94 8a       	ld.uh	r10,r10[0x0]
80002866:	14 08       	add	r8,r10
80002868:	10 39       	cp.w	r9,r8
8000286a:	e0 89 00 08 	brgt	8000287a <udd_ctrl_in_sent+0x86>
								+
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
8000286e:	4a d8       	lddpc	r8,80002920 <udd_ctrl_in_sent+0x12c>
80002870:	70 5c       	ld.w	r12,r8[0x14]
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002872:	58 0c       	cp.w	r12,0
80002874:	c0 30       	breq	8000287a <udd_ctrl_in_sent+0x86>
80002876:	5d 1c       	icall	r12
80002878:	c0 51       	brne	80002882 <udd_ctrl_in_sent+0x8e>
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun or data packet complette than send zlp on IN (note don't change DataToggle)
			udd_ctrl_payload_need_in_zlp = false;
8000287a:	30 09       	mov	r9,0
8000287c:	4a b8       	lddpc	r8,80002928 <udd_ctrl_in_sent+0x134>
8000287e:	b0 89       	st.b	r8[0x0],r9
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002880:	c1 18       	rjmp	800028a2 <udd_ctrl_in_sent+0xae>
			udd_ctrl_payload_need_in_zlp = false;
			// nb_remain==0 allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			// Update number of total data sending by previous playlaod buffer
			udd_ctrl_prev_payload_nb_trans +=
80002882:	4a b9       	lddpc	r9,8000292c <udd_ctrl_in_sent+0x138>
80002884:	4a 88       	lddpc	r8,80002924 <udd_ctrl_in_sent+0x130>
80002886:	90 0b       	ld.sh	r11,r8[0x0]
80002888:	92 0a       	ld.sh	r10,r9[0x0]
8000288a:	f6 0a 00 0a 	add	r10,r11,r10
8000288e:	b2 0a       	st.h	r9[0x0],r10
					udd_ctrl_payload_nb_trans;
			// Update maangement of current playoad transfer
			udd_ctrl_payload_nb_trans = 0;
80002890:	30 09       	mov	r9,0
80002892:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
80002894:	4a 38       	lddpc	r8,80002920 <udd_ctrl_in_sent+0x12c>
80002896:	90 67       	ld.sh	r7,r8[0xc]
			// Compute if an IN ZLP must be send after IN data
			udd_ctrl_payload_need_in_zlp =
80002898:	f1 d7 c0 06 	bfextu	r8,r7,0x0,0x6
8000289c:	5f 09       	sreq	r9
8000289e:	4a 38       	lddpc	r8,80002928 <udd_ctrl_in_sent+0x134>
800028a0:	b0 89       	st.b	r8[0x0],r9
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800028a2:	4a 08       	lddpc	r8,80002920 <udd_ctrl_in_sent+0x12c>
800028a4:	70 2a       	ld.w	r10,r8[0x8]
800028a6:	4a 08       	lddpc	r8,80002924 <udd_ctrl_in_sent+0x130>
800028a8:	90 09       	ld.sh	r9,r8[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800028aa:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
800028ae:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write 
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
800028b0:	fe 68 01 30 	mov	r8,-130768
800028b4:	70 08       	ld.w	r8,r8[0x0]
800028b6:	e2 18 00 02 	andl	r8,0x2,COH
800028ba:	c0 91       	brne	800028cc <udd_ctrl_in_sent+0xd8>
800028bc:	34 08       	mov	r8,64
800028be:	f0 07 19 00 	cp.h	r7,r8
800028c2:	f9 b7 0b 40 	movhi	r7,64
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800028c6:	58 07       	cp.w	r7,0
800028c8:	c0 91       	brne	800028da <udd_ctrl_in_sent+0xe6>
800028ca:	c1 48       	rjmp	800028f2 <udd_ctrl_in_sent+0xfe>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800028cc:	e3 bb 00 00 	mtsr	0x0,r11
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800028d0:	30 49       	mov	r9,4
800028d2:	49 18       	lddpc	r8,80002914 <udd_ctrl_in_sent+0x120>
800028d4:	91 09       	st.w	r8[0x0],r9
		return;	// Exit of IN DATA phase
800028d6:	e3 cd 80 80 	ldm	sp++,r7,pc
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800028da:	5c 79       	castu.h	r9
800028dc:	f4 09 00 09 	add	r9,r10,r9
800028e0:	fc 18 e0 00 	movh	r8,0xe000
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
800028e4:	13 3a       	ld.ub	r10,r9++
800028e6:	10 ca       	st.b	r8++,r10
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800028e8:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
800028ec:	ee 0a 19 00 	cp.h	r10,r7
800028f0:	cf a3       	brcs	800028e4 <udd_ctrl_in_sent+0xf0>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
800028f2:	48 d8       	lddpc	r8,80002924 <udd_ctrl_in_sent+0x130>
800028f4:	90 09       	ld.sh	r9,r8[0x0]
800028f6:	f2 07 00 07 	add	r7,r9,r7
800028fa:	b0 07       	st.h	r8[0x0],r7

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
800028fc:	30 18       	mov	r8,1
800028fe:	fe 69 01 60 	mov	r9,-130720
80002902:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
80002904:	fe 69 01 f0 	mov	r9,-130576
80002908:	93 08       	st.w	r9[0x0],r8
8000290a:	e3 bb 00 00 	mtsr	0x0,r11
#endif
	barrier();
8000290e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002912:	00 00       	add	r0,r0
80002914:	00 00       	add	r0,r0
80002916:	07 4c       	ld.w	r12,--r3
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	25 54       	sub	r4,85
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	27 94       	sub	r4,121
80002920:	00 00       	add	r0,r0
80002922:	0a 00       	add	r0,r5
80002924:	00 00       	add	r0,r0
80002926:	07 4a       	ld.w	r10,--r3
80002928:	00 00       	add	r0,r0
8000292a:	07 50       	ld.sh	r0,--r3
8000292c:	00 00       	add	r0,r0
8000292e:	07 14       	ld.sh	r4,r3++

80002930 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
80002930:	eb cd 40 e0 	pushm	r5-r7,lr
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
80002934:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (ep > USB_DEVICE_MAX_EP)
80002938:	30 39       	mov	r9,3
8000293a:	f2 08 18 00 	cp.b	r8,r9
8000293e:	e0 8b 00 88 	brhi	80002a4e <udd_ep_alloc+0x11e>
		return false;
	if (Is_udd_endpoint_enabled(ep))
80002942:	fe 69 00 00 	mov	r9,-131072
80002946:	72 79       	ld.w	r9,r9[0x1c]
80002948:	30 17       	mov	r7,1
8000294a:	ee 08 09 47 	lsl	r7,r7,r8
8000294e:	ef e9 00 09 	and	r9,r7,r9
80002952:	c7 e1       	brne	80002a4e <udd_ep_alloc+0x11e>
		return false;

	// Bank choise
	switch(bmAttributes&USB_EP_TYPE_MASK) {
80002954:	f3 db c0 02 	bfextu	r9,r11,0x0,0x2
80002958:	58 19       	cp.w	r9,1
8000295a:	c7 a5       	brlt	80002a4e <udd_ep_alloc+0x11e>
8000295c:	58 29       	cp.w	r9,2
8000295e:	e0 8a 00 06 	brle	8000296a <udd_ep_alloc+0x3a>
80002962:	58 39       	cp.w	r9,3
80002964:	c7 51       	brne	80002a4e <udd_ep_alloc+0x11e>
80002966:	30 06       	mov	r6,0
80002968:	c0 28       	rjmp	8000296c <udd_ep_alloc+0x3c>
8000296a:	30 16       	mov	r6,1
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);
		   
	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
8000296c:	f0 09 15 02 	lsl	r9,r8,0x2
80002970:	e0 39 ff 00 	sub	r9,130816
80002974:	72 0e       	ld.w	lr,r9[0x0]
80002976:	5c 7a       	castu.h	r10
80002978:	30 85       	mov	r5,8
8000297a:	f4 05 0c 4a 	max	r10,r10,r5
8000297e:	e0 65 04 00 	mov	r5,1024
80002982:	f4 05 0d 4a 	min	r10,r10,r5
80002986:	a1 7a       	lsl	r10,0x1
80002988:	20 1a       	sub	r10,1
8000298a:	f4 0a 12 00 	clz	r10,r10
8000298e:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
80002992:	ab 7b       	lsl	r11,0xb
80002994:	e2 1b 18 00 	andl	r11,0x1800,COH
80002998:	f7 ec 10 8c 	or	r12,r11,r12<<0x8
8000299c:	f4 0b 11 1c 	rsub	r11,r10,28
800029a0:	f9 eb 10 4b 	or	r11,r12,r11<<0x4
800029a4:	f7 e6 10 2b 	or	r11,r11,r6<<0x2
800029a8:	e2 1b 19 7c 	andl	r11,0x197c,COH
800029ac:	1c 9a       	mov	r10,lr
800029ae:	e0 1a e6 83 	andl	r10,0xe683
800029b2:	f7 ea 10 0a 	or	r10,r11,r10
800029b6:	93 0a       	st.w	r9[0x0],r10
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
800029b8:	5c 87       	casts.h	r7

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800029ba:	30 29       	mov	r9,2
800029bc:	f2 08 18 00 	cp.b	r8,r9
800029c0:	e0 8b 00 1d 	brhi	800029fa <udd_ep_alloc+0xca>
800029c4:	fe 6a 01 0c 	mov	r10,-130804
800029c8:	30 39       	mov	r9,3
		if (Is_udd_endpoint_enabled(i)) {
800029ca:	fe 6c 00 00 	mov	r12,-131072
800029ce:	30 16       	mov	r6,1
800029d0:	78 7e       	ld.w	lr,r12[0x1c]
800029d2:	ec 09 09 4b 	lsl	r11,r6,r9
800029d6:	f7 ee 00 0e 	and	lr,r11,lr
800029da:	c0 b0       	breq	800029f0 <udd_ep_alloc+0xc0>
			ep_allocated |= 1 << i;
800029dc:	f7 e7 10 07 	or	r7,r11,r7
800029e0:	5c 87       	casts.h	r7
			udd_disable_endpoint(i);
800029e2:	78 7e       	ld.w	lr,r12[0x1c]
800029e4:	5c db       	com	r11
800029e6:	1c 6b       	and	r11,lr
800029e8:	99 7b       	st.w	r12[0x1c],r11
			udd_unallocate_memory(i);
800029ea:	74 0b       	ld.w	r11,r10[0x0]
800029ec:	a1 db       	cbr	r11,0x1
800029ee:	95 0b       	st.w	r10[0x0],r11
800029f0:	20 19       	sub	r9,1
800029f2:	20 4a       	sub	r10,4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800029f4:	f2 08 18 00 	cp.b	r8,r9
800029f8:	ce c3       	brcs	800029d0 <udd_ep_alloc+0xa0>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
800029fa:	0e 9c       	mov	r12,r7
800029fc:	5c 7c       	castu.h	r12
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
800029fe:	fe 6e 00 00 	mov	lr,-131072
80002a02:	30 16       	mov	r6,1
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80002a04:	30 37       	mov	r7,3
		if (ep_allocated & (1 << i)) {
80002a06:	f8 08 08 49 	asr	r9,r12,r8
80002a0a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002a0e:	c1 80       	breq	80002a3e <udd_ep_alloc+0x10e>
			udd_allocate_memory(i);
80002a10:	f0 0b 15 02 	lsl	r11,r8,0x2
80002a14:	fe 65 01 00 	mov	r5,-130816
80002a18:	f6 05 00 09 	add	r9,r11,r5
80002a1c:	72 05       	ld.w	r5,r9[0x0]
80002a1e:	a1 b5       	sbr	r5,0x1
80002a20:	93 05       	st.w	r9[0x0],r5
			udd_enable_endpoint(i);
80002a22:	7c 75       	ld.w	r5,lr[0x1c]
80002a24:	ec 08 09 4a 	lsl	r10,r6,r8
80002a28:	0a 4a       	or	r10,r5
80002a2a:	9d 7a       	st.w	lr[0x1c],r10
			if (!Is_udd_endpoint_configured(i))
80002a2c:	e0 3b fe d0 	sub	r11,130768
80002a30:	76 0a       	ld.w	r10,r11[0x0]
80002a32:	e6 1a 00 04 	andh	r10,0x4,COH
80002a36:	c0 c0       	breq	80002a4e <udd_ep_alloc+0x11e>
				return false;
			udd_enable_endpoint_bank_autoswitch(i);	
80002a38:	72 0a       	ld.w	r10,r9[0x0]
80002a3a:	a9 ba       	sbr	r10,0x9
80002a3c:	93 0a       	st.w	r9[0x0],r10
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80002a3e:	2f f8       	sub	r8,-1
80002a40:	5c 58       	castu.b	r8
80002a42:	ee 08 18 00 	cp.b	r8,r7
80002a46:	fe 98 ff e0 	brls	80002a06 <udd_ep_alloc+0xd6>
80002a4a:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002a4e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

80002a52 <udd_reset_ep_ctrl>:

static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;
	// Reset USB address to 0
	udd_configure_address(0);
80002a52:	fe 68 00 00 	mov	r8,-131072
80002a56:	70 09       	ld.w	r9,r8[0x0]
80002a58:	e0 19 ff 80 	andl	r9,0xff80
80002a5c:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80002a5e:	70 09       	ld.w	r9,r8[0x0]
80002a60:	a7 b9       	sbr	r9,0x7
80002a62:	91 09       	st.w	r8[0x0],r9
	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80002a64:	fe 69 01 00 	mov	r9,-130816
80002a68:	72 0b       	ld.w	r11,r9[0x0]
80002a6a:	30 8c       	mov	r12,8
80002a6c:	34 0a       	mov	r10,64
80002a6e:	f4 0c 0c 4a 	max	r10,r10,r12
80002a72:	e0 6c 04 00 	mov	r12,1024
80002a76:	f4 0c 0d 4a 	min	r10,r10,r12
80002a7a:	a1 7a       	lsl	r10,0x1
80002a7c:	20 1a       	sub	r10,1
80002a7e:	f4 0a 12 00 	clz	r10,r10
80002a82:	f4 0a 11 1c 	rsub	r10,r10,28
80002a86:	a5 6a       	lsl	r10,0x4
80002a88:	e2 1a 19 7c 	andl	r10,0x197c,COH
80002a8c:	e0 1b e6 83 	andl	r11,0xe683
80002a90:	16 4a       	or	r10,r11
80002a92:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80002a94:	72 0a       	ld.w	r10,r9[0x0]
80002a96:	a1 ba       	sbr	r10,0x1
80002a98:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(0);
80002a9a:	70 79       	ld.w	r9,r8[0x1c]
80002a9c:	a1 a9       	sbr	r9,0x0
80002a9e:	91 79       	st.w	r8[0x1c],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002aa0:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002aa4:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002aa6:	fe 69 01 f0 	mov	r9,-130576
80002aaa:	30 4b       	mov	r11,4
80002aac:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
80002aae:	30 2b       	mov	r11,2
80002ab0:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002ab2:	e0 69 10 00 	mov	r9,4096
80002ab6:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002ab8:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);
}
80002abc:	5e fc       	retal	r12
80002abe:	d7 03       	nop

80002ac0 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80002ac0:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002ac4:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002ac8:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown, 
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002aca:	30 1c       	mov	r12,1
80002acc:	f0 1f 00 15 	mcall	80002b20 <udd_attach+0x60>
	otg_unfreeze_clock();
80002ad0:	fe 67 00 00 	mov	r7,-131072
80002ad4:	ee f8 08 00 	ld.w	r8,r7[2048]
80002ad8:	af c8       	cbr	r8,0xe
80002ada:	ef 48 08 00 	st.w	r7[2048],r8
#else
	// Check USB clock because the source can be a PLL
	while( !Is_clock_usable() );
#endif
	// Authorize attach if VBus is present
	udd_attach_device();
80002ade:	6e 08       	ld.w	r8,r7[0x0]
80002ae0:	a9 c8       	cbr	r8,0x8
80002ae2:	8f 08       	st.w	r7[0x0],r8

	// (RESET_AND_WAKEUP)
	// After the attach and the first USB suspend, the following USB Reset time can be inferior to CPU restart clock time.
	// Thus, the USB Reset state is not detected and endpoint control is not allocated
	// In this case, a Reset is do automatically after attach.
	udc_reset();	// Reset USB Device Stack Core
80002ae4:	f0 1f 00 10 	mcall	80002b24 <udd_attach+0x64>
	udd_reset_ep_ctrl();	// Reset endpoint control
80002ae8:	f0 1f 00 10 	mcall	80002b28 <udd_attach+0x68>
	udd_ctrl_init();	// Reset endpoint control management
80002aec:	f0 1f 00 10 	mcall	80002b2c <udd_attach+0x6c>

	// Enable USB line events
	udd_enable_reset_interrupt();
80002af0:	30 8b       	mov	r11,8
80002af2:	8f 6b       	st.w	r7[0x18],r11
	udd_enable_suspend_interrupt();
80002af4:	30 19       	mov	r9,1
80002af6:	8f 69       	st.w	r7[0x18],r9
	udd_enable_wake_up_interrupt();
80002af8:	31 08       	mov	r8,16
80002afa:	8f 68       	st.w	r7[0x18],r8
	udd_enable_sof_interrupt();
80002afc:	30 4a       	mov	r10,4
80002afe:	8f 6a       	st.w	r7[0x18],r10
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
80002b00:	8f 2b       	st.w	r7[0x8],r11
	udd_ack_sof();
80002b02:	8f 2a       	st.w	r7[0x8],r10
	udd_ack_msof();
80002b04:	30 2a       	mov	r10,2
80002b06:	8f 2a       	st.w	r7[0x8],r10

	// The first suspend interrupt must be forced
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
80002b08:	8f 29       	st.w	r7[0x8],r9
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
#endif
	udd_ack_wake_up();
80002b0a:	8f 28       	st.w	r7[0x8],r8
	otg_freeze_clock();
80002b0c:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b10:	af a8       	sbr	r8,0xe
80002b12:	ef 48 08 00 	st.w	r7[2048],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002b16:	e3 b6 00 00 	mtsr	0x0,r6
	cpu_irq_restore(flags);
}
80002b1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b1e:	00 00       	add	r0,r0
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	27 20       	sub	r0,114
80002b24:	80 00       	ld.sh	r0,r0[0x0]
80002b26:	39 f4       	mov	r4,-97
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	2a 52       	sub	r2,-91
80002b2c:	80 00       	ld.sh	r0,r0[0x0]
80002b2e:	27 94       	sub	r4,121

80002b30 <udd_enable>:
	return true;
}


void udd_enable(void)
{
80002b30:	eb cd 40 c0 	pushm	r6-r7,lr
	irqflags_t flags;
	sysclk_enable_usb();
80002b34:	f0 1f 00 39 	mcall	80002c18 <udd_enable+0xe8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b38:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002b3c:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	//** Enable USB hardware
	otg_disable();
80002b3e:	fe 67 00 00 	mov	r7,-131072
80002b42:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b46:	af d8       	cbr	r8,0xf
80002b48:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_enabled();
80002b4c:	ee f8 08 00 	ld.w	r8,r7[2048]
	// Check UID pin state before enter in USB device mode
	if (!Is_otg_id_device())
		return false;
#else
	// Here, only the Device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBB_IRQ, UDD_USB_INT_LEVEL);
80002b50:	30 0a       	mov	r10,0
80002b52:	e0 6b 02 20 	mov	r11,544
80002b56:	4b 2c       	lddpc	r12,80002c1c <udd_enable+0xec>
80002b58:	f0 1f 00 32 	mcall	80002c20 <udd_enable+0xf0>
	otg_force_device_mode();
80002b5c:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b60:	b9 b8       	sbr	r8,0x19
80002b62:	ef 48 08 00 	st.w	r7[2048],r8
80002b66:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b6a:	b9 c8       	cbr	r8,0x18
80002b6c:	ef 48 08 00 	st.w	r7[2048],r8
#endif
	otg_disable_pad();
80002b70:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b74:	ad c8       	cbr	r8,0xc
80002b76:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable_pad();
80002b7a:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b7e:	ad a8       	sbr	r8,0xc
80002b80:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable();
80002b84:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b88:	af b8       	sbr	r8,0xf
80002b8a:	ef 48 08 00 	st.w	r7[2048],r8
	otg_unfreeze_clock();
80002b8e:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b92:	af c8       	cbr	r8,0xe
80002b94:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_clock_frozen();
80002b98:	ee f8 08 00 	ld.w	r8,r7[2048]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002b9c:	4a 28       	lddpc	r8,80002c24 <udd_enable+0xf4>
80002b9e:	70 0a       	ld.w	r10,r8[0x0]
80002ba0:	30 09       	mov	r9,0
		udd_ep_job[i].stall_requested = false;
80002ba2:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002ba6:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002baa:	91 0a       	st.w	r8[0x0],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002bac:	70 4a       	ld.w	r10,r8[0x10]
		udd_ep_job[i].stall_requested = false;
80002bae:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002bb2:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002bb6:	91 4a       	st.w	r8[0x10],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002bb8:	70 8a       	ld.w	r10,r8[0x20]
		udd_ep_job[i].stall_requested = false;
80002bba:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002bbe:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002bc2:	91 8a       	st.w	r8[0x20],r10

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80002bc4:	6e 08       	ld.w	r8,r7[0x0]
80002bc6:	ad c8       	cbr	r8,0xc
80002bc8:	8f 08       	st.w	r7[0x0],r8
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80002bca:	6e 08       	ld.w	r8,r7[0x0]
80002bcc:	e8 18 0c 00 	orl	r8,0xc00
80002bd0:	8f 08       	st.w	r7[0x0],r8
#  endif
#endif
	udd_enable_vbus_interrupt();
80002bd2:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bd6:	a1 b8       	sbr	r8,0x1
80002bd8:	ef 48 08 00 	st.w	r7[2048],r8
	otg_freeze_clock();
80002bdc:	ee f8 08 00 	ld.w	r8,r7[2048]
80002be0:	af a8       	sbr	r8,0xe
80002be2:	ef 48 08 00 	st.w	r7[2048],r8
	// Always authorize asynchrone USB interrupts to exit of sleep mode
	AVR32_PM.AWEN.usb_waken = 1;
80002be6:	fe 78 0c 00 	mov	r8,-62464
80002bea:	f0 fa 01 44 	ld.w	r10,r8[324]
80002bee:	30 1b       	mov	r11,1
80002bf0:	f5 db d0 01 	bfins	r10,r11,0x0,0x1
80002bf4:	f1 4a 01 44 	st.w	r8[324],r10

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
80002bf8:	48 c8       	lddpc	r8,80002c28 <udd_enable+0xf8>
80002bfa:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002bfc:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002c00:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002c02:	48 b8       	lddpc	r8,80002c2c <udd_enable+0xfc>
80002c04:	11 ba       	ld.ub	r10,r8[0x3]
80002c06:	2f fa       	sub	r10,-1
80002c08:	b0 ba       	st.b	r8[0x3],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002c0a:	e3 b9 00 00 	mtsr	0x0,r9
80002c0e:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
80002c12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c16:	00 00       	add	r0,r0
80002c18:	80 00       	ld.sh	r0,r0[0x0]
80002c1a:	32 d8       	mov	r8,45
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	2c 30       	sub	r0,-61
80002c20:	80 00       	ld.sh	r0,r0[0x0]
80002c22:	22 50       	sub	r0,37
80002c24:	00 00       	add	r0,r0
80002c26:	07 18       	ld.sh	r8,r3++
80002c28:	00 00       	add	r0,r0
80002c2a:	07 48       	ld.w	r8,--r3
80002c2c:	00 00       	add	r0,r0
80002c2e:	0a 18       	sub	r8,r5

80002c30 <udd_interrupt>:
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002c30:	eb cd 40 fc 	pushm	r2-r7,lr
	if (Is_udd_sof()) {
80002c34:	fe 68 00 00 	mov	r8,-131072
80002c38:	70 18       	ld.w	r8,r8[0x4]
80002c3a:	e2 18 00 04 	andl	r8,0x4,COH
80002c3e:	c0 f0       	breq	80002c5c <udd_interrupt+0x2c>
		udd_ack_sof();
80002c40:	fe 68 00 00 	mov	r8,-131072
80002c44:	30 49       	mov	r9,4
80002c46:	91 29       	st.w	r8[0x8],r9
		if (Is_udd_full_speed_mode()) {
80002c48:	f0 f8 08 04 	ld.w	r8,r8[2052]
80002c4c:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80002c50:	e0 81 02 ce 	brne	800031ec <udd_interrupt+0x5bc>
		udc_sof_notify();
80002c54:	f0 1f 01 6f 	mcall	80003210 <udd_interrupt+0x5e0>
80002c58:	e0 8f 02 ca 	bral	800031ec <udd_interrupt+0x5bc>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
	}
	if (Is_udd_msof()) {
80002c5c:	fe 68 00 00 	mov	r8,-131072
80002c60:	70 18       	ld.w	r8,r8[0x4]
80002c62:	e2 18 00 02 	andl	r8,0x2,COH
80002c66:	c0 90       	breq	80002c78 <udd_interrupt+0x48>
		udd_ack_msof();
80002c68:	30 29       	mov	r9,2
80002c6a:	fe 68 00 00 	mov	r8,-131072
80002c6e:	91 29       	st.w	r8[0x8],r9
		udc_sof_notify();
80002c70:	f0 1f 01 68 	mcall	80003210 <udd_interrupt+0x5e0>
		goto udd_interrupt_end;
80002c74:	e0 8f 02 bc 	bral	800031ec <udd_interrupt+0x5bc>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0))
80002c78:	fe 68 00 00 	mov	r8,-131072
80002c7c:	70 18       	ld.w	r8,r8[0x4]
80002c7e:	e2 18 10 00 	andl	r8,0x1000,COH
80002c82:	e0 80 01 6f 	breq	80002f60 <udd_interrupt+0x330>
		return false;	// No interrupt events on control endpoint

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002c86:	fe 68 02 20 	mov	r8,-130528
80002c8a:	31 09       	mov	r9,16
80002c8c:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002c8e:	30 89       	mov	r9,8
80002c90:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002c92:	fe 68 01 30 	mov	r8,-130768
80002c96:	70 08       	ld.w	r8,r8[0x0]
80002c98:	e2 18 00 04 	andl	r8,0x4,COH
80002c9c:	e0 80 00 87 	breq	80002daa <udd_interrupt+0x17a>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002ca0:	fe f8 05 74 	ld.w	r8,pc[1396]
80002ca4:	70 08       	ld.w	r8,r8[0x0]
80002ca6:	58 08       	cp.w	r8,0
80002ca8:	c0 50       	breq	80002cb2 <udd_interrupt+0x82>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002caa:	f0 1f 01 5c 	mcall	80003218 <udd_interrupt+0x5e8>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002cae:	f0 1f 01 5c 	mcall	8000321c <udd_interrupt+0x5ec>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80002cb2:	fe 68 01 30 	mov	r8,-130768
80002cb6:	70 08       	ld.w	r8,r8[0x0]
80002cb8:	f1 d8 c2 8b 	bfextu	r8,r8,0x14,0xb
80002cbc:	58 88       	cp.w	r8,8
80002cbe:	c0 90       	breq	80002cd0 <udd_interrupt+0xa0>
		udd_ctrl_stall_data();
80002cc0:	f0 1f 01 58 	mcall	80003220 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002cc4:	30 49       	mov	r9,4
80002cc6:	fe 68 01 60 	mov	r8,-130720
80002cca:	91 09       	st.w	r8[0x0],r9
80002ccc:	e0 8f 02 90 	bral	800031ec <udd_interrupt+0x5bc>
80002cd0:	fc 18 e0 00 	movh	r8,0xe000
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80002cd4:	fe fc 05 50 	ld.w	r12,pc[1360]
80002cd8:	fc 1b 20 00 	movh	r11,0x2000
80002cdc:	f0 0c 00 09 	add	r9,r8,r12
80002ce0:	11 3a       	ld.ub	r10,r8++
80002ce2:	f2 0b 0b 0a 	st.b	r9[r11],r10
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80002ce6:	30 8a       	mov	r10,8
80002ce8:	ea 1a e0 00 	orh	r10,0xe000
80002cec:	14 38       	cp.w	r8,r10
80002cee:	cf 71       	brne	80002cdc <udd_interrupt+0xac>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002cf0:	fe f8 05 34 	ld.w	r8,pc[1332]
80002cf4:	90 19       	ld.sh	r9,r8[0x2]
80002cf6:	5c c9       	swap.bh	r9
80002cf8:	b0 19       	st.h	r8[0x2],r9
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002cfa:	90 29       	ld.sh	r9,r8[0x4]
80002cfc:	5c c9       	swap.bh	r9
80002cfe:	b0 29       	st.h	r8[0x4],r9
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002d00:	90 39       	ld.sh	r9,r8[0x6]
80002d02:	5c c9       	swap.bh	r9
80002d04:	b0 39       	st.h	r8[0x6],r9

	// Decode setup request
	if (udc_process_setup() == false) {
80002d06:	f0 1f 01 49 	mcall	80003228 <udd_interrupt+0x5f8>
80002d0a:	c0 91       	brne	80002d1c <udd_interrupt+0xec>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002d0c:	f0 1f 01 45 	mcall	80003220 <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002d10:	30 49       	mov	r9,4
80002d12:	fe 68 01 60 	mov	r8,-130720
80002d16:	91 09       	st.w	r8[0x0],r9
80002d18:	e0 8f 02 6a 	bral	800031ec <udd_interrupt+0x5bc>
		return;
	}
	udd_ack_setup_received(0);
80002d1c:	30 49       	mov	r9,4
80002d1e:	fe 68 01 60 	mov	r8,-130720
80002d22:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002d24:	fe f8 05 00 	ld.w	r8,pc[1280]
80002d28:	11 89       	ld.ub	r9,r8[0x0]
80002d2a:	30 08       	mov	r8,0
80002d2c:	f0 09 18 00 	cp.b	r9,r8
80002d30:	c1 94       	brge	80002d62 <udd_interrupt+0x132>
		// Compute if an IN ZLP must be send after IN data
		udd_ctrl_payload_need_in_zlp =
80002d32:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002d36:	90 e8       	ld.uh	r8,r8[0xc]
80002d38:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002d3c:	5f 09       	sreq	r9
80002d3e:	fe f8 04 ee 	ld.w	r8,pc[1262]
80002d42:	b0 89       	st.b	r8[0x0],r9
				((udd_g_ctrlreq.payload_size %
						USB_DEVICE_EP_CTRL_SIZE) == 0);
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d44:	30 08       	mov	r8,0
80002d46:	fe f9 04 ea 	ld.w	r9,pc[1258]
80002d4a:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d4c:	fe f9 04 e8 	ld.w	r9,pc[1256]
80002d50:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002d52:	30 29       	mov	r9,2
80002d54:	fe f8 04 c0 	ld.w	r8,pc[1216]
80002d58:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent();	// Send first data transfer
80002d5a:	f0 1f 01 38 	mcall	80003238 <udd_interrupt+0x608>
80002d5e:	e0 8f 02 47 	bral	800031ec <udd_interrupt+0x5bc>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002d62:	fe f8 04 c2 	ld.w	r8,pc[1218]
80002d66:	90 39       	ld.sh	r9,r8[0x6]
80002d68:	30 08       	mov	r8,0
80002d6a:	f0 09 19 00 	cp.h	r9,r8
80002d6e:	c0 51       	brne	80002d78 <udd_interrupt+0x148>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002d70:	f0 1f 01 33 	mcall	8000323c <udd_interrupt+0x60c>
80002d74:	e0 8f 02 3c 	bral	800031ec <udd_interrupt+0x5bc>
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d78:	30 08       	mov	r8,0
80002d7a:	fe f9 04 b6 	ld.w	r9,pc[1206]
80002d7e:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d80:	fe f9 04 b4 	ld.w	r9,pc[1204]
80002d84:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002d86:	30 19       	mov	r9,1
80002d88:	fe f8 04 8c 	ld.w	r8,pc[1164]
80002d8c:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002d8e:	31 08       	mov	r8,16
80002d90:	fe 69 01 60 	mov	r9,-130720
80002d94:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002d96:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002d9a:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002d9c:	fe 6a 01 f0 	mov	r10,-130576
80002da0:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002da2:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002da6:	e0 8f 02 23 	bral	800031ec <udd_interrupt+0x5bc>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002daa:	fe 68 01 30 	mov	r8,-130768
80002dae:	70 08       	ld.w	r8,r8[0x0]
80002db0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002db4:	c0 b0       	breq	80002dca <udd_interrupt+0x19a>
80002db6:	fe 68 01 c0 	mov	r8,-130624
80002dba:	70 08       	ld.w	r8,r8[0x0]
80002dbc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002dc0:	c0 50       	breq	80002dca <udd_interrupt+0x19a>
		// IN packet sent
		udd_ctrl_in_sent();
80002dc2:	f0 1f 01 1e 	mcall	80003238 <udd_interrupt+0x608>
80002dc6:	e0 8f 02 13 	bral	800031ec <udd_interrupt+0x5bc>
		return true;
	}
	if (Is_udd_out_received(0)) {
80002dca:	fe 68 01 30 	mov	r8,-130768
80002dce:	70 08       	ld.w	r8,r8[0x0]
80002dd0:	e2 18 00 02 	andl	r8,0x2,COH
80002dd4:	e0 80 00 a3 	breq	80002f1a <udd_interrupt+0x2ea>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002dd8:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002ddc:	70 08       	ld.w	r8,r8[0x0]
80002dde:	58 18       	cp.w	r8,1
80002de0:	c1 10       	breq	80002e02 <udd_interrupt+0x1d2>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80002de2:	58 28       	cp.w	r8,2
80002de4:	5f 09       	sreq	r9
80002de6:	58 48       	cp.w	r8,4
80002de8:	5f 08       	sreq	r8
80002dea:	f3 e8 10 08 	or	r8,r9,r8
80002dee:	c0 40       	breq	80002df6 <udd_interrupt+0x1c6>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002df0:	f0 1f 01 0a 	mcall	80003218 <udd_interrupt+0x5e8>
80002df4:	c0 38       	rjmp	80002dfa <udd_interrupt+0x1ca>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002df6:	f0 1f 01 0b 	mcall	80003220 <udd_interrupt+0x5f0>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002dfa:	f0 1f 01 09 	mcall	8000321c <udd_interrupt+0x5ec>
80002dfe:	e0 8f 01 f7 	bral	800031ec <udd_interrupt+0x5bc>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
80002e02:	fe 68 01 30 	mov	r8,-130768
80002e06:	70 0b       	ld.w	r11,r8[0x0]
80002e08:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002e0c:	fe f8 04 18 	ld.w	r8,pc[1048]
80002e10:	90 69       	ld.sh	r9,r8[0xc]
80002e12:	fe f8 04 22 	ld.w	r8,pc[1058]
80002e16:	90 08       	ld.sh	r8,r8[0x0]
80002e18:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
80002e1c:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002e20:	f6 0a 00 0a 	add	r10,r11,r10
80002e24:	14 3c       	cp.w	r12,r10
80002e26:	c0 44       	brge	80002e2e <udd_interrupt+0x1fe>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002e28:	10 19       	sub	r9,r8
80002e2a:	f7 d9 b0 10 	bfexts	r11,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e2e:	fe f9 03 f6 	ld.w	r9,pc[1014]
80002e32:	72 29       	ld.w	r9,r9[0x8]
	for (i = 0; i < nb_data; i++) {
80002e34:	58 0b       	cp.w	r11,0
80002e36:	e0 80 01 e2 	breq	800031fa <udd_interrupt+0x5ca>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e3a:	5c 78       	castu.h	r8
80002e3c:	10 09       	add	r9,r8
80002e3e:	fc 18 e0 00 	movh	r8,0xe000
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
80002e42:	11 3a       	ld.ub	r10,r8++
80002e44:	12 ca       	st.b	r9++,r10
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
80002e46:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002e4a:	f6 0a 19 00 	cp.h	r10,r11
80002e4e:	cf a3       	brcs	80002e42 <udd_interrupt+0x212>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80002e50:	fe f9 03 e4 	ld.w	r9,pc[996]
80002e54:	92 08       	ld.sh	r8,r9[0x0]
80002e56:	16 08       	add	r8,r11
80002e58:	5c 88       	casts.h	r8
80002e5a:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80002e5c:	34 09       	mov	r9,64
80002e5e:	f2 0b 19 00 	cp.h	r11,r9
80002e62:	c0 e1       	brne	80002e7e <udd_interrupt+0x24e>
80002e64:	fe f9 03 c0 	ld.w	r9,pc[960]
80002e68:	92 ba       	ld.uh	r10,r9[0x6]
80002e6a:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002e6e:	fe f9 03 c2 	ld.w	r9,pc[962]
80002e72:	92 89       	ld.uh	r9,r9[0x0]
80002e74:	f6 09 00 09 	add	r9,r11,r9
80002e78:	12 3a       	cp.w	r10,r9
80002e7a:	e0 89 00 1a 	brgt	80002eae <udd_interrupt+0x27e>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback 
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002e7e:	fe f9 03 a6 	ld.w	r9,pc[934]
80002e82:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002e84:	72 5c       	ld.w	r12,r9[0x14]
80002e86:	58 0c       	cp.w	r12,0
80002e88:	c0 b0       	breq	80002e9e <udd_interrupt+0x26e>
			if (!udd_g_ctrlreq.over_under_run()) {
80002e8a:	5d 1c       	icall	r12
80002e8c:	c0 91       	brne	80002e9e <udd_interrupt+0x26e>
				// Stall ZLP
				udd_ctrl_stall_data();
80002e8e:	f0 1f 00 e5 	mcall	80003220 <udd_interrupt+0x5f0>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002e92:	30 29       	mov	r9,2
80002e94:	fe 68 01 60 	mov	r8,-130720
80002e98:	91 09       	st.w	r8[0x0],r9
80002e9a:	e0 8f 01 a9 	bral	800031ec <udd_interrupt+0x5bc>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002e9e:	30 29       	mov	r9,2
80002ea0:	fe 68 01 60 	mov	r8,-130720
80002ea4:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002ea6:	f0 1f 00 e6 	mcall	8000323c <udd_interrupt+0x60c>
80002eaa:	e0 8f 01 a1 	bral	800031ec <udd_interrupt+0x5bc>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002eae:	fe f9 03 76 	ld.w	r9,pc[886]
80002eb2:	92 69       	ld.sh	r9,r9[0xc]
80002eb4:	f0 09 19 00 	cp.h	r9,r8
80002eb8:	c2 21       	brne	80002efc <udd_interrupt+0x2cc>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002eba:	fe f8 03 6a 	ld.w	r8,pc[874]
80002ebe:	70 5c       	ld.w	r12,r8[0x14]
80002ec0:	58 0c       	cp.w	r12,0
80002ec2:	c0 91       	brne	80002ed4 <udd_interrupt+0x2a4>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002ec4:	f0 1f 00 d7 	mcall	80003220 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002ec8:	30 29       	mov	r9,2
80002eca:	fe 68 01 60 	mov	r8,-130720
80002ece:	91 09       	st.w	r8[0x0],r9
80002ed0:	e0 8f 01 8e 	bral	800031ec <udd_interrupt+0x5bc>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002ed4:	5d 1c       	icall	r12
80002ed6:	c0 81       	brne	80002ee6 <udd_interrupt+0x2b6>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002ed8:	f0 1f 00 d2 	mcall	80003220 <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002edc:	30 29       	mov	r9,2
80002ede:	fe 68 01 60 	mov	r8,-130720
80002ee2:	91 09       	st.w	r8[0x0],r9
80002ee4:	c8 49       	rjmp	800031ec <udd_interrupt+0x5bc>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002ee6:	fe f9 03 4a 	ld.w	r9,pc[842]
80002eea:	fe f8 03 4a 	ld.w	r8,pc[842]
80002eee:	90 0b       	ld.sh	r11,r8[0x0]
80002ef0:	92 0a       	ld.sh	r10,r9[0x0]
80002ef2:	f6 0a 00 0a 	add	r10,r11,r10
80002ef6:	b2 0a       	st.h	r9[0x0],r10
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002ef8:	30 09       	mov	r9,0
80002efa:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002efc:	fe 69 01 60 	mov	r9,-130720
80002f00:	30 28       	mov	r8,2
80002f02:	93 08       	st.w	r9[0x0],r8
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002f04:	31 08       	mov	r8,16
80002f06:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002f08:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002f0c:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002f0e:	fe 6a 01 f0 	mov	r10,-130576
80002f12:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002f14:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002f18:	c6 a9       	rjmp	800031ec <udd_interrupt+0x5bc>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002f1a:	fe 68 01 30 	mov	r8,-130768
80002f1e:	70 08       	ld.w	r8,r8[0x0]
80002f20:	e2 18 00 08 	andl	r8,0x8,COH
80002f24:	c1 80       	breq	80002f54 <udd_interrupt+0x324>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002f26:	30 89       	mov	r9,8
80002f28:	fe 68 01 60 	mov	r8,-130720
80002f2c:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
80002f2e:	fe 68 01 30 	mov	r8,-130768
80002f32:	70 08       	ld.w	r8,r8[0x0]
80002f34:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002f38:	e0 81 01 5a 	brne	800031ec <udd_interrupt+0x5bc>
		return;	// overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002f3c:	fe f8 02 d8 	ld.w	r8,pc[728]
80002f40:	70 08       	ld.w	r8,r8[0x0]
80002f42:	58 38       	cp.w	r8,3
80002f44:	e0 81 01 54 	brne	800031ec <udd_interrupt+0x5bc>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002f48:	e8 69 00 00 	mov	r9,524288
80002f4c:	fe 68 01 f0 	mov	r8,-130576
80002f50:	91 09       	st.w	r8[0x0],r9
80002f52:	c4 d9       	rjmp	800031ec <udd_interrupt+0x5bc>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002f54:	fe 68 01 30 	mov	r8,-130768
80002f58:	70 08       	ld.w	r8,r8[0x0]
80002f5a:	e2 18 00 10 	andl	r8,0x10,COH
80002f5e:	c0 e1       	brne	80002f7a <udd_interrupt+0x34a>
80002f60:	fe f7 02 e0 	ld.w	r7,pc[736]
80002f64:	0e 9a       	mov	r10,r7
80002f66:	fe 69 01 34 	mov	r9,-130764
80002f6a:	30 0b       	mov	r11,0
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002f6c:	fe 66 00 00 	mov	r6,-131072
80002f70:	fc 14 02 00 	movh	r4,0x200
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002f74:	e0 63 10 00 	mov	r3,4096
80002f78:	c1 e8       	rjmp	80002fb4 <udd_interrupt+0x384>
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002f7a:	31 09       	mov	r9,16
80002f7c:	fe 68 01 60 	mov	r8,-130720
80002f80:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002f82:	fe 68 01 30 	mov	r8,-130768
80002f86:	70 08       	ld.w	r8,r8[0x0]
80002f88:	e2 18 00 02 	andl	r8,0x2,COH
80002f8c:	e0 81 01 30 	brne	800031ec <udd_interrupt+0x5bc>
		return;	// underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002f90:	fe f8 02 84 	ld.w	r8,pc[644]
80002f94:	70 08       	ld.w	r8,r8[0x0]
80002f96:	58 18       	cp.w	r8,1
80002f98:	c0 41       	brne	80002fa0 <udd_interrupt+0x370>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002f9a:	f0 1f 00 a9 	mcall	8000323c <udd_interrupt+0x60c>
80002f9e:	c2 79       	rjmp	800031ec <udd_interrupt+0x5bc>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002fa0:	58 48       	cp.w	r8,4
80002fa2:	e0 81 01 25 	brne	800031ec <udd_interrupt+0x5bc>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002fa6:	e8 69 00 00 	mov	r9,524288
80002faa:	fe 68 01 f0 	mov	r8,-130576
80002fae:	91 09       	st.w	r8[0x0],r9
80002fb0:	c1 e9       	rjmp	800031ec <udd_interrupt+0x5bc>
80002fb2:	10 9b       	mov	r11,r8
80002fb4:	f6 c8 ff ff 	sub	r8,r11,-1
80002fb8:	14 9c       	mov	r12,r10
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002fba:	6c 45       	ld.w	r5,r6[0x10]
80002fbc:	10 9e       	mov	lr,r8
80002fbe:	e8 0b 09 4b 	lsl	r11,r4,r11
80002fc2:	f7 e5 00 05 	and	r5,r11,r5
80002fc6:	c4 b0       	breq	8000305c <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80002fc8:	6c 15       	ld.w	r5,r6[0x4]
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002fca:	f7 e5 00 05 	and	r5,r11,r5
80002fce:	c4 70       	breq	8000305c <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			udd_disable_endpoint_dma_interrupt(ep);
80002fd0:	fe 69 00 00 	mov	r9,-131072
80002fd4:	93 5b       	st.w	r9[0x14],r11
			if (ptr_job->b_raise_dma) {
80002fd6:	74 09       	ld.w	r9,r10[0x0]
80002fd8:	e6 19 20 00 	andh	r9,0x2000,COH
80002fdc:	c0 50       	breq	80002fe6 <udd_interrupt+0x3b6>
				// In case of manual raise DMA interrupt
				// to process a ZLP packet
				udd_raise_endpoint_dma_interrupt(ep);
80002fde:	fe 69 00 00 	mov	r9,-131072
80002fe2:	93 3b       	st.w	r9[0xc],r11
80002fe4:	c0 a8       	rjmp	80002ff8 <udd_interrupt+0x3c8>
			}else{
				// Save number of data no transfered
				nb_remaining = (udd_endpoint_dma_get_status(ep) &
80002fe6:	f0 09 15 04 	lsl	r9,r8,0x4
80002fea:	e0 39 fd 00 	sub	r9,130304
80002fee:	72 39       	ld.w	r9,r9[0xc]
						AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
						>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
				// Update number of data transfered
				ptr_job->buf_size -= nb_remaining;
80002ff0:	b1 89       	lsr	r9,0x10
80002ff2:	74 2a       	ld.w	r10,r10[0x8]
80002ff4:	12 1a       	sub	r10,r9
80002ff6:	99 2a       	st.w	r12[0x8],r10
			}

			if (Is_udd_endpoint_in(ep)) {
80002ff8:	a3 68       	lsl	r8,0x2
80002ffa:	fe 6b 01 00 	mov	r11,-130816
80002ffe:	f0 0b 00 09 	add	r9,r8,r11
80003002:	72 09       	ld.w	r9,r9[0x0]
80003004:	e2 19 01 00 	andl	r9,0x100,COH
80003008:	c2 60       	breq	80003054 <udd_interrupt+0x424>
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
8000300a:	78 09       	ld.w	r9,r12[0x0]
8000300c:	e6 19 40 00 	andh	r9,0x4000,COH
80003010:	c2 20       	breq	80003054 <udd_interrupt+0x424>
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
80003012:	fe 6a 01 60 	mov	r10,-130720
80003016:	f0 0a 00 09 	add	r9,r8,r10
8000301a:	30 1a       	mov	r10,1
8000301c:	93 0a       	st.w	r9[0x0],r10
					if (Is_udd_write_enabled(ep)) {
8000301e:	fe 6b 01 30 	mov	r11,-130768
80003022:	f0 0b 00 09 	add	r9,r8,r11
80003026:	72 0a       	ld.w	r10,r9[0x0]
						udd_raise_in_send(ep);
80003028:	fe 6b 01 90 	mov	r11,-130672
8000302c:	f0 0b 00 09 	add	r9,r8,r11
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
					if (Is_udd_write_enabled(ep)) {
80003030:	e6 1a 00 01 	andh	r10,0x1,COH
						udd_raise_in_send(ep);
80003034:	f9 ba 01 01 	movne	r10,1
80003038:	f3 fa 1a 00 	st.wne	r9[0x0],r10
					}
					udd_enable_in_send_interrupt(ep);
8000303c:	e0 38 fe 10 	sub	r8,130576
80003040:	30 19       	mov	r9,1
80003042:	91 09       	st.w	r8[0x0],r9
					udd_enable_endpoint_interrupt(ep);
80003044:	e0 68 10 00 	mov	r8,4096
80003048:	f0 0e 09 4e 	lsl	lr,r8,lr
8000304c:	fe 68 00 00 	mov	r8,-131072
80003050:	91 6e       	st.w	r8[0x18],lr
80003052:	cc d8       	rjmp	800031ec <udd_interrupt+0x5bc>
					return true;
				}
			}
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
80003054:	30 0b       	mov	r11,0
80003056:	f0 1f 00 7c 	mcall	80003244 <udd_interrupt+0x614>
8000305a:	cc 98       	rjmp	800031ec <udd_interrupt+0x5bc>
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
8000305c:	6c 4b       	ld.w	r11,r6[0x10]
8000305e:	e6 0e 09 4e 	lsl	lr,r3,lr
80003062:	fd eb 00 0b 	and	r11,lr,r11
80003066:	c4 60       	breq	800030f2 <udd_interrupt+0x4c2>
80003068:	e0 7b fe d0 	mov	r11,130768
8000306c:	f2 0b 00 02 	add	r2,r9,r11
80003070:	f2 cb ff 70 	sub	r11,r9,-144
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
80003074:	76 05       	ld.w	r5,r11[0x0]
80003076:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
8000307a:	c1 50       	breq	800030a4 <udd_interrupt+0x474>
8000307c:	72 05       	ld.w	r5,r9[0x0]
8000307e:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80003082:	c1 10       	breq	800030a4 <udd_interrupt+0x474>
				udd_disable_in_send_interrupt(ep);
80003084:	fe 6a 02 20 	mov	r10,-130528
80003088:	e4 0a 00 08 	add	r8,r2,r10
8000308c:	30 19       	mov	r9,1
8000308e:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
80003090:	e0 32 fe a0 	sub	r2,130720
80003094:	85 09       	st.w	r2[0x0],r9
				udd_ack_fifocon(ep);
80003096:	e0 69 40 00 	mov	r9,16384
8000309a:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false);
8000309c:	30 0b       	mov	r11,0
8000309e:	f0 1f 00 6a 	mcall	80003244 <udd_interrupt+0x614>
800030a2:	ca 58       	rjmp	800031ec <udd_interrupt+0x5bc>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0==udd_nb_busy_bank(ep))) {
800030a4:	76 0b       	ld.w	r11,r11[0x0]
800030a6:	e2 1b 10 00 	andl	r11,0x1000,COH
800030aa:	c2 40       	breq	800030f2 <udd_interrupt+0x4c2>
800030ac:	72 0b       	ld.w	r11,r9[0x0]
800030ae:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
800030b2:	c2 01       	brne	800030f2 <udd_interrupt+0x4c2>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
800030b4:	fe 69 02 20 	mov	r9,-130528
800030b8:	e4 09 00 08 	add	r8,r2,r9
800030bc:	e0 69 10 00 	mov	r9,4096
800030c0:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
800030c2:	fe 68 00 00 	mov	r8,-131072
800030c6:	91 5e       	st.w	r8[0x14],lr

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
800030c8:	78 08       	ld.w	r8,r12[0x0]
800030ca:	30 09       	mov	r9,0
800030cc:	f1 d9 d3 81 	bfins	r8,r9,0x1c,0x1
800030d0:	99 08       	st.w	r12[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
800030d2:	fe 6b 01 00 	mov	r11,-130816
800030d6:	e4 0b 00 08 	add	r8,r2,r11
800030da:	70 09       	ld.w	r9,r8[0x0]
800030dc:	a9 d9       	cbr	r9,0x9
800030de:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
800030e0:	e0 32 fe 10 	sub	r2,130576
800030e4:	e8 68 00 00 	mov	r8,524288
800030e8:	85 08       	st.w	r2[0x0],r8
				udd_reset_data_toggle(ep);
800030ea:	e4 68 00 00 	mov	r8,262144
800030ee:	85 08       	st.w	r2[0x0],r8
800030f0:	c7 e8       	rjmp	800031ec <udd_interrupt+0x5bc>
800030f2:	2f 0a       	sub	r10,-16
800030f4:	2f c9       	sub	r9,-4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
800030f6:	58 38       	cp.w	r8,3
800030f8:	fe 91 ff 5d 	brne	80002fb2 <udd_interrupt+0x382>
800030fc:	c8 38       	rjmp	80003202 <udd_interrupt+0x5d2>
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
800030fe:	30 89       	mov	r9,8
80003100:	fe 68 00 00 	mov	r8,-131072
80003104:	91 29       	st.w	r8[0x8],r9
#if __ICCAVR32__
#if !defined(AVR32_USBB_IRQ_GROUP)
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
80003106:	ee c6 ff d0 	sub	r6,r7,-48
static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true);
8000310a:	30 15       	mov	r5,1
8000310c:	0a 9b       	mov	r11,r5
8000310e:	0e 9c       	mov	r12,r7
80003110:	f0 1f 00 4d 	mcall	80003244 <udd_interrupt+0x614>
80003114:	2f 07       	sub	r7,-16

static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
80003116:	0c 37       	cp.w	r7,r6
80003118:	cf a1       	brne	8000310c <udd_interrupt+0x4dc>
		// Abort all jobs on-going
#if (0!=USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
8000311a:	f0 1f 00 4c 	mcall	80003248 <udd_interrupt+0x618>
		// Reset endpoint control
		udd_reset_ep_ctrl();
8000311e:	f0 1f 00 4c 	mcall	8000324c <udd_interrupt+0x61c>
		// Reset endpoint control management
		udd_ctrl_init();
80003122:	f0 1f 00 3f 	mcall	8000321c <udd_interrupt+0x5ec>
		goto udd_interrupt_end;
80003126:	c6 38       	rjmp	800031ec <udd_interrupt+0x5bc>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
80003128:	fe 68 00 00 	mov	r8,-131072
8000312c:	70 48       	ld.w	r8,r8[0x10]
8000312e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003132:	c1 b0       	breq	80003168 <udd_interrupt+0x538>
80003134:	fe 68 00 00 	mov	r8,-131072
80003138:	70 18       	ld.w	r8,r8[0x4]
8000313a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000313e:	c1 50       	breq	80003168 <udd_interrupt+0x538>
		otg_unfreeze_clock();
80003140:	fe 68 00 00 	mov	r8,-131072
80003144:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003148:	af c9       	cbr	r9,0xe
8000314a:	f1 49 08 00 	st.w	r8[2048],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
8000314e:	30 19       	mov	r9,1
80003150:	91 59       	st.w	r8[0x14],r9
		udd_enable_wake_up_interrupt();
80003152:	31 09       	mov	r9,16
80003154:	91 69       	st.w	r8[0x18],r9
		otg_freeze_clock();	// Mandatory to exit of sleep mode after a wakeup event
80003156:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000315a:	af a9       	sbr	r9,0xe
8000315c:	f1 49 08 00 	st.w	r8[2048],r9
		udd_sleep_mode(false);	// Enter in SUSPEND mode
80003160:	30 0c       	mov	r12,0
80003162:	f0 1f 00 3c 	mcall	80003250 <udd_interrupt+0x620>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
80003166:	c4 38       	rjmp	800031ec <udd_interrupt+0x5bc>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80003168:	fe 68 00 00 	mov	r8,-131072
8000316c:	70 48       	ld.w	r8,r8[0x10]
8000316e:	e2 18 00 10 	andl	r8,0x10,COH
80003172:	c2 10       	breq	800031b4 <udd_interrupt+0x584>
80003174:	fe 68 00 00 	mov	r8,-131072
80003178:	70 18       	ld.w	r8,r8[0x4]
8000317a:	e2 18 00 10 	andl	r8,0x10,COH
8000317e:	c1 b0       	breq	800031b4 <udd_interrupt+0x584>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
80003180:	fe 68 00 00 	mov	r8,-131072
80003184:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003188:	af c9       	cbr	r9,0xe
8000318a:	f1 49 08 00 	st.w	r8[2048],r9
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
8000318e:	c0 58       	rjmp	80003198 <udd_interrupt+0x568>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
80003190:	70 19       	ld.w	r9,r8[0x4]
80003192:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80003196:	c0 61       	brne	800031a2 <udd_interrupt+0x572>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
80003198:	f0 f9 08 04 	ld.w	r9,r8[2052]
8000319c:	e2 19 40 00 	andl	r9,0x4000,COH
800031a0:	cf 80       	breq	80003190 <udd_interrupt+0x560>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
800031a2:	fe 68 00 00 	mov	r8,-131072
800031a6:	31 09       	mov	r9,16
800031a8:	91 59       	st.w	r8[0x14],r9
		udd_enable_suspend_interrupt();
800031aa:	30 1c       	mov	r12,1
800031ac:	91 6c       	st.w	r8[0x18],r12
		udd_sleep_mode(true);	// Enter in IDLE mode
800031ae:	f0 1f 00 29 	mcall	80003250 <udd_interrupt+0x620>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
800031b2:	c1 d8       	rjmp	800031ec <udd_interrupt+0x5bc>
	}

	if (Is_udd_vbus_transition()) {
800031b4:	fe 68 00 00 	mov	r8,-131072
800031b8:	f0 f8 08 04 	ld.w	r8,r8[2052]
800031bc:	e2 18 00 02 	andl	r8,0x2,COH
800031c0:	c1 60       	breq	800031ec <udd_interrupt+0x5bc>
		// Ack VBus transition and send status to high level
		otg_unfreeze_clock();
800031c2:	fe 68 00 00 	mov	r8,-131072
800031c6:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031ca:	af c9       	cbr	r9,0xe
800031cc:	f1 49 08 00 	st.w	r8[2048],r9
		udd_ack_vbus_transition();
800031d0:	30 29       	mov	r9,2
800031d2:	f1 49 08 08 	st.w	r8[2056],r9
		otg_freeze_clock();
800031d6:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031da:	af a9       	sbr	r9,0xe
800031dc:	f1 49 08 00 	st.w	r8[2048],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_udd_vbus_high());
800031e0:	f0 fc 08 04 	ld.w	r12,r8[2052]
800031e4:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
800031e8:	f0 1f 00 1b 	mcall	80003254 <udd_interrupt+0x624>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
800031ec:	fe 68 00 00 	mov	r8,-131072
800031f0:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
800031f4:	e3 cd 40 fc 	ldm	sp++,r2-r7,lr
800031f8:	d6 03       	rete
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
800031fa:	48 f9       	lddpc	r9,80003234 <udd_interrupt+0x604>
800031fc:	b2 08       	st.h	r9[0x0],r8
800031fe:	fe 9f fe 40 	bral	80002e7e <udd_interrupt+0x24e>
	if (udd_ep_interrupt())
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
80003202:	fe 68 00 00 	mov	r8,-131072
80003206:	70 18       	ld.w	r8,r8[0x4]
80003208:	e2 18 00 08 	andl	r8,0x8,COH
8000320c:	c8 e0       	breq	80003128 <udd_interrupt+0x4f8>
8000320e:	c7 8b       	rjmp	800030fe <udd_interrupt+0x4ce>
80003210:	80 00       	ld.sh	r0,r0[0x0]
80003212:	37 d4       	mov	r4,125
80003214:	00 00       	add	r0,r0
80003216:	07 4c       	ld.w	r12,--r3
80003218:	80 00       	ld.sh	r0,r0[0x0]
8000321a:	25 54       	sub	r4,85
8000321c:	80 00       	ld.sh	r0,r0[0x0]
8000321e:	27 94       	sub	r4,121
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	25 3c       	sub	r12,83
80003224:	00 00       	add	r0,r0
80003226:	0a 00       	add	r0,r5
80003228:	80 00       	ld.sh	r0,r0[0x0]
8000322a:	3a 54       	mov	r4,-91
8000322c:	00 00       	add	r0,r0
8000322e:	07 50       	ld.sh	r0,--r3
80003230:	00 00       	add	r0,r0
80003232:	07 14       	ld.sh	r4,r3++
80003234:	00 00       	add	r0,r0
80003236:	07 4a       	ld.w	r10,--r3
80003238:	80 00       	ld.sh	r0,r0[0x0]
8000323a:	27 f4       	sub	r4,127
8000323c:	80 00       	ld.sh	r0,r0[0x0]
8000323e:	27 c8       	sub	r8,124
80003240:	00 00       	add	r0,r0
80003242:	07 18       	ld.sh	r8,r3++
80003244:	80 00       	ld.sh	r0,r0[0x0]
80003246:	25 68       	sub	r8,86
80003248:	80 00       	ld.sh	r0,r0[0x0]
8000324a:	39 f4       	mov	r4,-97
8000324c:	80 00       	ld.sh	r0,r0[0x0]
8000324e:	2a 52       	sub	r2,-91
80003250:	80 00       	ld.sh	r0,r0[0x0]
80003252:	27 20       	sub	r0,114
80003254:	80 00       	ld.sh	r0,r0[0x0]
80003256:	3f 54       	mov	r4,-11

80003258 <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003258:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
8000325c:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000325e:	fe 78 0c 00 	mov	r8,-62464
80003262:	71 59       	ld.w	r9,r8[0x54]
80003264:	e2 19 00 40 	andl	r9,0x40,COH
80003268:	cf d0       	breq	80003262 <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
8000326a:	a3 6c       	lsl	r12,0x2
8000326c:	e0 2c f3 f8 	sub	r12,62456
80003270:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
80003272:	30 19       	mov	r9,1
80003274:	f2 0b 09 4b 	lsl	r11,r9,r11
80003278:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
8000327a:	99 0b       	st.w	r12[0x0],r11
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000327c:	e3 ba 00 00 	mtsr	0x0,r10

	cpu_irq_restore(flags);
}
80003280:	5e fc       	retal	r12
80003282:	d7 03       	nop

80003284 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
80003284:	eb cd 40 e0 	pushm	r5-r7,lr
80003288:	18 96       	mov	r6,r12
8000328a:	58 9c       	cp.w	r12,9
8000328c:	5f 07       	sreq	r7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000328e:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
80003292:	d3 03       	ssrf	0x10
		pbus_id = 1;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_bus_refcount[pbus_id])
80003294:	48 f8       	lddpc	r8,800032d0 <sysclk_enable_pbb_module+0x4c>
80003296:	f0 07 07 09 	ld.ub	r9,r8[r7]
8000329a:	30 08       	mov	r8,0
8000329c:	f0 09 18 00 	cp.b	r9,r8
800032a0:	c0 a1       	brne	800032b4 <sysclk_enable_pbb_module+0x30>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
800032a2:	ee 0b 15 01 	lsl	r11,r7,0x1
800032a6:	f9 bb 01 06 	movne	r11,6
800032aa:	f9 bb 00 02 	moveq	r11,2
800032ae:	30 1c       	mov	r12,1
800032b0:	f0 1f 00 09 	mcall	800032d4 <sysclk_enable_pbb_module+0x50>
		sysclk_enable_hsb_module(2 + (4 * pbus_id));
	sysclk_bus_refcount[pbus_id]++;
800032b4:	48 78       	lddpc	r8,800032d0 <sysclk_enable_pbb_module+0x4c>
800032b6:	f0 07 07 09 	ld.ub	r9,r8[r7]
800032ba:	2f f9       	sub	r9,-1
800032bc:	f0 07 0b 09 	st.b	r8[r7],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032c0:	e3 b5 00 00 	mtsr	0x0,r5

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
800032c4:	0c 9b       	mov	r11,r6
800032c6:	30 3c       	mov	r12,3
800032c8:	f0 1f 00 03 	mcall	800032d4 <sysclk_enable_pbb_module+0x50>
}
800032cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032d0:	00 00       	add	r0,r0
800032d2:	07 54       	ld.sh	r4,--r3
800032d4:	80 00       	ld.sh	r0,r0[0x0]
800032d6:	32 58       	mov	r8,37

800032d8 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 12MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
800032d8:	d4 01       	pushm	lr
	struct genclk_config gcfg;

	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
800032da:	30 1c       	mov	r12,1
800032dc:	f0 1f 00 0f 	mcall	80003318 <sysclk_enable_usb+0x40>
800032e0:	30 3b       	mov	r11,3
800032e2:	30 1c       	mov	r12,1
800032e4:	f0 1f 00 0e 	mcall	8000331c <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800032e8:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800032ec:	d3 03       	ssrf	0x10
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
800032ee:	fe 78 0c 00 	mov	r8,-62464
800032f2:	e0 6a 03 07 	mov	r10,775
800032f6:	91 aa       	st.w	r8[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
800032f8:	70 0a       	ld.w	r10,r8[0x0]
800032fa:	a3 aa       	sbr	r10,0x2
800032fc:	91 0a       	st.w	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032fe:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_OSC0RDY + id)));
80003302:	71 59       	ld.w	r9,r8[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80003304:	e2 19 00 80 	andl	r9,0x80,COH
80003308:	cf d0       	breq	80003302 <sysclk_enable_usb+0x2a>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
8000330a:	30 49       	mov	r9,4
8000330c:	fe 78 0c 00 	mov	r8,-62464
80003310:	f1 49 00 70 	st.w	r8[112],r9
		break;
	}

	genclk_config_set_divider(&gcfg, CONFIG_USBCLK_DIV);
	genclk_enable(&gcfg, AVR32_PM_GCLK_USBB);
}
80003314:	d8 02       	popm	pc
80003316:	00 00       	add	r0,r0
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	32 84       	mov	r4,40
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	32 58       	mov	r8,37

80003320 <udi_cdc_data_disable>:
	UDI_CDC_DISABLE_EXT();
}

void udi_cdc_data_disable(void)
{
}
80003320:	5e fc       	retal	r12
80003322:	d7 03       	nop

80003324 <udi_cdc_comm_setup>:


bool udi_cdc_comm_setup(void)
{
	if (Udd_setup_is_in()) {
80003324:	49 e8       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
80003326:	11 88       	ld.ub	r8,r8[0x0]
80003328:	30 09       	mov	r9,0
8000332a:	f2 08 18 00 	cp.b	r8,r9
8000332e:	c1 84       	brge	8000335e <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests 
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80003330:	e2 18 00 60 	andl	r8,0x60,COH
80003334:	e0 48 00 20 	cp.w	r8,32
80003338:	c3 11       	brne	8000339a <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
8000333a:	49 98       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
8000333c:	11 99       	ld.ub	r9,r8[0x1]
8000333e:	32 18       	mov	r8,33
80003340:	f0 09 18 00 	cp.b	r9,r8
80003344:	c2 b1       	brne	8000339a <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80003346:	49 68       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
80003348:	90 39       	ld.sh	r9,r8[0x6]
8000334a:	30 78       	mov	r8,7
8000334c:	f0 09 19 00 	cp.h	r9,r8
80003350:	c2 51       	brne	8000339a <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.payload =
80003352:	49 38       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
80003354:	49 39       	lddpc	r9,800033a0 <udi_cdc_comm_setup+0x7c>
80003356:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003358:	30 79       	mov	r9,7
8000335a:	b0 69       	st.h	r8[0xc],r9
8000335c:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests  
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000335e:	e2 18 00 60 	andl	r8,0x60,COH
80003362:	e0 48 00 20 	cp.w	r8,32
80003366:	c1 a1       	brne	8000339a <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
80003368:	48 d8       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
8000336a:	11 98       	ld.ub	r8,r8[0x1]
8000336c:	32 09       	mov	r9,32
8000336e:	f2 08 18 00 	cp.b	r8,r9
80003372:	c0 60       	breq	8000337e <udi_cdc_comm_setup+0x5a>
80003374:	32 29       	mov	r9,34
80003376:	f2 08 18 00 	cp.b	r8,r9
8000337a:	c1 01       	brne	8000339a <udi_cdc_comm_setup+0x76>
8000337c:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
8000337e:	48 88       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
80003380:	90 39       	ld.sh	r9,r8[0x6]
80003382:	30 78       	mov	r8,7
80003384:	f0 09 19 00 	cp.h	r9,r8
80003388:	c0 91       	brne	8000339a <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.callback =
8000338a:	48 58       	lddpc	r8,8000339c <udi_cdc_comm_setup+0x78>
8000338c:	48 69       	lddpc	r9,800033a4 <udi_cdc_comm_setup+0x80>
8000338e:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
80003390:	48 49       	lddpc	r9,800033a0 <udi_cdc_comm_setup+0x7c>
80003392:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003394:	30 79       	mov	r9,7
80003396:	b0 69       	st.h	r8[0xc],r9
80003398:	5e ff       	retal	1
						sizeof(udi_cdc_line_coding);
				return true;
8000339a:	5e fd       	retal	0
8000339c:	00 00       	add	r0,r0
8000339e:	0a 00       	add	r0,r5
800033a0:	00 00       	add	r0,r0
800033a2:	07 58       	ld.sh	r8,--r3
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	33 ac       	mov	r12,58

800033a8 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
800033a8:	5e fd       	retal	0

800033aa <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
800033aa:	5e fd       	retal	0

800033ac <udi_cdc_line_coding_received>:

void udi_cdc_line_coding_received(void)
{
	// Send line coding to component associated to CDC
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));
}
800033ac:	5e fc       	retal	r12
800033ae:	d7 03       	nop

800033b0 <udi_cdc_is_rx_ready>:
}


bool udi_cdc_is_rx_ready(void)
{
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
800033b0:	48 68       	lddpc	r8,800033c8 <udi_cdc_is_rx_ready+0x18>
800033b2:	11 8a       	ld.ub	r10,r8[0x0]
800033b4:	48 68       	lddpc	r8,800033cc <udi_cdc_is_rx_ready+0x1c>
800033b6:	90 08       	ld.sh	r8,r8[0x0]
800033b8:	48 69       	lddpc	r9,800033d0 <udi_cdc_is_rx_ready+0x20>
800033ba:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033be:	f0 09 19 00 	cp.h	r9,r8
}
800033c2:	5f bc       	srhi	r12
800033c4:	5e fc       	retal	r12
800033c6:	00 00       	add	r0,r0
800033c8:	00 00       	add	r0,r0
800033ca:	07 ec       	ld.ub	r12,r3[0x6]
800033cc:	00 00       	add	r0,r0
800033ce:	07 e8       	ld.ub	r8,r3[0x6]
800033d0:	00 00       	add	r0,r0
800033d2:	07 e4       	ld.ub	r4,r3[0x6]

800033d4 <udi_cdc_is_tx_ready>:


bool udi_cdc_is_tx_ready(void)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS) {
800033d4:	49 58       	lddpc	r8,80003428 <udi_cdc_is_tx_ready+0x54>
800033d6:	11 89       	ld.ub	r9,r8[0x0]
800033d8:	49 58       	lddpc	r8,8000342c <udi_cdc_is_tx_ready+0x58>
800033da:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800033de:	34 08       	mov	r8,64
800033e0:	f0 09 19 00 	cp.h	r9,r8
800033e4:	c0 20       	breq	800033e8 <udi_cdc_is_tx_ready+0x14>
800033e6:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send) {
800033e8:	49 28       	lddpc	r8,80003430 <udi_cdc_is_tx_ready+0x5c>
800033ea:	11 88       	ld.ub	r8,r8[0x0]
800033ec:	58 08       	cp.w	r8,0
800033ee:	c1 21       	brne	80003412 <udi_cdc_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800033f0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800033f4:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing) {
800033f6:	49 09       	lddpc	r9,80003434 <udi_cdc_is_tx_ready+0x60>
800033f8:	13 89       	ld.ub	r9,r9[0x0]
800033fa:	58 09       	cp.w	r9,0
800033fc:	c0 91       	brne	8000340e <udi_cdc_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send = true;
800033fe:	30 1a       	mov	r10,1
80003400:	48 c9       	lddpc	r9,80003430 <udi_cdc_is_tx_ready+0x5c>
80003402:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel = (udi_cdc_tx_buf_sel==0)?1:0;
80003404:	48 99       	lddpc	r9,80003428 <udi_cdc_is_tx_ready+0x54>
80003406:	13 8a       	ld.ub	r10,r9[0x0]
80003408:	58 0a       	cp.w	r10,0
8000340a:	5f 0a       	sreq	r10
8000340c:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000340e:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS);
80003412:	48 68       	lddpc	r8,80003428 <udi_cdc_is_tx_ready+0x54>
80003414:	11 89       	ld.ub	r9,r8[0x0]
80003416:	48 68       	lddpc	r8,8000342c <udi_cdc_is_tx_ready+0x58>
80003418:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000341c:	34 08       	mov	r8,64
8000341e:	f0 09 19 00 	cp.h	r9,r8
80003422:	5f 1c       	srne	r12
}
80003424:	5e fc       	retal	r12
80003426:	00 00       	add	r0,r0
80003428:	00 00       	add	r0,r0
8000342a:	07 5f       	ld.sh	pc,--r3
8000342c:	00 00       	add	r0,r0
8000342e:	07 60       	ld.uh	r0,--r3
80003430:	00 00       	add	r0,r0
80003432:	08 71       	tst	r1,r4
80003434:	00 00       	add	r0,r0
80003436:	07 ee       	ld.ub	lr,r3[0x6]

80003438 <udi_cdc_putc>:


int udi_cdc_putc(int value)
{
80003438:	eb cd 40 fe 	pushm	r1-r7,lr
8000343c:	18 97       	mov	r7,r12
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
8000343e:	49 88       	lddpc	r8,8000349c <udi_cdc_putc+0x64>
80003440:	11 e9       	ld.ub	r9,r8[0x6]
80003442:	30 98       	mov	r8,9
80003444:	f0 09 18 00 	cp.b	r9,r8
80003448:	5f 04       	sreq	r4

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
		if (!udi_cdc_running) {
8000344a:	49 66       	lddpc	r6,800034a0 <udi_cdc_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
8000344c:	49 63       	lddpc	r3,800034a4 <udi_cdc_putc+0x6c>
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
8000344e:	49 75       	lddpc	r5,800034a8 <udi_cdc_putc+0x70>
80003450:	49 72       	lddpc	r2,800034ac <udi_cdc_putc+0x74>
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
80003452:	30 01       	mov	r1,0

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
80003454:	f0 1f 00 17 	mcall	800034b0 <udi_cdc_putc+0x78>
80003458:	c0 51       	brne	80003462 <udi_cdc_putc+0x2a>
		if (!udi_cdc_running) {
8000345a:	0d 88       	ld.ub	r8,r6[0x0]
8000345c:	58 08       	cp.w	r8,0
8000345e:	cf b1       	brne	80003454 <udi_cdc_putc+0x1c>
80003460:	c1 b8       	rjmp	80003496 <udi_cdc_putc+0x5e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003462:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003466:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003468:	07 88       	ld.ub	r8,r3[0x0]
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
8000346a:	ea 08 04 19 	ld.sh	r9,r5[r8<<0x1]
8000346e:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
80003472:	f0 0c 15 06 	lsl	r12,r8,0x6
80003476:	f8 0b 00 0b 	add	r11,r12,r11
8000347a:	e4 0b 0b 07 	st.b	r2[r11],r7
8000347e:	2f f9       	sub	r9,-1
80003480:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003484:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
80003488:	58 04       	cp.w	r4,0
8000348a:	c0 31       	brne	80003490 <udi_cdc_putc+0x58>
8000348c:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
80003490:	a9 47       	asr	r7,0x8
80003492:	02 94       	mov	r4,r1
80003494:	ce 0b       	rjmp	80003454 <udi_cdc_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
80003496:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000349a:	00 00       	add	r0,r0
8000349c:	00 00       	add	r0,r0
8000349e:	07 58       	ld.sh	r8,--r3
800034a0:	00 00       	add	r0,r0
800034a2:	07 ed       	ld.ub	sp,r3[0x6]
800034a4:	00 00       	add	r0,r0
800034a6:	07 5f       	ld.sh	pc,--r3
800034a8:	00 00       	add	r0,r0
800034aa:	07 60       	ld.uh	r0,--r3
800034ac:	00 00       	add	r0,r0
800034ae:	07 64       	ld.uh	r4,--r3
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	33 d4       	mov	r4,61

800034b4 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(void)
{
800034b4:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800034b8:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800034bc:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel;
800034be:	49 78       	lddpc	r8,80003518 <udi_cdc_rx_start+0x64>
800034c0:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing ||
800034c2:	49 78       	lddpc	r8,8000351c <udi_cdc_rx_start+0x68>
800034c4:	11 88       	ld.ub	r8,r8[0x0]
800034c6:	58 08       	cp.w	r8,0
800034c8:	c0 a1       	brne	800034dc <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos < udi_cdc_rx_buf_nb[buf_sel_trans])) {
800034ca:	49 68       	lddpc	r8,80003520 <udi_cdc_rx_start+0x6c>
800034cc:	90 08       	ld.sh	r8,r8[0x0]
800034ce:	49 6a       	lddpc	r10,80003524 <udi_cdc_rx_start+0x70>
800034d0:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
800034d4:	f0 0a 19 00 	cp.h	r10,r8
800034d8:	e0 88 00 06 	brls	800034e4 <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034dc:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
800034e0:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos = 0;
800034e4:	30 0a       	mov	r10,0
800034e6:	48 f8       	lddpc	r8,80003520 <udi_cdc_rx_start+0x6c>
800034e8:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel = (buf_sel_trans==0)?1:0;
800034ea:	58 07       	cp.w	r7,0
800034ec:	5f 0a       	sreq	r10
800034ee:	48 b8       	lddpc	r8,80003518 <udi_cdc_rx_start+0x64>
800034f0:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing = true;
800034f2:	30 1a       	mov	r10,1
800034f4:	48 a8       	lddpc	r8,8000351c <udi_cdc_rx_start+0x68>
800034f6:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034f8:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
	
	if (udi_cdc_is_rx_ready()) {
800034fc:	f0 1f 00 0b 	mcall	80003528 <udi_cdc_rx_start+0x74>
		UDI_CDC_RX_NOTIFY();
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUT,
80003500:	a7 67       	lsl	r7,0x6
80003502:	48 b8       	lddpc	r8,8000352c <udi_cdc_rx_start+0x78>
80003504:	34 09       	mov	r9,64
80003506:	48 ba       	lddpc	r10,80003530 <udi_cdc_rx_start+0x7c>
80003508:	0e 0a       	add	r10,r7
8000350a:	30 1b       	mov	r11,1
8000350c:	30 2c       	mov	r12,2
8000350e:	f0 1f 00 0a 	mcall	80003534 <udi_cdc_rx_start+0x80>
					true,
					udi_cdc_rx_buf[buf_sel_trans],
					UDI_CDC_RX_BUFFERS,
					udi_cdc_data_recevied);
}
80003512:	e3 cd 80 80 	ldm	sp++,r7,pc
80003516:	00 00       	add	r0,r0
80003518:	00 00       	add	r0,r0
8000351a:	07 ec       	ld.ub	r12,r3[0x6]
8000351c:	00 00       	add	r0,r0
8000351e:	08 70       	tst	r0,r4
80003520:	00 00       	add	r0,r0
80003522:	07 e8       	ld.ub	r8,r3[0x6]
80003524:	00 00       	add	r0,r0
80003526:	07 e4       	ld.ub	r4,r3[0x6]
80003528:	80 00       	ld.sh	r0,r0[0x0]
8000352a:	33 b0       	mov	r0,59
8000352c:	80 00       	ld.sh	r0,r0[0x0]
8000352e:	35 b4       	mov	r4,91
80003530:	00 00       	add	r0,r0
80003532:	07 f0       	ld.ub	r0,r3[0x7]
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	25 d8       	sub	r8,93

80003538 <udi_cdc_getc>:
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
}


int udi_cdc_getc(void)
{
80003538:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
8000353a:	49 88       	lddpc	r8,80003598 <udi_cdc_getc+0x60>
8000353c:	11 e9       	ld.ub	r9,r8[0x6]
8000353e:	30 98       	mov	r8,9
80003540:	f0 09 18 00 	cp.b	r9,r8
80003544:	5f 02       	sreq	r2
80003546:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003548:	49 56       	lddpc	r6,8000359c <udi_cdc_getc+0x64>
8000354a:	49 67       	lddpc	r7,800035a0 <udi_cdc_getc+0x68>
8000354c:	49 65       	lddpc	r5,800035a4 <udi_cdc_getc+0x6c>
		if (!udi_cdc_running) {
8000354e:	49 74       	lddpc	r4,800035a8 <udi_cdc_getc+0x70>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
80003550:	49 71       	lddpc	r1,800035ac <udi_cdc_getc+0x74>
	udi_cdc_rx_start();

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
80003552:	06 90       	mov	r0,r3
80003554:	c0 48       	rjmp	8000355c <udi_cdc_getc+0x24>
	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
		if (!udi_cdc_running) {
80003556:	09 88       	ld.ub	r8,r4[0x0]
80003558:	58 08       	cp.w	r8,0
8000355a:	c1 b0       	breq	80003590 <udi_cdc_getc+0x58>

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
8000355c:	0d 89       	ld.ub	r9,r6[0x0]
8000355e:	8e 08       	ld.sh	r8,r7[0x0]
80003560:	ea 09 04 19 	ld.sh	r9,r5[r9<<0x1]
80003564:	f0 09 19 00 	cp.h	r9,r8
80003568:	fe 98 ff f7 	brls	80003556 <udi_cdc_getc+0x1e>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
8000356c:	0d 88       	ld.ub	r8,r6[0x0]
8000356e:	8e 09       	ld.sh	r9,r7[0x0]
80003570:	5c 79       	castu.h	r9
80003572:	a7 68       	lsl	r8,0x6
80003574:	12 08       	add	r8,r9
80003576:	e2 08 07 08 	ld.ub	r8,r1[r8]
8000357a:	10 43       	or	r3,r8
	udi_cdc_rx_pos++;
8000357c:	8e 08       	ld.sh	r8,r7[0x0]
8000357e:	2f f8       	sub	r8,-1
80003580:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start();
80003582:	f0 1f 00 0c 	mcall	800035b0 <udi_cdc_getc+0x78>

	if (b_databit_9) {
80003586:	58 02       	cp.w	r2,0
80003588:	c0 50       	breq	80003592 <udi_cdc_getc+0x5a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
8000358a:	a9 63       	lsl	r3,0x8
8000358c:	00 92       	mov	r2,r0
8000358e:	ce 7b       	rjmp	8000355c <udi_cdc_getc+0x24>
		goto udi_cdc_getc_process_one_byte;
80003590:	30 03       	mov	r3,0
	}
	return rx_data;
}
80003592:	06 9c       	mov	r12,r3
80003594:	d8 32       	popm	r0-r7,pc
80003596:	00 00       	add	r0,r0
80003598:	00 00       	add	r0,r0
8000359a:	07 58       	ld.sh	r8,--r3
8000359c:	00 00       	add	r0,r0
8000359e:	07 ec       	ld.ub	r12,r3[0x6]
800035a0:	00 00       	add	r0,r0
800035a2:	07 e8       	ld.ub	r8,r3[0x6]
800035a4:	00 00       	add	r0,r0
800035a6:	07 e4       	ld.ub	r4,r3[0x6]
800035a8:	00 00       	add	r0,r0
800035aa:	07 ed       	ld.ub	sp,r3[0x6]
800035ac:	00 00       	add	r0,r0
800035ae:	07 f0       	ld.ub	r0,r3[0x7]
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	34 b4       	mov	r4,75

800035b4 <udi_cdc_data_recevied>:
					udi_cdc_data_recevied);
}


void udi_cdc_data_recevied(udd_ep_status_t status, iram_size_t n)
{
800035b4:	d4 01       	pushm	lr
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
800035b6:	58 0c       	cp.w	r12,0
800035b8:	c1 01       	brne	800035d8 <udi_cdc_data_recevied+0x24>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel==0)?1:0;
800035ba:	48 98       	lddpc	r8,800035dc <udi_cdc_data_recevied+0x28>
800035bc:	11 88       	ld.ub	r8,r8[0x0]
	udi_cdc_rx_buf_nb[buf_sel_trans] = n;
800035be:	58 08       	cp.w	r8,0
800035c0:	f9 b8 01 00 	movne	r8,0
800035c4:	f9 b8 00 02 	moveq	r8,2
800035c8:	48 69       	lddpc	r9,800035e0 <udi_cdc_data_recevied+0x2c>
800035ca:	f2 08 0a 0b 	st.h	r9[r8],r11
	udi_cdc_rx_trans_ongoing = false;
800035ce:	30 09       	mov	r9,0
800035d0:	48 58       	lddpc	r8,800035e4 <udi_cdc_data_recevied+0x30>
800035d2:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start();
800035d4:	f0 1f 00 05 	mcall	800035e8 <udi_cdc_data_recevied+0x34>
800035d8:	d8 02       	popm	pc
800035da:	00 00       	add	r0,r0
800035dc:	00 00       	add	r0,r0
800035de:	07 ec       	ld.ub	r12,r3[0x6]
800035e0:	00 00       	add	r0,r0
800035e2:	07 e4       	ld.ub	r4,r3[0x6]
800035e4:	00 00       	add	r0,r0
800035e6:	08 70       	tst	r0,r4
800035e8:	80 00       	ld.sh	r0,r0[0x0]
800035ea:	34 b4       	mov	r4,75

800035ec <udi_cdc_tx_send>:
	udi_cdc_tx_send();
}


static void udi_cdc_tx_send(void)
{
800035ec:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing) {
800035f0:	4a a8       	lddpc	r8,80003698 <udi_cdc_tx_send+0xac>
800035f2:	11 88       	ld.ub	r8,r8[0x0]
800035f4:	58 08       	cp.w	r8,0
800035f6:	c4 f1       	brne	80003694 <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
800035f8:	f0 1f 00 29 	mcall	8000369c <udi_cdc_tx_send+0xb0>
800035fc:	c0 a0       	breq	80003610 <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num == udd_get_micro_frame_number()) {
800035fe:	f0 1f 00 29 	mcall	800036a0 <udi_cdc_tx_send+0xb4>
80003602:	4a 98       	lddpc	r8,800036a4 <udi_cdc_tx_send+0xb8>
80003604:	90 08       	ld.sh	r8,r8[0x0]
80003606:	f8 08 19 00 	cp.h	r8,r12
8000360a:	c0 a1       	brne	8000361e <udi_cdc_tx_send+0x32>
8000360c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num == udd_get_frame_number()) {
80003610:	f0 1f 00 26 	mcall	800036a8 <udi_cdc_tx_send+0xbc>
80003614:	4a 48       	lddpc	r8,800036a4 <udi_cdc_tx_send+0xb8>
80003616:	90 08       	ld.sh	r8,r8[0x0]
80003618:	f8 08 19 00 	cp.h	r8,r12
8000361c:	c3 c0       	breq	80003694 <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000361e:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80003622:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel;
80003624:	4a 29       	lddpc	r9,800036ac <udi_cdc_tx_send+0xc0>
80003626:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send) {
80003628:	4a 29       	lddpc	r9,800036b0 <udi_cdc_tx_send+0xc4>
8000362a:	13 89       	ld.ub	r9,r9[0x0]
8000362c:	58 09       	cp.w	r9,0
8000362e:	c0 61       	brne	8000363a <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel = (buf_sel_trans==0)?1:0;
80003630:	58 07       	cp.w	r7,0
80003632:	5f 0a       	sreq	r10
80003634:	49 e9       	lddpc	r9,800036ac <udi_cdc_tx_send+0xc0>
80003636:	b2 8a       	st.b	r9[0x0],r10
80003638:	c0 38       	rjmp	8000363e <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
8000363a:	58 07       	cp.w	r7,0
8000363c:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing = true;
8000363e:	30 1a       	mov	r10,1
80003640:	49 69       	lddpc	r9,80003698 <udi_cdc_tx_send+0xac>
80003642:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003644:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80003648:	0e 95       	mov	r5,r7
8000364a:	49 b8       	lddpc	r8,800036b4 <udi_cdc_tx_send+0xc8>
8000364c:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
80003650:	34 08       	mov	r8,64
80003652:	f0 09 19 00 	cp.h	r9,r8
80003656:	5f 16       	srne	r6
	if (b_short_packet) {
80003658:	58 06       	cp.w	r6,0
8000365a:	c0 e0       	breq	80003676 <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
8000365c:	f0 1f 00 10 	mcall	8000369c <udi_cdc_tx_send+0xb0>
80003660:	c0 60       	breq	8000366c <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num = udd_get_micro_frame_number();
80003662:	f0 1f 00 10 	mcall	800036a0 <udi_cdc_tx_send+0xb4>
80003666:	49 08       	lddpc	r8,800036a4 <udi_cdc_tx_send+0xb8>
80003668:	b0 0c       	st.h	r8[0x0],r12
8000366a:	c0 98       	rjmp	8000367c <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num = udd_get_frame_number();
8000366c:	f0 1f 00 0f 	mcall	800036a8 <udi_cdc_tx_send+0xbc>
80003670:	48 d8       	lddpc	r8,800036a4 <udi_cdc_tx_send+0xb8>
80003672:	b0 0c       	st.h	r8[0x0],r12
80003674:	c0 48       	rjmp	8000367c <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num = 0; // Force next transfer without wait SOF
80003676:	30 09       	mov	r9,0
80003678:	48 b8       	lddpc	r8,800036a4 <udi_cdc_tx_send+0xb8>
8000367a:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_IN,
8000367c:	a7 67       	lsl	r7,0x6
8000367e:	48 f8       	lddpc	r8,800036b8 <udi_cdc_tx_send+0xcc>
80003680:	48 d9       	lddpc	r9,800036b4 <udi_cdc_tx_send+0xc8>
80003682:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
80003686:	48 ea       	lddpc	r10,800036bc <udi_cdc_tx_send+0xd0>
80003688:	0e 0a       	add	r10,r7
8000368a:	0c 9b       	mov	r11,r6
8000368c:	e0 6c 00 81 	mov	r12,129
80003690:	f0 1f 00 0c 	mcall	800036c0 <udi_cdc_tx_send+0xd4>
80003694:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003698:	00 00       	add	r0,r0
8000369a:	07 ee       	ld.ub	lr,r3[0x6]
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	23 e2       	sub	r2,62
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	24 1e       	sub	lr,65
800036a4:	00 00       	add	r0,r0
800036a6:	07 ea       	ld.ub	r10,r3[0x6]
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	24 12       	sub	r2,65
800036ac:	00 00       	add	r0,r0
800036ae:	07 5f       	ld.sh	pc,--r3
800036b0:	00 00       	add	r0,r0
800036b2:	08 71       	tst	r1,r4
800036b4:	00 00       	add	r0,r0
800036b6:	07 60       	ld.uh	r0,--r3
800036b8:	80 00       	ld.sh	r0,r0[0x0]
800036ba:	36 c4       	mov	r4,108
800036bc:	00 00       	add	r0,r0
800036be:	07 64       	ld.uh	r4,--r3
800036c0:	80 00       	ld.sh	r0,r0[0x0]
800036c2:	25 d8       	sub	r8,93

800036c4 <udi_cdc_data_sent>:
	udi_cdc_rx_start();
}


void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
800036c4:	d4 01       	pushm	lr
	if (UDD_EP_TRANSFER_OK != status) {
800036c6:	58 0c       	cp.w	r12,0
800036c8:	c1 21       	brne	800036ec <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[(udi_cdc_tx_buf_sel==0)?1:0] = 0;
800036ca:	48 a8       	lddpc	r8,800036f0 <udi_cdc_data_sent+0x2c>
800036cc:	11 88       	ld.ub	r8,r8[0x0]
800036ce:	58 08       	cp.w	r8,0
800036d0:	f9 b9 01 00 	movne	r9,0
800036d4:	f9 b9 00 02 	moveq	r9,2
800036d8:	30 08       	mov	r8,0
800036da:	48 7a       	lddpc	r10,800036f4 <udi_cdc_data_sent+0x30>
800036dc:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send = false;
800036e0:	48 69       	lddpc	r9,800036f8 <udi_cdc_data_sent+0x34>
800036e2:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing = false;
800036e4:	48 69       	lddpc	r9,800036fc <udi_cdc_data_sent+0x38>
800036e6:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send();
800036e8:	f0 1f 00 06 	mcall	80003700 <udi_cdc_data_sent+0x3c>
800036ec:	d8 02       	popm	pc
800036ee:	00 00       	add	r0,r0
800036f0:	00 00       	add	r0,r0
800036f2:	07 5f       	ld.sh	pc,--r3
800036f4:	00 00       	add	r0,r0
800036f6:	07 60       	ld.uh	r0,--r3
800036f8:	00 00       	add	r0,r0
800036fa:	08 71       	tst	r1,r4
800036fc:	00 00       	add	r0,r0
800036fe:	07 ee       	ld.ub	lr,r3[0x6]
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	35 ec       	mov	r12,94

80003704 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
80003704:	d4 01       	pushm	lr
	udi_cdc_tx_send();
80003706:	f0 1f 00 02 	mcall	8000370c <udi_cdc_data_sof_notify+0x8>
}
8000370a:	d8 02       	popm	pc
8000370c:	80 00       	ld.sh	r0,r0[0x0]
8000370e:	35 ec       	mov	r12,94

80003710 <udi_cdc_data_enable>:
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
}

bool udi_cdc_data_enable(void)
{
80003710:	eb cd 40 c0 	pushm	r6-r7,lr
	// Initialize TX management
	udi_cdc_tx_trans_ongoing = false;
80003714:	30 06       	mov	r6,0
80003716:	48 f8       	lddpc	r8,80003750 <udi_cdc_data_enable+0x40>
80003718:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send = false;
8000371a:	48 f8       	lddpc	r8,80003754 <udi_cdc_data_enable+0x44>
8000371c:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel = 0;
8000371e:	48 f8       	lddpc	r8,80003758 <udi_cdc_data_enable+0x48>
80003720:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[0] = 0;
80003722:	48 f8       	lddpc	r8,8000375c <udi_cdc_data_enable+0x4c>
80003724:	30 07       	mov	r7,0
80003726:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[1] = 0;
80003728:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num = 0;
8000372a:	48 e8       	lddpc	r8,80003760 <udi_cdc_data_enable+0x50>
8000372c:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send();
8000372e:	f0 1f 00 0e 	mcall	80003764 <udi_cdc_data_enable+0x54>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing = false;
80003732:	48 e8       	lddpc	r8,80003768 <udi_cdc_data_enable+0x58>
80003734:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel = 0;
80003736:	48 e8       	lddpc	r8,8000376c <udi_cdc_data_enable+0x5c>
80003738:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[0] = 0;
8000373a:	48 e8       	lddpc	r8,80003770 <udi_cdc_data_enable+0x60>
8000373c:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos = 0;
8000373e:	48 e8       	lddpc	r8,80003774 <udi_cdc_data_enable+0x64>
80003740:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running = udi_cdc_rx_start();
80003742:	f0 1f 00 0e 	mcall	80003778 <udi_cdc_data_enable+0x68>
80003746:	48 e8       	lddpc	r8,8000377c <udi_cdc_data_enable+0x6c>
80003748:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running;
8000374a:	11 8c       	ld.ub	r12,r8[0x0]
}
8000374c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003750:	00 00       	add	r0,r0
80003752:	07 ee       	ld.ub	lr,r3[0x6]
80003754:	00 00       	add	r0,r0
80003756:	08 71       	tst	r1,r4
80003758:	00 00       	add	r0,r0
8000375a:	07 5f       	ld.sh	pc,--r3
8000375c:	00 00       	add	r0,r0
8000375e:	07 60       	ld.uh	r0,--r3
80003760:	00 00       	add	r0,r0
80003762:	07 ea       	ld.ub	r10,r3[0x6]
80003764:	80 00       	ld.sh	r0,r0[0x0]
80003766:	35 ec       	mov	r12,94
80003768:	00 00       	add	r0,r0
8000376a:	08 70       	tst	r0,r4
8000376c:	00 00       	add	r0,r0
8000376e:	07 ec       	ld.ub	r12,r3[0x6]
80003770:	00 00       	add	r0,r0
80003772:	07 e4       	ld.ub	r4,r3[0x6]
80003774:	00 00       	add	r0,r0
80003776:	07 e8       	ld.ub	r8,r3[0x6]
80003778:	80 00       	ld.sh	r0,r0[0x0]
8000377a:	34 b4       	mov	r4,75
8000377c:	00 00       	add	r0,r0
8000377e:	07 ed       	ld.ub	sp,r3[0x6]

80003780 <udi_cdc_comm_disable>:


void udi_cdc_comm_disable(void)
{
80003780:	d4 01       	pushm	lr
	udi_cdc_running = false;
80003782:	30 09       	mov	r9,0
80003784:	48 38       	lddpc	r8,80003790 <udi_cdc_comm_disable+0x10>
80003786:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
80003788:	f0 1f 00 03 	mcall	80003794 <udi_cdc_comm_disable+0x14>
}
8000378c:	d8 02       	popm	pc
8000378e:	00 00       	add	r0,r0
80003790:	00 00       	add	r0,r0
80003792:	07 ed       	ld.ub	sp,r3[0x6]
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	3f 48       	mov	r8,-12

80003798 <udi_cdc_comm_enable>:

//@}


bool udi_cdc_comm_enable(void)
{
80003798:	d4 01       	pushm	lr
	// Initialize control signal management
	udi_cdc_state = CPU_TO_LE16(0);
8000379a:	30 0a       	mov	r10,0
8000379c:	48 a8       	lddpc	r8,800037c4 <udi_cdc_comm_enable+0x2c>
8000379e:	b0 0a       	st.h	r8[0x0],r10
	uid_cdc_state_msg.value = CPU_TO_LE16(0);
800037a0:	48 a8       	lddpc	r8,800037c8 <udi_cdc_comm_enable+0x30>
800037a2:	b0 4a       	st.h	r8[0x8],r10

	udi_cdc_line_coding.dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
800037a4:	48 a8       	lddpc	r8,800037cc <udi_cdc_comm_enable+0x34>
800037a6:	30 09       	mov	r9,0
800037a8:	b0 8a       	st.b	r8[0x0],r10
800037aa:	3c 2a       	mov	r10,-62
800037ac:	b0 9a       	st.b	r8[0x1],r10
800037ae:	30 1a       	mov	r10,1
800037b0:	b0 aa       	st.b	r8[0x2],r10
800037b2:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding.bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
800037b4:	b0 c9       	st.b	r8[0x4],r9
	udi_cdc_line_coding.bParityType = UDI_CDC_DEFAULT_PARITY;
800037b6:	b0 d9       	st.b	r8[0x5],r9
	udi_cdc_line_coding.bDataBits = UDI_CDC_DEFAULT_DATABITS;
800037b8:	30 89       	mov	r9,8
800037ba:	b0 e9       	st.b	r8[0x6],r9
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));

	// Call application callback
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
800037bc:	f0 1f 00 05 	mcall	800037d0 <udi_cdc_comm_enable+0x38>
}
800037c0:	d8 02       	popm	pc
800037c2:	00 00       	add	r0,r0
800037c4:	00 00       	add	r0,r0
800037c6:	08 72       	tst	r2,r4
800037c8:	00 00       	add	r0,r0
800037ca:	00 50       	eor	r0,r0
800037cc:	00 00       	add	r0,r0
800037ce:	07 58       	ld.sh	r8,--r3
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	3f 3c       	mov	r12,-13

800037d4 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
800037d4:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800037d8:	49 18       	lddpc	r8,8000381c <udc_sof_notify+0x48>
800037da:	11 89       	ld.ub	r9,r8[0x0]
800037dc:	30 08       	mov	r8,0
800037de:	f0 09 18 00 	cp.b	r9,r8
800037e2:	c1 b0       	breq	80003818 <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037e4:	48 f8       	lddpc	r8,80003820 <udc_sof_notify+0x4c>
800037e6:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800037e8:	70 09       	ld.w	r9,r8[0x0]
800037ea:	13 ca       	ld.ub	r10,r9[0x4]
800037ec:	30 09       	mov	r9,0
800037ee:	f2 0a 18 00 	cp.b	r10,r9
800037f2:	c1 30       	breq	80003818 <udc_sof_notify+0x44>
800037f4:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800037f6:	48 b6       	lddpc	r6,80003820 <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
800037f8:	70 18       	ld.w	r8,r8[0x4]
800037fa:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
800037fe:	70 48       	ld.w	r8,r8[0x10]
80003800:	58 08       	cp.w	r8,0
80003802:	c0 20       	breq	80003806 <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
80003804:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003806:	2f f7       	sub	r7,-1
80003808:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
8000380a:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
8000380c:	70 09       	ld.w	r9,r8[0x0]
8000380e:	13 c9       	ld.ub	r9,r9[0x4]
80003810:	ee 09 18 00 	cp.b	r9,r7
80003814:	fe 9b ff f2 	brhi	800037f8 <udc_sof_notify+0x24>
80003818:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000381c:	00 00       	add	r0,r0
8000381e:	08 7e       	tst	lr,r4
80003820:	00 00       	add	r0,r0
80003822:	08 78       	tst	r8,r4

80003824 <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80003824:	48 78       	lddpc	r8,80003840 <udc_get_eof_conf+0x1c>
80003826:	70 08       	ld.w	r8,r8[0x0]
80003828:	70 08       	ld.w	r8,r8[0x0]
8000382a:	11 aa       	ld.ub	r10,r8[0x2]
8000382c:	11 b9       	ld.ub	r9,r8[0x3]
8000382e:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80003832:	5c c9       	swap.bh	r9
80003834:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
80003838:	f0 0c 00 0c 	add	r12,r8,r12
8000383c:	5e fc       	retal	r12
8000383e:	00 00       	add	r0,r0
80003840:	00 00       	add	r0,r0
80003842:	08 78       	tst	r8,r4

80003844 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80003844:	eb cd 40 e0 	pushm	r5-r7,lr
80003848:	18 97       	mov	r7,r12
8000384a:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration)
8000384c:	49 b8       	lddpc	r8,800038b8 <udc_update_iface_desc+0x74>
8000384e:	11 89       	ld.ub	r9,r8[0x0]
80003850:	30 08       	mov	r8,0
80003852:	f0 09 18 00 	cp.b	r9,r8
80003856:	c2 f0       	breq	800038b4 <udc_update_iface_desc+0x70>
		return false;

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003858:	49 98       	lddpc	r8,800038bc <udc_update_iface_desc+0x78>
8000385a:	70 08       	ld.w	r8,r8[0x0]
8000385c:	70 08       	ld.w	r8,r8[0x0]
8000385e:	11 c9       	ld.ub	r9,r8[0x4]
80003860:	18 9e       	mov	lr,r12
80003862:	f8 09 18 00 	cp.b	r9,r12
80003866:	e0 88 00 27 	brls	800038b4 <udc_update_iface_desc+0x70>
		return false;

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
8000386a:	49 65       	lddpc	r5,800038c0 <udc_update_iface_desc+0x7c>
8000386c:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
8000386e:	f0 1f 00 16 	mcall	800038c4 <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
80003872:	6a 08       	ld.w	r8,r5[0x0]
80003874:	10 3c       	cp.w	r12,r8
80003876:	e0 88 00 1f 	brls	800038b4 <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
8000387a:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
8000387c:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
8000387e:	11 9a       	ld.ub	r10,r8[0x1]
80003880:	f6 0a 18 00 	cp.b	r10,r11
80003884:	c0 a1       	brne	80003898 <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber)
80003886:	11 aa       	ld.ub	r10,r8[0x2]
80003888:	0e 9e       	mov	lr,r7
8000388a:	ee 0a 18 00 	cp.b	r10,r7
8000388e:	c0 51       	brne	80003898 <udc_update_iface_desc+0x54>
					&& (setting_num ==
							udc_ptr_iface->
80003890:	11 ba       	ld.ub	r10,r8[0x3]
80003892:	ec 0a 18 00 	cp.b	r10,r6
80003896:	c0 b0       	breq	800038ac <udc_update_iface_desc+0x68>
							bAlternateSetting))
				return true;	// Interface found
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t
80003898:	13 88       	ld.ub	r8,r9[0x0]
8000389a:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
8000389e:	10 3c       	cp.w	r12,r8
800038a0:	fe 9b ff ee 	brhi	8000387c <udc_update_iface_desc+0x38>
800038a4:	48 79       	lddpc	r9,800038c0 <udc_update_iface_desc+0x7c>
800038a6:	93 08       	st.w	r9[0x0],r8
800038a8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800038ac:	48 59       	lddpc	r9,800038c0 <udc_update_iface_desc+0x7c>
800038ae:	93 08       	st.w	r9[0x0],r8
800038b0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800038b4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800038b8:	00 00       	add	r0,r0
800038ba:	08 7e       	tst	lr,r4
800038bc:	00 00       	add	r0,r0
800038be:	08 78       	tst	r8,r4
800038c0:	00 00       	add	r0,r0
800038c2:	08 84       	andn	r4,r4
800038c4:	80 00       	ld.sh	r0,r0[0x0]
800038c6:	38 24       	mov	r4,-126

800038c8 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
800038c8:	eb cd 40 c0 	pushm	r6-r7,lr
800038cc:	18 96       	mov	r6,r12
800038ce:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
800038d0:	f0 1f 00 11 	mcall	80003914 <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800038d4:	0d 88       	ld.ub	r8,r6[0x0]
800038d6:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800038d8:	0c 3c       	cp.w	r12,r6
800038da:	e0 88 00 19 	brls	8000390c <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038de:	0d 98       	ld.ub	r8,r6[0x1]
800038e0:	30 49       	mov	r9,4
800038e2:	f2 08 18 00 	cp.b	r8,r9
800038e6:	c1 30       	breq	8000390c <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038e8:	ee 08 18 00 	cp.b	r8,r7
800038ec:	c0 a1       	brne	80003900 <udc_next_desc_in_iface+0x38>
800038ee:	c1 08       	rjmp	8000390e <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
800038f0:	0d 98       	ld.ub	r8,r6[0x1]
800038f2:	f2 08 18 00 	cp.b	r8,r9
800038f6:	c0 b0       	breq	8000390c <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
800038f8:	ee 08 18 00 	cp.b	r8,r7
800038fc:	c0 31       	brne	80003902 <udc_next_desc_in_iface+0x3a>
800038fe:	c0 88       	rjmp	8000390e <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
80003900:	30 49       	mov	r9,4
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
			return desc;	// Specific descriptor found
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80003902:	0d 88       	ld.ub	r8,r6[0x0]
80003904:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
80003906:	0c 3c       	cp.w	r12,r6
80003908:	fe 9b ff f4 	brhi	800038f0 <udc_next_desc_in_iface+0x28>
8000390c:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL;	// No specific descriptor found
}
8000390e:	0c 9c       	mov	r12,r6
80003910:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	38 24       	mov	r4,-126

80003918 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
80003918:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
8000391a:	48 48       	lddpc	r8,80003928 <udc_valid_address+0x10>
8000391c:	11 bc       	ld.ub	r12,r8[0x3]
8000391e:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80003922:	f0 1f 00 03 	mcall	8000392c <udc_valid_address+0x14>
}
80003926:	d8 02       	popm	pc
80003928:	00 00       	add	r0,r0
8000392a:	0a 00       	add	r0,r5
8000392c:	80 00       	ld.sh	r0,r0[0x0]
8000392e:	23 e4       	sub	r4,62

80003930 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
80003930:	eb cd 40 e0 	pushm	r5-r7,lr
80003934:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num))
80003936:	f0 1f 00 12 	mcall	8000397c <udc_iface_enable+0x4c>
8000393a:	c1 f0       	breq	80003978 <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
8000393c:	49 18       	lddpc	r8,80003980 <udc_iface_enable+0x50>
8000393e:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80003940:	30 56       	mov	r6,5
80003942:	0c 9b       	mov	r11,r6
80003944:	0e 9c       	mov	r12,r7
80003946:	f0 1f 00 10 	mcall	80003984 <udc_iface_enable+0x54>
8000394a:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
8000394c:	c0 d0       	breq	80003966 <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
						ep_desc->bmAttributes,
						le16_to_cpu
8000394e:	19 ca       	ld.ub	r10,r12[0x4]
80003950:	19 d8       	ld.ub	r8,r12[0x5]
80003952:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
80003956:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80003958:	5c 7a       	castu.h	r10
8000395a:	19 bb       	ld.ub	r11,r12[0x3]
8000395c:	19 ac       	ld.ub	r12,r12[0x2]
8000395e:	f0 1f 00 0b 	mcall	80003988 <udc_iface_enable+0x58>
80003962:	cf 01       	brne	80003942 <udc_iface_enable+0x12>
80003964:	c0 a8       	rjmp	80003978 <udc_iface_enable+0x48>
						(ep_desc->wMaxPacketSize)))
			return false;
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
80003966:	48 a8       	lddpc	r8,8000398c <udc_iface_enable+0x5c>
80003968:	70 08       	ld.w	r8,r8[0x0]
8000396a:	70 18       	ld.w	r8,r8[0x4]
8000396c:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
80003970:	70 0c       	ld.w	r12,r8[0x0]
80003972:	5d 1c       	icall	r12
80003974:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003978:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000397c:	80 00       	ld.sh	r0,r0[0x0]
8000397e:	38 44       	mov	r4,-124
80003980:	00 00       	add	r0,r0
80003982:	08 84       	andn	r4,r4
80003984:	80 00       	ld.sh	r0,r0[0x0]
80003986:	38 c8       	mov	r8,-116
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	29 30       	sub	r0,-109
8000398c:	00 00       	add	r0,r0
8000398e:	08 78       	tst	r8,r4

80003990 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
80003990:	eb cd 40 e0 	pushm	r5-r7,lr
80003994:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003996:	18 97       	mov	r7,r12
80003998:	30 0b       	mov	r11,0
8000399a:	f0 1f 00 12 	mcall	800039e0 <udc_iface_disable+0x50>
8000399e:	c1 e0       	breq	800039da <udc_iface_disable+0x4a>
		return false;

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
800039a0:	49 18       	lddpc	r8,800039e4 <udc_iface_disable+0x54>
800039a2:	70 08       	ld.w	r8,r8[0x0]
800039a4:	70 18       	ld.w	r8,r8[0x4]
800039a6:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
800039aa:	6a 3c       	ld.w	r12,r5[0xc]
800039ac:	5d 1c       	icall	r12
800039ae:	18 9b       	mov	r11,r12
800039b0:	0c 9c       	mov	r12,r6
800039b2:	f0 1f 00 0c 	mcall	800039e0 <udc_iface_disable+0x50>
800039b6:	c1 20       	breq	800039da <udc_iface_disable+0x4a>
		return false;

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800039b8:	48 c8       	lddpc	r8,800039e8 <udc_iface_disable+0x58>
800039ba:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800039bc:	30 56       	mov	r6,5
800039be:	0c 9b       	mov	r11,r6
800039c0:	0e 9c       	mov	r12,r7
800039c2:	f0 1f 00 0b 	mcall	800039ec <udc_iface_disable+0x5c>
800039c6:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
							usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc)
800039c8:	c0 50       	breq	800039d2 <udc_iface_disable+0x42>
				break;
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
800039ca:	19 ac       	ld.ub	r12,r12[0x2]
800039cc:	f0 1f 00 09 	mcall	800039f0 <udc_iface_disable+0x60>
		}
800039d0:	cf 7b       	rjmp	800039be <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
800039d2:	6a 18       	ld.w	r8,r5[0x4]
800039d4:	5d 18       	icall	r8
800039d6:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
800039da:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800039de:	00 00       	add	r0,r0
800039e0:	80 00       	ld.sh	r0,r0[0x0]
800039e2:	38 44       	mov	r4,-124
800039e4:	00 00       	add	r0,r0
800039e6:	08 78       	tst	r8,r4
800039e8:	00 00       	add	r0,r0
800039ea:	08 84       	andn	r4,r4
800039ec:	80 00       	ld.sh	r0,r0[0x0]
800039ee:	38 c8       	mov	r8,-116
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	25 a8       	sub	r8,90

800039f4 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device, 
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
800039f4:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
800039f8:	49 38       	lddpc	r8,80003a44 <udc_reset+0x50>
800039fa:	11 89       	ld.ub	r9,r8[0x0]
800039fc:	30 08       	mov	r8,0
800039fe:	f0 09 18 00 	cp.b	r9,r8
80003a02:	c1 70       	breq	80003a30 <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a04:	49 18       	lddpc	r8,80003a48 <udc_reset+0x54>
80003a06:	70 08       	ld.w	r8,r8[0x0]
80003a08:	70 08       	ld.w	r8,r8[0x0]
80003a0a:	11 c9       	ld.ub	r9,r8[0x4]
80003a0c:	30 08       	mov	r8,0
80003a0e:	f0 09 18 00 	cp.b	r9,r8
80003a12:	c0 f0       	breq	80003a30 <udc_reset+0x3c>
80003a14:	30 07       	mov	r7,0
80003a16:	48 d6       	lddpc	r6,80003a48 <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
80003a18:	0e 9c       	mov	r12,r7
80003a1a:	f0 1f 00 0d 	mcall	80003a4c <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003a1e:	2f f7       	sub	r7,-1
80003a20:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a22:	6c 08       	ld.w	r8,r6[0x0]
80003a24:	70 08       	ld.w	r8,r8[0x0]
80003a26:	11 c8       	ld.ub	r8,r8[0x4]
80003a28:	ee 08 18 00 	cp.b	r8,r7
80003a2c:	fe 9b ff f6 	brhi	80003a18 <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80003a30:	30 09       	mov	r9,0
80003a32:	48 58       	lddpc	r8,80003a44 <udc_reset+0x50>
80003a34:	b0 89       	st.b	r8[0x0],r9
	if (0 != (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status)) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80003a36:	e0 69 01 00 	mov	r9,256
80003a3a:	48 68       	lddpc	r8,80003a50 <udc_reset+0x5c>
80003a3c:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
80003a3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a42:	00 00       	add	r0,r0
80003a44:	00 00       	add	r0,r0
80003a46:	08 7e       	tst	lr,r4
80003a48:	00 00       	add	r0,r0
80003a4a:	08 78       	tst	r8,r4
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	39 90       	mov	r0,-103
80003a50:	00 00       	add	r0,r0
80003a52:	08 7c       	tst	r12,r4

80003a54 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
80003a54:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
80003a58:	fe f8 04 3c 	ld.w	r8,pc[1084]
80003a5c:	30 09       	mov	r9,0
80003a5e:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
80003a60:	30 0a       	mov	r10,0
80003a62:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003a64:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003a66:	11 88       	ld.ub	r8,r8[0x0]
80003a68:	10 9a       	mov	r10,r8
80003a6a:	f2 08 18 00 	cp.b	r8,r9
80003a6e:	c0 94       	brge	80003a80 <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0)
80003a70:	fe f9 04 24 	ld.w	r9,pc[1060]
80003a74:	92 3b       	ld.sh	r11,r9[0x6]
80003a76:	30 09       	mov	r9,0
80003a78:	f2 0b 19 00 	cp.h	r11,r9
80003a7c:	e0 80 02 0a 	breq	80003e90 <udc_process_setup+0x43c>
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003a80:	10 99       	mov	r9,r8
80003a82:	e2 19 00 60 	andl	r9,0x60,COH
80003a86:	e0 81 01 d9 	brne	80003e38 <udc_process_setup+0x3e4>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003a8a:	f2 0a 18 00 	cp.b	r10,r9
80003a8e:	e0 84 01 01 	brge	80003c90 <udc_process_setup+0x23c>
		// GET Standard Requests 
		if (udd_g_ctrlreq.req.wLength == 0)
80003a92:	fe f9 04 02 	ld.w	r9,pc[1026]
80003a96:	92 39       	ld.sh	r9,r9[0x6]
80003a98:	58 09       	cp.w	r9,0
80003a9a:	e0 80 01 cf 	breq	80003e38 <udc_process_setup+0x3e4>
			return false;	// Error for USB host

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003a9e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003aa2:	e0 81 00 9e 	brne	80003bde <udc_process_setup+0x18a>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003aa6:	fe fa 03 ee 	ld.w	r10,pc[1006]
80003aaa:	15 9a       	ld.ub	r10,r10[0x1]
80003aac:	30 6b       	mov	r11,6
80003aae:	f6 0a 18 00 	cp.b	r10,r11
80003ab2:	c1 a0       	breq	80003ae6 <udc_process_setup+0x92>
80003ab4:	30 8b       	mov	r11,8
80003ab6:	f6 0a 18 00 	cp.b	r10,r11
80003aba:	e0 80 00 85 	breq	80003bc4 <udc_process_setup+0x170>
80003abe:	30 0b       	mov	r11,0
80003ac0:	f6 0a 18 00 	cp.b	r10,r11
80003ac4:	e0 81 00 8d 	brne	80003bde <udc_process_setup+0x18a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status))
80003ac8:	30 28       	mov	r8,2
80003aca:	f0 09 19 00 	cp.h	r9,r8
80003ace:	c0 40       	breq	80003ad6 <udc_process_setup+0x82>
80003ad0:	30 0c       	mov	r12,0
80003ad2:	e0 8f 01 af 	bral	80003e30 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(
80003ad6:	30 2b       	mov	r11,2
80003ad8:	fe fc 03 c0 	ld.w	r12,pc[960]
80003adc:	f0 1f 00 f0 	mcall	80003e9c <udc_process_setup+0x448>
80003ae0:	30 1c       	mov	r12,1
80003ae2:	e0 8f 01 a7 	bral	80003e30 <udc_process_setup+0x3dc>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003ae6:	fe f8 03 ae 	ld.w	r8,pc[942]
80003aea:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003aec:	f2 08 16 08 	lsr	r8,r9,0x8
80003af0:	30 2a       	mov	r10,2
80003af2:	f4 08 18 00 	cp.b	r8,r10
80003af6:	c1 00       	breq	80003b16 <udc_process_setup+0xc2>
80003af8:	30 3a       	mov	r10,3
80003afa:	f4 08 18 00 	cp.b	r8,r10
80003afe:	c2 a0       	breq	80003b52 <udc_process_setup+0xfe>
80003b00:	30 19       	mov	r9,1
80003b02:	f2 08 18 00 	cp.b	r8,r9
80003b06:	c5 d1       	brne	80003bc0 <udc_process_setup+0x16c>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003b08:	fe f8 03 98 	ld.w	r8,pc[920]
80003b0c:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003b0e:	19 8b       	ld.ub	r11,r12[0x0]
80003b10:	f0 1f 00 e3 	mcall	80003e9c <udc_process_setup+0x448>
80003b14:	c4 78       	rjmp	80003ba2 <udc_process_setup+0x14e>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003b16:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003b18:	fe f8 03 88 	ld.w	r8,pc[904]
80003b1c:	70 08       	ld.w	r8,r8[0x0]
80003b1e:	f1 38 00 11 	ld.ub	r8,r8[17]
80003b22:	f2 08 18 00 	cp.b	r8,r9
80003b26:	e0 88 00 4d 	brls	80003bc0 <udc_process_setup+0x16c>
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003b2a:	fe f8 03 76 	ld.w	r8,pc[886]
80003b2e:	70 18       	ld.w	r8,r8[0x4]
80003b30:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003b34:	19 a9       	ld.ub	r9,r12[0x2]
80003b36:	19 b8       	ld.ub	r8,r12[0x3]
80003b38:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003b3c:	5c c8       	swap.bh	r8
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
80003b3e:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003b42:	f0 1f 00 d7 	mcall	80003e9c <udc_process_setup+0x448>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003b46:	fe f8 03 4e 	ld.w	r8,pc[846]
80003b4a:	70 28       	ld.w	r8,r8[0x8]
80003b4c:	30 29       	mov	r9,2
80003b4e:	b0 99       	st.b	r8[0x1],r9
80003b50:	c2 98       	rjmp	80003ba2 <udc_process_setup+0x14e>
	uint8_t i;
	uint8_t *str;
	uint8_t str_lgt=0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003b52:	5c 59       	castu.b	r9
80003b54:	58 19       	cp.w	r9,1
80003b56:	c1 00       	breq	80003b76 <udc_process_setup+0x122>
80003b58:	58 29       	cp.w	r9,2
80003b5a:	c0 40       	breq	80003b62 <udc_process_setup+0x10e>
80003b5c:	58 09       	cp.w	r9,0
80003b5e:	c0 60       	breq	80003b6a <udc_process_setup+0x116>
80003b60:	c3 08       	rjmp	80003bc0 <udc_process_setup+0x16c>
80003b62:	fe fc 03 42 	ld.w	r12,pc[834]
80003b66:	30 3b       	mov	r11,3
80003b68:	c0 a8       	rjmp	80003b7c <udc_process_setup+0x128>
	case 0:
		udd_set_setup_payload(
80003b6a:	30 4b       	mov	r11,4
80003b6c:	fe fc 03 3c 	ld.w	r12,pc[828]
80003b70:	f0 1f 00 cb 	mcall	80003e9c <udc_process_setup+0x448>
80003b74:	c1 78       	rjmp	80003ba2 <udc_process_setup+0x14e>
80003b76:	fe fc 03 36 	ld.w	r12,pc[822]
80003b7a:	30 9b       	mov	r11,9
80003b7c:	fe fa 03 34 	ld.w	r10,pc[820]
80003b80:	2f ea       	sub	r10,-2
80003b82:	18 98       	mov	r8,r12
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80003b84:	11 39       	ld.ub	r9,r8++
80003b86:	5c c9       	swap.bh	r9
80003b88:	14 b9       	st.h	r10++,r9
#endif
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
80003b8a:	f0 0c 01 09 	sub	r9,r8,r12
80003b8e:	f6 09 18 00 	cp.b	r9,r11
80003b92:	cf 93       	brcs	80003b84 <udc_process_setup+0x130>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}
		
		udc_string_desc.header.bLength = 2 + (str_lgt) * 2;
80003b94:	a1 7b       	lsl	r11,0x1
80003b96:	2f eb       	sub	r11,-2
80003b98:	fe fc 03 18 	ld.w	r12,pc[792]
80003b9c:	b8 8b       	st.b	r12[0x0],r11
		udd_set_setup_payload(
80003b9e:	f0 1f 00 c0 	mcall	80003e9c <udc_process_setup+0x448>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size)
80003ba2:	fe f8 02 f2 	ld.w	r8,pc[754]
80003ba6:	90 39       	ld.sh	r9,r8[0x6]
80003ba8:	90 68       	ld.sh	r8,r8[0xc]
80003baa:	f2 08 19 00 	cp.h	r8,r9
80003bae:	e0 8b 00 04 	brhi	80003bb6 <udc_process_setup+0x162>
80003bb2:	30 1c       	mov	r12,1
80003bb4:	c3 e9       	rjmp	80003e30 <udc_process_setup+0x3dc>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003bb6:	fe f8 02 de 	ld.w	r8,pc[734]
80003bba:	b0 69       	st.h	r8[0xc],r9
80003bbc:	30 1c       	mov	r12,1
80003bbe:	c3 99       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003bc0:	30 0c       	mov	r12,0
80003bc2:	c3 79       	rjmp	80003e30 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1)
80003bc4:	30 18       	mov	r8,1
80003bc6:	f0 09 19 00 	cp.h	r9,r8
80003bca:	c0 30       	breq	80003bd0 <udc_process_setup+0x17c>
80003bcc:	30 0c       	mov	r12,0
80003bce:	c3 19       	rjmp	80003e30 <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(&udc_num_configuration,1);
80003bd0:	30 1b       	mov	r11,1
80003bd2:	fe fc 02 e2 	ld.w	r12,pc[738]
80003bd6:	f0 1f 00 b2 	mcall	80003e9c <udc_process_setup+0x448>
80003bda:	30 1c       	mov	r12,1
80003bdc:	c2 a9       	rjmp	80003e30 <udc_process_setup+0x3dc>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003bde:	58 18       	cp.w	r8,1
80003be0:	c3 61       	brne	80003c4c <udc_process_setup+0x1f8>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003be2:	fe fa 02 b2 	ld.w	r10,pc[690]
80003be6:	15 9b       	ld.ub	r11,r10[0x1]
80003be8:	30 aa       	mov	r10,10
80003bea:	f4 0b 18 00 	cp.b	r11,r10
80003bee:	c2 f1       	brne	80003c4c <udc_process_setup+0x1f8>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1)
80003bf0:	f0 09 19 00 	cp.h	r9,r8
80003bf4:	c2 a1       	brne	80003c48 <udc_process_setup+0x1f4>
		return false;	// Error in request
	if (!udc_num_configuration)
80003bf6:	fe f8 02 be 	ld.w	r8,pc[702]
80003bfa:	11 89       	ld.ub	r9,r8[0x0]
80003bfc:	30 08       	mov	r8,0
80003bfe:	f0 09 18 00 	cp.b	r9,r8
80003c02:	c2 30       	breq	80003c48 <udc_process_setup+0x1f4>
		return false;	// The device is not is configured state yet

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003c04:	fe f8 02 90 	ld.w	r8,pc[656]
80003c08:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003c0a:	fe f8 02 ae 	ld.w	r8,pc[686]
80003c0e:	70 08       	ld.w	r8,r8[0x0]
80003c10:	70 08       	ld.w	r8,r8[0x0]
80003c12:	11 c8       	ld.ub	r8,r8[0x4]
80003c14:	ee 08 18 00 	cp.b	r8,r7
80003c18:	e0 88 00 18 	brls	80003c48 <udc_process_setup+0x1f4>
		return false;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003c1c:	30 0b       	mov	r11,0
80003c1e:	0e 9c       	mov	r12,r7
80003c20:	f0 1f 00 a7 	mcall	80003ebc <udc_process_setup+0x468>
80003c24:	c1 20       	breq	80003c48 <udc_process_setup+0x1f4>
		return false;
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003c26:	fe f8 02 92 	ld.w	r8,pc[658]
80003c2a:	70 08       	ld.w	r8,r8[0x0]
80003c2c:	70 18       	ld.w	r8,r8[0x4]
80003c2e:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003c32:	70 3c       	ld.w	r12,r8[0xc]
80003c34:	5d 1c       	icall	r12
80003c36:	fe f8 02 8a 	ld.w	r8,pc[650]
80003c3a:	b0 8c       	st.b	r8[0x0],r12
	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003c3c:	30 1b       	mov	r11,1
80003c3e:	10 9c       	mov	r12,r8
80003c40:	f0 1f 00 97 	mcall	80003e9c <udc_process_setup+0x448>
80003c44:	30 1c       	mov	r12,1
80003c46:	cf 58       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003c48:	30 0c       	mov	r12,0
80003c4a:	cf 38       	rjmp	80003e30 <udc_process_setup+0x3dc>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003c4c:	58 28       	cp.w	r8,2
80003c4e:	e0 81 00 f5 	brne	80003e38 <udc_process_setup+0x3e4>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c52:	fe f8 02 42 	ld.w	r8,pc[578]
80003c56:	11 9a       	ld.ub	r10,r8[0x1]
80003c58:	30 08       	mov	r8,0
80003c5a:	f0 0a 18 00 	cp.b	r10,r8
80003c5e:	e0 81 00 e8 	brne	80003e2e <udc_process_setup+0x3da>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status))
80003c62:	30 28       	mov	r8,2
80003c64:	f0 09 19 00 	cp.h	r9,r8
80003c68:	c0 30       	breq	80003c6e <udc_process_setup+0x21a>
80003c6a:	30 0c       	mov	r12,0
80003c6c:	ce 28       	rjmp	80003e30 <udc_process_setup+0x3dc>
		return false;

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003c6e:	fe f8 02 26 	ld.w	r8,pc[550]
80003c72:	11 dc       	ld.ub	r12,r8[0x5]
80003c74:	f0 1f 00 94 	mcall	80003ec4 <udc_process_setup+0x470>
80003c78:	e0 68 01 00 	mov	r8,256
80003c7c:	f9 b8 00 00 	moveq	r8,0
80003c80:	fe fc 02 48 	ld.w	r12,pc[584]
80003c84:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload(
80003c86:	30 2b       	mov	r11,2
80003c88:	f0 1f 00 85 	mcall	80003e9c <udc_process_setup+0x448>
80003c8c:	30 1c       	mov	r12,1
80003c8e:	cd 18       	rjmp	80003e30 <udc_process_setup+0x3dc>
			}
		}
#endif
	} else {
		// SET Standard Requests  
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003c90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003c94:	c7 71       	brne	80003d82 <udc_process_setup+0x32e>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c96:	fe f9 01 fe 	ld.w	r9,pc[510]
80003c9a:	13 99       	ld.ub	r9,r9[0x1]
80003c9c:	30 3a       	mov	r10,3
80003c9e:	f4 09 18 00 	cp.b	r9,r10
80003ca2:	e0 80 00 c6 	breq	80003e2e <udc_process_setup+0x3da>
80003ca6:	e0 8b 00 07 	brhi	80003cb4 <udc_process_setup+0x260>
80003caa:	30 1a       	mov	r10,1
80003cac:	f4 09 18 00 	cp.b	r9,r10
80003cb0:	c6 91       	brne	80003d82 <udc_process_setup+0x32e>
80003cb2:	c1 78       	rjmp	80003ce0 <udc_process_setup+0x28c>
80003cb4:	30 5a       	mov	r10,5
80003cb6:	f4 09 18 00 	cp.b	r9,r10
80003cba:	c0 60       	breq	80003cc6 <udc_process_setup+0x272>
80003cbc:	30 9a       	mov	r10,9
80003cbe:	f4 09 18 00 	cp.b	r9,r10
80003cc2:	c6 01       	brne	80003d82 <udc_process_setup+0x32e>
80003cc4:	c2 28       	rjmp	80003d08 <udc_process_setup+0x2b4>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003cc6:	4f 48       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003cc8:	90 39       	ld.sh	r9,r8[0x6]
80003cca:	30 08       	mov	r8,0
80003ccc:	f0 09 19 00 	cp.h	r9,r8
80003cd0:	c0 30       	breq	80003cd6 <udc_process_setup+0x282>
80003cd2:	30 0c       	mov	r12,0
80003cd4:	ca e8       	rjmp	80003e30 <udc_process_setup+0x3dc>
		return false;

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003cd6:	4f e9       	lddpc	r9,80003ecc <udc_process_setup+0x478>
80003cd8:	4e f8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003cda:	91 49       	st.w	r8[0x10],r9
80003cdc:	30 1c       	mov	r12,1
80003cde:	ca 98       	rjmp	80003e30 <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003ce0:	4e d8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003ce2:	90 39       	ld.sh	r9,r8[0x6]
80003ce4:	30 08       	mov	r8,0
80003ce6:	f0 09 19 00 	cp.h	r9,r8
80003cea:	c0 d1       	brne	80003d04 <udc_process_setup+0x2b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003cec:	4e a8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003cee:	90 19       	ld.sh	r9,r8[0x2]
80003cf0:	30 18       	mov	r8,1
80003cf2:	f0 09 19 00 	cp.h	r9,r8
80003cf6:	c0 71       	brne	80003d04 <udc_process_setup+0x2b0>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003cf8:	4e 88       	lddpc	r8,80003e98 <udc_process_setup+0x444>
80003cfa:	90 09       	ld.sh	r9,r8[0x0]
80003cfc:	a9 d9       	cbr	r9,0x9
80003cfe:	b0 09       	st.h	r8[0x0],r9
80003d00:	30 1c       	mov	r12,1
80003d02:	c9 78       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003d04:	30 0c       	mov	r12,0
80003d06:	c9 58       	rjmp	80003e30 <udc_process_setup+0x3dc>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength != 0)
80003d08:	4e 38       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003d0a:	90 39       	ld.sh	r9,r8[0x6]
80003d0c:	30 08       	mov	r8,0
80003d0e:	f0 09 19 00 	cp.h	r9,r8
80003d12:	c3 41       	brne	80003d7a <udc_process_setup+0x326>
		return false;
	// Authorize configuration only if the address is valid
	if (!udd_getaddress())
80003d14:	f0 1f 00 6f 	mcall	80003ed0 <udc_process_setup+0x47c>
80003d18:	c3 10       	breq	80003d7a <udc_process_setup+0x326>
			return false;
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003d1a:	4d f8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003d1c:	11 b9       	ld.ub	r9,r8[0x3]
80003d1e:	4e 18       	lddpc	r8,80003ea0 <udc_process_setup+0x44c>
80003d20:	70 08       	ld.w	r8,r8[0x0]
80003d22:	f1 38 00 11 	ld.ub	r8,r8[17]
80003d26:	10 39       	cp.w	r9,r8
80003d28:	e0 89 00 29 	brgt	80003d7a <udc_process_setup+0x326>
				udc_config.confdev_lsfs->bNumConfigurations)
			return false;
	}

	// Reset current configuration
	udc_reset();
80003d2c:	f0 1f 00 6a 	mcall	80003ed4 <udc_process_setup+0x480>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003d30:	4d 98       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003d32:	11 b8       	ld.ub	r8,r8[0x3]
80003d34:	4e 09       	lddpc	r9,80003eb4 <udc_process_setup+0x460>
80003d36:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003d38:	58 08       	cp.w	r8,0
80003d3a:	c2 20       	breq	80003d7e <udc_process_setup+0x32a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003d3c:	20 18       	sub	r8,1
80003d3e:	4d 99       	lddpc	r9,80003ea0 <udc_process_setup+0x44c>
80003d40:	72 19       	ld.w	r9,r9[0x4]
80003d42:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003d46:	4d d9       	lddpc	r9,80003eb8 <udc_process_setup+0x464>
80003d48:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d4a:	70 08       	ld.w	r8,r8[0x0]
80003d4c:	11 c9       	ld.ub	r9,r8[0x4]
80003d4e:	30 08       	mov	r8,0
80003d50:	f0 09 18 00 	cp.b	r9,r8
80003d54:	c1 50       	breq	80003d7e <udc_process_setup+0x32a>
80003d56:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d58:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d5a:	4d 86       	lddpc	r6,80003eb8 <udc_process_setup+0x464>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d5c:	0a 9b       	mov	r11,r5
80003d5e:	0e 9c       	mov	r12,r7
80003d60:	f0 1f 00 5e 	mcall	80003ed8 <udc_process_setup+0x484>
80003d64:	c0 b0       	breq	80003d7a <udc_process_setup+0x326>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003d66:	2f f7       	sub	r7,-1
80003d68:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d6a:	6c 08       	ld.w	r8,r6[0x0]
80003d6c:	70 08       	ld.w	r8,r8[0x0]
80003d6e:	11 c8       	ld.ub	r8,r8[0x4]
80003d70:	ee 08 18 00 	cp.b	r8,r7
80003d74:	fe 9b ff f4 	brhi	80003d5c <udc_process_setup+0x308>
80003d78:	c0 38       	rjmp	80003d7e <udc_process_setup+0x32a>
80003d7a:	30 0c       	mov	r12,0
80003d7c:	c5 a8       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003d7e:	30 1c       	mov	r12,1
80003d80:	c5 88       	rjmp	80003e30 <udc_process_setup+0x3dc>
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003d82:	58 18       	cp.w	r8,1
80003d84:	c2 21       	brne	80003dc8 <udc_process_setup+0x374>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003d86:	4c 49       	lddpc	r9,80003e94 <udc_process_setup+0x440>
80003d88:	13 9a       	ld.ub	r10,r9[0x1]
80003d8a:	30 b9       	mov	r9,11
80003d8c:	f2 0a 18 00 	cp.b	r10,r9
80003d90:	c1 c1       	brne	80003dc8 <udc_process_setup+0x374>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength != 0)
80003d92:	4c 18       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003d94:	90 39       	ld.sh	r9,r8[0x6]
80003d96:	30 08       	mov	r8,0
80003d98:	f0 09 19 00 	cp.h	r9,r8
80003d9c:	c1 41       	brne	80003dc4 <udc_process_setup+0x370>
		return false;	// Error in request
	if (!udc_num_configuration)
80003d9e:	4c 68       	lddpc	r8,80003eb4 <udc_process_setup+0x460>
80003da0:	11 89       	ld.ub	r9,r8[0x0]
80003da2:	30 08       	mov	r8,0
80003da4:	f0 09 18 00 	cp.b	r9,r8
80003da8:	c0 e0       	breq	80003dc4 <udc_process_setup+0x370>
		return false;	// The device is not is configured state yet


	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003daa:	4b b8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003dac:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num))
80003dae:	11 d7       	ld.ub	r7,r8[0x5]
80003db0:	0e 9c       	mov	r12,r7
80003db2:	f0 1f 00 4b 	mcall	80003edc <udc_process_setup+0x488>
80003db6:	c0 70       	breq	80003dc4 <udc_process_setup+0x370>
		return false;

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003db8:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003dbc:	0e 9c       	mov	r12,r7
80003dbe:	f0 1f 00 47 	mcall	80003ed8 <udc_process_setup+0x484>
80003dc2:	c3 78       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003dc4:	30 0c       	mov	r12,0
80003dc6:	c3 58       	rjmp	80003e30 <udc_process_setup+0x3dc>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003dc8:	58 28       	cp.w	r8,2
80003dca:	c3 71       	brne	80003e38 <udc_process_setup+0x3e4>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003dcc:	4b 28       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003dce:	11 98       	ld.ub	r8,r8[0x1]
80003dd0:	30 19       	mov	r9,1
80003dd2:	f2 08 18 00 	cp.b	r8,r9
80003dd6:	c0 60       	breq	80003de2 <udc_process_setup+0x38e>
80003dd8:	30 39       	mov	r9,3
80003dda:	f2 08 18 00 	cp.b	r8,r9
80003dde:	c2 81       	brne	80003e2e <udc_process_setup+0x3da>
80003de0:	c1 48       	rjmp	80003e08 <udc_process_setup+0x3b4>
 *
 * \return true if success 
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003de2:	4a d8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003de4:	90 39       	ld.sh	r9,r8[0x6]
80003de6:	30 08       	mov	r8,0
80003de8:	f0 09 19 00 	cp.h	r9,r8
80003dec:	c0 c1       	brne	80003e04 <udc_process_setup+0x3b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003dee:	4a a8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003df0:	90 19       	ld.sh	r9,r8[0x2]
80003df2:	30 08       	mov	r8,0
80003df4:	f0 09 19 00 	cp.h	r9,r8
80003df8:	c0 61       	brne	80003e04 <udc_process_setup+0x3b0>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003dfa:	4a 78       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003dfc:	11 dc       	ld.ub	r12,r8[0x5]
80003dfe:	f0 1f 00 39 	mcall	80003ee0 <udc_process_setup+0x48c>
80003e02:	c1 78       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003e04:	30 0c       	mov	r12,0
80003e06:	c1 58       	rjmp	80003e30 <udc_process_setup+0x3dc>
 * \return true if success 
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003e08:	4a 38       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003e0a:	90 39       	ld.sh	r9,r8[0x6]
80003e0c:	30 08       	mov	r8,0
80003e0e:	f0 09 19 00 	cp.h	r9,r8
80003e12:	c0 c1       	brne	80003e2a <udc_process_setup+0x3d6>
		return false;
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003e14:	4a 08       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003e16:	90 19       	ld.sh	r9,r8[0x2]
80003e18:	30 08       	mov	r8,0
80003e1a:	f0 09 19 00 	cp.h	r9,r8
80003e1e:	c0 61       	brne	80003e2a <udc_process_setup+0x3d6>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e20:	49 d8       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003e22:	11 dc       	ld.ub	r12,r8[0x5]
80003e24:	f0 1f 00 30 	mcall	80003ee4 <udc_process_setup+0x490>
80003e28:	c0 48       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003e2a:	30 0c       	mov	r12,0
80003e2c:	c0 28       	rjmp	80003e30 <udc_process_setup+0x3dc>
80003e2e:	30 0c       	mov	r12,0
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd())
80003e30:	58 0c       	cp.w	r12,0
80003e32:	c0 30       	breq	80003e38 <udc_process_setup+0x3e4>
80003e34:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003e38:	49 78       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003e3a:	11 88       	ld.ub	r8,r8[0x0]
80003e3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e40:	58 18       	cp.w	r8,1
80003e42:	c2 71       	brne	80003e90 <udc_process_setup+0x43c>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration)
80003e44:	49 c8       	lddpc	r8,80003eb4 <udc_process_setup+0x460>
80003e46:	11 89       	ld.ub	r9,r8[0x0]
80003e48:	30 08       	mov	r8,0
80003e4a:	f0 09 18 00 	cp.b	r9,r8
80003e4e:	c2 10       	breq	80003e90 <udc_process_setup+0x43c>
		return false;	// The device is not is configured state yet
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003e50:	49 18       	lddpc	r8,80003e94 <udc_process_setup+0x440>
80003e52:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003e54:	49 98       	lddpc	r8,80003eb8 <udc_process_setup+0x464>
80003e56:	70 08       	ld.w	r8,r8[0x0]
80003e58:	70 08       	ld.w	r8,r8[0x0]
80003e5a:	11 c8       	ld.ub	r8,r8[0x4]
80003e5c:	ee 08 18 00 	cp.b	r8,r7
80003e60:	e0 88 00 18 	brls	80003e90 <udc_process_setup+0x43c>
		return false;

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003e64:	0e 96       	mov	r6,r7
80003e66:	30 0b       	mov	r11,0
80003e68:	0e 9c       	mov	r12,r7
80003e6a:	f0 1f 00 15 	mcall	80003ebc <udc_process_setup+0x468>
80003e6e:	c1 10       	breq	80003e90 <udc_process_setup+0x43c>
		return false;
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003e70:	49 28       	lddpc	r8,80003eb8 <udc_process_setup+0x464>
80003e72:	70 08       	ld.w	r8,r8[0x0]
80003e74:	70 18       	ld.w	r8,r8[0x4]
80003e76:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003e7a:	6e 3c       	ld.w	r12,r7[0xc]
80003e7c:	5d 1c       	icall	r12
80003e7e:	18 9b       	mov	r11,r12
80003e80:	0c 9c       	mov	r12,r6
80003e82:	f0 1f 00 0f 	mcall	80003ebc <udc_process_setup+0x468>
80003e86:	c0 50       	breq	80003e90 <udc_process_setup+0x43c>
		return false;

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003e88:	6e 2c       	ld.w	r12,r7[0x8]
80003e8a:	5d 1c       	icall	r12
80003e8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e90:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003e94:	00 00       	add	r0,r0
80003e96:	0a 00       	add	r0,r5
80003e98:	00 00       	add	r0,r0
80003e9a:	08 7c       	tst	r12,r4
80003e9c:	80 00       	ld.sh	r0,r0[0x0]
80003e9e:	24 2c       	sub	r12,66
80003ea0:	00 00       	add	r0,r0
80003ea2:	00 b0       	st.h	r0++,r0
80003ea4:	00 00       	add	r0,r0
80003ea6:	00 cc       	st.b	r0++,r12
80003ea8:	00 00       	add	r0,r0
80003eaa:	00 f0       	st.b	--r0,r0
80003eac:	00 00       	add	r0,r0
80003eae:	00 d0       	st.w	--r0,r0
80003eb0:	00 00       	add	r0,r0
80003eb2:	00 dc       	st.w	--r0,r12
80003eb4:	00 00       	add	r0,r0
80003eb6:	08 7e       	tst	lr,r4
80003eb8:	00 00       	add	r0,r0
80003eba:	08 78       	tst	r8,r4
80003ebc:	80 00       	ld.sh	r0,r0[0x0]
80003ebe:	38 44       	mov	r4,-124
80003ec0:	00 00       	add	r0,r0
80003ec2:	08 74       	tst	r4,r4
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	24 38       	sub	r8,67
80003ec8:	00 00       	add	r0,r0
80003eca:	08 80       	andn	r0,r4
80003ecc:	80 00       	ld.sh	r0,r0[0x0]
80003ece:	39 18       	mov	r8,-111
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	24 06       	sub	r6,64
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	39 f4       	mov	r4,-97
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	39 30       	mov	r0,-109
80003edc:	80 00       	ld.sh	r0,r0[0x0]
80003ede:	39 90       	mov	r0,-103
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	24 c8       	sub	r8,76
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	24 4c       	sub	r12,68

80003ee8 <_read>:
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80003ee8:	eb cd 40 fc 	pushm	r2-r7,lr
80003eec:	20 1d       	sub	sp,4
80003eee:	16 94       	mov	r4,r11
80003ef0:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0)
80003ef2:	58 0c       	cp.w	r12,0
80003ef4:	c0 30       	breq	80003efa <_read+0x12>
80003ef6:	3f f7       	mov	r7,-1
80003ef8:	c1 98       	rjmp	80003f2a <_read+0x42>
		return -1;

	for (; len > 0; --len) {
80003efa:	58 0a       	cp.w	r10,0
80003efc:	e0 89 00 04 	brgt	80003f04 <_read+0x1c>
80003f00:	30 07       	mov	r7,0
80003f02:	c1 48       	rjmp	80003f2a <_read+0x42>
80003f04:	30 07       	mov	r7,0
		int c;
		ptr_get(stdio_base,&c);
80003f06:	48 c3       	lddpc	r3,80003f34 <_read+0x4c>
80003f08:	48 c6       	lddpc	r6,80003f38 <_read+0x50>
80003f0a:	1a 92       	mov	r2,sp
80003f0c:	66 0c       	ld.w	r12,r3[0x0]
80003f0e:	6c 08       	ld.w	r8,r6[0x0]
80003f10:	1a 9b       	mov	r11,sp
80003f12:	5d 18       	icall	r8
		if (c < 0)
80003f14:	40 08       	lddsp	r8,sp[0x0]
80003f16:	58 08       	cp.w	r8,0
80003f18:	c0 95       	brlt	80003f2a <_read+0x42>
		break;
		*ptr++ = c;
80003f1a:	e8 07 0b 08 	st.b	r4[r7],r8
		++nChars;
80003f1e:	2f f7       	sub	r7,-1
// GCC AVR32 implementation
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
80003f20:	ea 07 01 08 	sub	r8,r5,r7
	int nChars = 0;

	if (file != 0)
		return -1;

	for (; len > 0; --len) {
80003f24:	58 08       	cp.w	r8,0
80003f26:	fe 99 ff f3 	brgt	80003f0c <_read+0x24>
		break;
		*ptr++ = c;
		++nChars;
	}
	return nChars;
}
80003f2a:	0e 9c       	mov	r12,r7
80003f2c:	2f fd       	sub	sp,-4
80003f2e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003f32:	00 00       	add	r0,r0
80003f34:	00 00       	add	r0,r0
80003f36:	0a 28       	rsub	r8,r5
80003f38:	00 00       	add	r0,r0
80003f3a:	0a 20       	rsub	r0,r5

80003f3c <stdio_usb_enable>:
	}
}

bool stdio_usb_enable(void)
{
	stdio_usb_interface_enable = true;
80003f3c:	30 19       	mov	r9,1
80003f3e:	48 28       	lddpc	r8,80003f44 <stdio_usb_enable+0x8>
80003f40:	b0 89       	st.b	r8[0x0],r9
	return true;
}
80003f42:	5e ff       	retal	1
80003f44:	00 00       	add	r0,r0
80003f46:	08 88       	andn	r8,r4

80003f48 <stdio_usb_disable>:

void stdio_usb_disable(void)
{
	stdio_usb_interface_enable = false;
80003f48:	30 09       	mov	r9,0
80003f4a:	48 28       	lddpc	r8,80003f50 <stdio_usb_disable+0x8>
80003f4c:	b0 89       	st.b	r8[0x0],r9
}
80003f4e:	5e fc       	retal	r12
80003f50:	00 00       	add	r0,r0
80003f52:	08 88       	andn	r8,r4

80003f54 <stdio_usb_vbus_event>:
	
	*data = udi_cdc_getc ();
}

void stdio_usb_vbus_event(bool b_high)
{
80003f54:	d4 01       	pushm	lr
	if (b_high) {
80003f56:	58 0c       	cp.w	r12,0
80003f58:	c0 40       	breq	80003f60 <stdio_usb_vbus_event+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003f5a:	f0 1f 00 04 	mcall	80003f68 <stdio_usb_vbus_event+0x14>
80003f5e:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003f60:	f0 1f 00 03 	mcall	80003f6c <stdio_usb_vbus_event+0x18>
80003f64:	d8 02       	popm	pc
80003f66:	00 00       	add	r0,r0
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	2a c0       	sub	r0,-84
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	27 70       	sub	r0,119

80003f70 <stdio_usb_init>:
{
	stdio_usb_interface_enable = false;
}

void stdio_usb_init (volatile void * usart)
{
80003f70:	d4 01       	pushm	lr
	stdio_base = usart;
80003f72:	48 98       	lddpc	r8,80003f94 <stdio_usb_init+0x24>
80003f74:	91 0c       	st.w	r8[0x0],r12
	ptr_put = stdio_usb_putchar;
80003f76:	48 99       	lddpc	r9,80003f98 <stdio_usb_init+0x28>
80003f78:	48 98       	lddpc	r8,80003f9c <stdio_usb_init+0x2c>
80003f7a:	91 09       	st.w	r8[0x0],r9
	ptr_get = stdio_usb_getchar;
80003f7c:	48 99       	lddpc	r9,80003fa0 <stdio_usb_init+0x30>
80003f7e:	48 a8       	lddpc	r8,80003fa4 <stdio_usb_init+0x34>
80003f80:	91 09       	st.w	r8[0x0],r9

/*! \brief Start the USB Device stack
 */
static inline void udc_start(void)
{
	udd_enable();
80003f82:	f0 1f 00 0a 	mcall	80003fa8 <stdio_usb_init+0x38>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003f86:	f0 1f 00 0a 	mcall	80003fac <stdio_usb_init+0x3c>
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();

	if (! udc_include_vbus_monitoring ()) {
80003f8a:	c0 41       	brne	80003f92 <stdio_usb_init+0x22>
		stdio_usb_vbus_event (true);
80003f8c:	30 1c       	mov	r12,1
80003f8e:	f0 1f 00 09 	mcall	80003fb0 <stdio_usb_init+0x40>
80003f92:	d8 02       	popm	pc
80003f94:	00 00       	add	r0,r0
80003f96:	0a 28       	rsub	r8,r5
80003f98:	80 00       	ld.sh	r0,r0[0x0]
80003f9a:	3f e0       	mov	r0,-2
80003f9c:	00 00       	add	r0,r0
80003f9e:	0a 24       	rsub	r4,r5
80003fa0:	80 00       	ld.sh	r0,r0[0x0]
80003fa2:	3f b4       	mov	r4,-5
80003fa4:	00 00       	add	r0,r0
80003fa6:	0a 20       	rsub	r0,r5
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	2b 30       	sub	r0,-77
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	23 e0       	sub	r0,62
80003fb0:	80 00       	ld.sh	r0,r0[0x0]
80003fb2:	3f 54       	mov	r4,-11

80003fb4 <stdio_usb_getchar>:

	return udi_cdc_putc (data) ? 0 : -1;
}

void stdio_usb_getchar (void volatile * usart, int * data)
{
80003fb4:	eb cd 40 80 	pushm	r7,lr
80003fb8:	16 97       	mov	r7,r11
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003fba:	48 88       	lddpc	r8,80003fd8 <stdio_usb_getchar+0x24>
80003fbc:	11 89       	ld.ub	r9,r8[0x0]
80003fbe:	30 08       	mov	r8,0
80003fc0:	f0 09 18 00 	cp.b	r9,r8
80003fc4:	c0 51       	brne	80003fce <stdio_usb_getchar+0x1a>
		*data = 0;  // -1
80003fc6:	30 08       	mov	r8,0
80003fc8:	97 08       	st.w	r11[0x0],r8
		return;
80003fca:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	
	*data = udi_cdc_getc ();
80003fce:	f0 1f 00 04 	mcall	80003fdc <stdio_usb_getchar+0x28>
80003fd2:	8f 0c       	st.w	r7[0x0],r12
80003fd4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003fd8:	00 00       	add	r0,r0
80003fda:	08 88       	andn	r8,r4
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	35 38       	mov	r8,83

80003fe0 <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * usart, int data)
{
80003fe0:	d4 01       	pushm	lr
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003fe2:	48 78       	lddpc	r8,80003ffc <stdio_usb_putchar+0x1c>
80003fe4:	11 89       	ld.ub	r9,r8[0x0]
80003fe6:	30 08       	mov	r8,0
80003fe8:	f0 09 18 00 	cp.b	r9,r8
80003fec:	c0 60       	breq	80003ff8 <stdio_usb_putchar+0x18>
		return 0;  // -1
	}

	return udi_cdc_putc (data) ? 0 : -1;
80003fee:	16 9c       	mov	r12,r11
80003ff0:	f0 1f 00 04 	mcall	80004000 <stdio_usb_putchar+0x20>
80003ff4:	c0 21       	brne	80003ff8 <stdio_usb_putchar+0x18>
80003ff6:	dc 0a       	popm	pc,r12=-1
80003ff8:	d8 0a       	popm	pc,r12=0
80003ffa:	00 00       	add	r0,r0
80003ffc:	00 00       	add	r0,r0
80003ffe:	08 88       	andn	r8,r4
80004000:	80 00       	ld.sh	r0,r0[0x0]
80004002:	34 38       	mov	r8,67

80004004 <_write>:

#elif (defined(__GNUC__) && !defined(XMEGA))

	int __attribute__((weak))
	_write (int file, char * ptr, int len)
	{
80004004:	eb cd 40 f8 	pushm	r3-r7,lr
80004008:	16 94       	mov	r4,r11
8000400a:	14 95       	mov	r5,r10
		int nChars = 0;
	
		if ( (file != 1)
8000400c:	20 1c       	sub	r12,1
8000400e:	58 2c       	cp.w	r12,2
80004010:	e0 8b 00 13 	brhi	80004036 <_write+0x32>
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80004014:	58 0a       	cp.w	r10,0
80004016:	c0 31       	brne	8000401c <_write+0x18>
80004018:	30 07       	mov	r7,0
8000401a:	c0 f8       	rjmp	80004038 <_write+0x34>
8000401c:	30 07       	mov	r7,0
			if (ptr_put(stdio_base, *ptr++) < 0) {
8000401e:	48 93       	lddpc	r3,80004040 <_write+0x3c>
80004020:	48 96       	lddpc	r6,80004044 <_write+0x40>
80004022:	66 0c       	ld.w	r12,r3[0x0]
80004024:	6c 08       	ld.w	r8,r6[0x0]
80004026:	e8 07 07 0b 	ld.ub	r11,r4[r7]
8000402a:	5d 18       	icall	r8
8000402c:	c0 55       	brlt	80004036 <_write+0x32>
				return -1;
			}
			++nChars;
8000402e:	2f f7       	sub	r7,-1
	
		if ( (file != 1)
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80004030:	0e 35       	cp.w	r5,r7
80004032:	cf 81       	brne	80004022 <_write+0x1e>
80004034:	c0 28       	rjmp	80004038 <_write+0x34>
80004036:	3f f7       	mov	r7,-1
				return -1;
			}
			++nChars;
		}
		return nChars;
	}
80004038:	0e 9c       	mov	r12,r7
8000403a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000403e:	00 00       	add	r0,r0
80004040:	00 00       	add	r0,r0
80004042:	0a 28       	rsub	r8,r5
80004044:	00 00       	add	r0,r0
80004046:	0a 24       	rsub	r4,r5

80004048 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004048:	f8 c8 ff f8 	sub	r8,r12,-8
8000404c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000404e:	3f f9       	mov	r9,-1
80004050:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004052:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004054:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004056:	30 08       	mov	r8,0
80004058:	99 08       	st.w	r12[0x0],r8
}
8000405a:	5e fc       	retal	r12

8000405c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
8000405c:	30 08       	mov	r8,0
8000405e:	99 48       	st.w	r12[0x10],r8
}
80004060:	5e fc       	retal	r12

80004062 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004062:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004064:	70 19       	ld.w	r9,r8[0x4]
80004066:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004068:	78 19       	ld.w	r9,r12[0x4]
8000406a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000406c:	70 19       	ld.w	r9,r8[0x4]
8000406e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004070:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004072:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004074:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004076:	78 08       	ld.w	r8,r12[0x0]
80004078:	2f f8       	sub	r8,-1
8000407a:	99 08       	st.w	r12[0x0],r8
}
8000407c:	5e fc       	retal	r12

8000407e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000407e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004080:	5b fa       	cp.w	r10,-1
80004082:	c0 31       	brne	80004088 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004084:	78 48       	ld.w	r8,r12[0x10]
80004086:	c0 c8       	rjmp	8000409e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004088:	f8 c8 ff f8 	sub	r8,r12,-8
8000408c:	70 19       	ld.w	r9,r8[0x4]
8000408e:	72 09       	ld.w	r9,r9[0x0]
80004090:	12 3a       	cp.w	r10,r9
80004092:	c0 63       	brcs	8000409e <vListInsert+0x20>
80004094:	70 18       	ld.w	r8,r8[0x4]
80004096:	70 19       	ld.w	r9,r8[0x4]
80004098:	72 09       	ld.w	r9,r9[0x0]
8000409a:	12 3a       	cp.w	r10,r9
8000409c:	cf c2       	brcc	80004094 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000409e:	70 19       	ld.w	r9,r8[0x4]
800040a0:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800040a2:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800040a4:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800040a6:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800040a8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800040aa:	78 08       	ld.w	r8,r12[0x0]
800040ac:	2f f8       	sub	r8,-1
800040ae:	99 08       	st.w	r12[0x0],r8
}
800040b0:	5e fc       	retal	r12

800040b2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800040b2:	78 18       	ld.w	r8,r12[0x4]
800040b4:	78 29       	ld.w	r9,r12[0x8]
800040b6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800040b8:	78 28       	ld.w	r8,r12[0x8]
800040ba:	78 19       	ld.w	r9,r12[0x4]
800040bc:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800040be:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800040c0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800040c2:	18 39       	cp.w	r9,r12
800040c4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800040c8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800040cc:	30 09       	mov	r9,0
800040ce:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800040d0:	70 09       	ld.w	r9,r8[0x0]
800040d2:	20 19       	sub	r9,1
800040d4:	91 09       	st.w	r8[0x0],r9
}
800040d6:	5e fc       	retal	r12

800040d8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800040d8:	e0 68 08 08 	mov	r8,2056
800040dc:	ea 18 08 08 	orh	r8,0x808
800040e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800040e2:	e0 68 09 09 	mov	r8,2313
800040e6:	ea 18 09 09 	orh	r8,0x909
800040ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800040ec:	e0 68 0a 0a 	mov	r8,2570
800040f0:	ea 18 0a 0a 	orh	r8,0xa0a
800040f4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800040f6:	e0 68 0b 0b 	mov	r8,2827
800040fa:	ea 18 0b 0b 	orh	r8,0xb0b
800040fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004100:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004102:	e0 68 be ef 	mov	r8,48879
80004106:	ea 18 de ad 	orh	r8,0xdead
8000410a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000410c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000410e:	fc 18 00 40 	movh	r8,0x40
80004112:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004114:	e0 68 00 ff 	mov	r8,255
80004118:	ea 18 ff 00 	orh	r8,0xff00
8000411c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000411e:	e0 68 01 01 	mov	r8,257
80004122:	ea 18 01 01 	orh	r8,0x101
80004126:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004128:	e0 68 02 02 	mov	r8,514
8000412c:	ea 18 02 02 	orh	r8,0x202
80004130:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004132:	e0 68 03 03 	mov	r8,771
80004136:	ea 18 03 03 	orh	r8,0x303
8000413a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000413c:	e0 68 04 04 	mov	r8,1028
80004140:	ea 18 04 04 	orh	r8,0x404
80004144:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004146:	e0 68 05 05 	mov	r8,1285
8000414a:	ea 18 05 05 	orh	r8,0x505
8000414e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004150:	e0 68 06 06 	mov	r8,1542
80004154:	ea 18 06 06 	orh	r8,0x606
80004158:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000415a:	e0 68 07 07 	mov	r8,1799
8000415e:	ea 18 07 07 	orh	r8,0x707
80004162:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004164:	30 08       	mov	r8,0
80004166:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004168:	5e fc       	retal	r12
8000416a:	d7 03       	nop

8000416c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
8000416c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000416e:	48 38       	lddpc	r8,80004178 <vPortEnterCritical+0xc>
80004170:	70 09       	ld.w	r9,r8[0x0]
80004172:	2f f9       	sub	r9,-1
80004174:	91 09       	st.w	r8[0x0],r9
}
80004176:	5e fc       	retal	r12
80004178:	00 00       	add	r0,r0
8000417a:	00 f4       	st.b	--r0,r4

8000417c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000417c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000417e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004180:	30 0a       	mov	r10,0
80004182:	14 9b       	mov	r11,r10
80004184:	49 2c       	lddpc	r12,800041cc <xPortStartScheduler+0x50>
80004186:	f0 1f 00 13 	mcall	800041d0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000418a:	e0 68 2e e0 	mov	r8,12000
8000418e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004192:	30 08       	mov	r8,0
80004194:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004198:	e0 68 09 5c 	mov	r8,2396
8000419c:	ea 18 00 00 	orh	r8,0x0
800041a0:	70 00       	ld.w	r0,r8[0x0]
800041a2:	60 0d       	ld.w	sp,r0[0x0]
800041a4:	1b 00       	ld.w	r0,sp++
800041a6:	e0 68 00 f4 	mov	r8,244
800041aa:	ea 18 00 00 	orh	r8,0x0
800041ae:	91 00       	st.w	r8[0x0],r0
800041b0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800041b4:	2f ed       	sub	sp,-8
800041b6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800041ba:	fa f0 ff e0 	ld.w	r0,sp[-32]
800041be:	e3 b0 00 00 	mtsr	0x0,r0
800041c2:	fa f0 ff dc 	ld.w	r0,sp[-36]
800041c6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800041ca:	d8 0a       	popm	pc,r12=0
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	42 98       	lddsp	r8,sp[0xa4]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	22 50       	sub	r0,37

800041d4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800041d4:	20 6d       	sub	sp,24
800041d6:	eb cd 00 ff 	pushm	r0-r7
800041da:	fa c7 ff c0 	sub	r7,sp,-64
800041de:	ee f0 ff f8 	ld.w	r0,r7[-8]
800041e2:	ef 40 ff e0 	st.w	r7[-32],r0
800041e6:	ee f0 ff fc 	ld.w	r0,r7[-4]
800041ea:	ef 40 ff e4 	st.w	r7[-28],r0
800041ee:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800041f2:	e0 68 00 f4 	mov	r8,244
800041f6:	ea 18 00 00 	orh	r8,0x0
800041fa:	70 00       	ld.w	r0,r8[0x0]
800041fc:	1a d0       	st.w	--sp,r0
800041fe:	f0 1f 00 1a 	mcall	80004264 <LABEL_RET_SCALL_266+0x14>
80004202:	e0 68 09 5c 	mov	r8,2396
80004206:	ea 18 00 00 	orh	r8,0x0
8000420a:	70 00       	ld.w	r0,r8[0x0]
8000420c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000420e:	f0 1f 00 17 	mcall	80004268 <LABEL_RET_SCALL_266+0x18>
	portRESTORE_CONTEXT_SCALL();
80004212:	e0 68 09 5c 	mov	r8,2396
80004216:	ea 18 00 00 	orh	r8,0x0
8000421a:	70 00       	ld.w	r0,r8[0x0]
8000421c:	60 0d       	ld.w	sp,r0[0x0]
8000421e:	1b 00       	ld.w	r0,sp++
80004220:	e0 68 00 f4 	mov	r8,244
80004224:	ea 18 00 00 	orh	r8,0x0
80004228:	91 00       	st.w	r8[0x0],r0
8000422a:	fa c7 ff d8 	sub	r7,sp,-40
8000422e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004232:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004236:	e0 61 00 f4 	mov	r1,244
8000423a:	ea 11 00 00 	orh	r1,0x0
8000423e:	62 02       	ld.w	r2,r1[0x0]
80004240:	58 02       	cp.w	r2,0
80004242:	c0 70       	breq	80004250 <LABEL_RET_SCALL_266>
80004244:	e4 c2 00 01 	sub	r2,r2,1
80004248:	83 02       	st.w	r1[0x0],r2
8000424a:	58 02       	cp.w	r2,0
8000424c:	c0 21       	brne	80004250 <LABEL_RET_SCALL_266>
8000424e:	b1 c0       	cbr	r0,0x10

80004250 <LABEL_RET_SCALL_266>:
80004250:	ef 40 ff f8 	st.w	r7[-8],r0
80004254:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004258:	ef 40 ff fc 	st.w	r7[-4],r0
8000425c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004260:	2f ad       	sub	sp,-24
80004262:	d6 13       	rets
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	41 6c       	lddsp	r12,sp[0x58]
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	43 ac       	lddsp	r12,sp[0xe8]

8000426c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
8000426c:	e1 b8 00 43 	mfsr	r8,0x10c
80004270:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004274:	5e fc       	retal	r12
80004276:	d7 03       	nop

80004278 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004278:	48 78       	lddpc	r8,80004294 <vPortExitCritical+0x1c>
8000427a:	70 08       	ld.w	r8,r8[0x0]
8000427c:	58 08       	cp.w	r8,0
8000427e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004280:	48 58       	lddpc	r8,80004294 <vPortExitCritical+0x1c>
80004282:	70 09       	ld.w	r9,r8[0x0]
80004284:	20 19       	sub	r9,1
80004286:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004288:	70 08       	ld.w	r8,r8[0x0]
8000428a:	58 08       	cp.w	r8,0
8000428c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000428e:	d5 03       	csrf	0x10
80004290:	5e fc       	retal	r12
80004292:	00 00       	add	r0,r0
80004294:	00 00       	add	r0,r0
80004296:	00 f4       	st.b	--r0,r4

80004298 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004298:	eb cd 00 ff 	pushm	r0-r7
8000429c:	e0 68 00 f4 	mov	r8,244
800042a0:	ea 18 00 00 	orh	r8,0x0
800042a4:	70 00       	ld.w	r0,r8[0x0]
800042a6:	1a d0       	st.w	--sp,r0
800042a8:	7a 90       	ld.w	r0,sp[0x24]
800042aa:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800042ae:	58 10       	cp.w	r0,1
800042b0:	e0 8b 00 08 	brhi	800042c0 <LABEL_INT_SKIP_SAVE_CONTEXT_240>
800042b4:	e0 68 09 5c 	mov	r8,2396
800042b8:	ea 18 00 00 	orh	r8,0x0
800042bc:	70 00       	ld.w	r0,r8[0x0]
800042be:	81 0d       	st.w	r0[0x0],sp

800042c0 <LABEL_INT_SKIP_SAVE_CONTEXT_240>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800042c0:	f0 1f 00 12 	mcall	80004308 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800042c4:	f0 1f 00 12 	mcall	8000430c <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
		vTaskIncrementTick();
800042c8:	f0 1f 00 12 	mcall	80004310 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x1c>
	portEXIT_CRITICAL();
800042cc:	f0 1f 00 12 	mcall	80004314 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800042d0:	7a 90       	ld.w	r0,sp[0x24]
800042d2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800042d6:	58 10       	cp.w	r0,1
800042d8:	e0 8b 00 0e 	brhi	800042f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>
800042dc:	f0 1f 00 0c 	mcall	8000430c <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
800042e0:	f0 1f 00 0e 	mcall	80004318 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x24>
800042e4:	f0 1f 00 0c 	mcall	80004314 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>
800042e8:	e0 68 09 5c 	mov	r8,2396
800042ec:	ea 18 00 00 	orh	r8,0x0
800042f0:	70 00       	ld.w	r0,r8[0x0]
800042f2:	60 0d       	ld.w	sp,r0[0x0]

800042f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>:
800042f4:	1b 00       	ld.w	r0,sp++
800042f6:	e0 68 00 f4 	mov	r8,244
800042fa:	ea 18 00 00 	orh	r8,0x0
800042fe:	91 00       	st.w	r8[0x0],r0
80004300:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004304:	d6 03       	rete
80004306:	00 00       	add	r0,r0
80004308:	80 00       	ld.sh	r0,r0[0x0]
8000430a:	42 6c       	lddsp	r12,sp[0x98]
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	41 6c       	lddsp	r12,sp[0x58]
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	44 28       	lddsp	r8,sp[0x108]
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	42 78       	lddsp	r8,sp[0x9c]
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	43 ac       	lddsp	r12,sp[0xe8]

8000431c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
8000431c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000431e:	f0 1f 00 02 	mcall	80004324 <__malloc_lock+0x8>
}
80004322:	d8 02       	popm	pc
80004324:	80 00       	ld.sh	r0,r0[0x0]
80004326:	43 9c       	lddsp	r12,sp[0xe4]

80004328 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004328:	d4 01       	pushm	lr
	xTaskResumeAll();
8000432a:	f0 1f 00 02 	mcall	80004330 <__malloc_unlock+0x8>
}
8000432e:	d8 02       	popm	pc
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	45 40       	lddsp	r0,sp[0x150]

80004334 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004334:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004336:	48 48       	lddpc	r8,80004344 <_init_startup+0x10>
80004338:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
8000433c:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
8000433e:	f0 1f 00 03 	mcall	80004348 <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
80004342:	da 0a       	popm	pc,r12=1
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	5c 00       	acr	r0
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	22 80       	sub	r0,40

8000434c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000434c:	eb cd 40 80 	pushm	r7,lr
80004350:	18 97       	mov	r7,r12
	if( pv )
80004352:	58 0c       	cp.w	r12,0
80004354:	c0 80       	breq	80004364 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004356:	f0 1f 00 05 	mcall	80004368 <vPortFree+0x1c>
		{
			free( pv );
8000435a:	0e 9c       	mov	r12,r7
8000435c:	f0 1f 00 04 	mcall	8000436c <vPortFree+0x20>
		}
		xTaskResumeAll();
80004360:	f0 1f 00 04 	mcall	80004370 <vPortFree+0x24>
80004364:	e3 cd 80 80 	ldm	sp++,r7,pc
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	43 9c       	lddsp	r12,sp[0xe4]
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	4b c8       	lddpc	r8,8000445c <vTaskIncrementTick+0x34>
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	45 40       	lddsp	r0,sp[0x150]

80004374 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004374:	eb cd 40 80 	pushm	r7,lr
80004378:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000437a:	f0 1f 00 06 	mcall	80004390 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000437e:	0e 9c       	mov	r12,r7
80004380:	f0 1f 00 05 	mcall	80004394 <pvPortMalloc+0x20>
80004384:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004386:	f0 1f 00 05 	mcall	80004398 <pvPortMalloc+0x24>
		}
	}
	#endif
	
	return pvReturn;
}
8000438a:	0e 9c       	mov	r12,r7
8000438c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	43 9c       	lddsp	r12,sp[0xe4]
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	4b e0       	lddpc	r0,8000448c <vTaskIncrementTick+0x64>
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	45 40       	lddsp	r0,sp[0x150]

8000439c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000439c:	48 38       	lddpc	r8,800043a8 <vTaskSuspendAll+0xc>
8000439e:	70 09       	ld.w	r9,r8[0x0]
800043a0:	2f f9       	sub	r9,-1
800043a2:	91 09       	st.w	r8[0x0],r9
}
800043a4:	5e fc       	retal	r12
800043a6:	00 00       	add	r0,r0
800043a8:	00 00       	add	r0,r0
800043aa:	09 8c       	ld.ub	r12,r4[0x0]

800043ac <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800043ac:	49 a8       	lddpc	r8,80004414 <vTaskSwitchContext+0x68>
800043ae:	70 08       	ld.w	r8,r8[0x0]
800043b0:	58 08       	cp.w	r8,0
800043b2:	c0 b1       	brne	800043c8 <vTaskSwitchContext+0x1c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043b4:	49 98       	lddpc	r8,80004418 <vTaskSwitchContext+0x6c>
800043b6:	70 08       	ld.w	r8,r8[0x0]
800043b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043bc:	49 89       	lddpc	r9,8000441c <vTaskSwitchContext+0x70>
800043be:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800043c2:	58 08       	cp.w	r8,0
800043c4:	c0 60       	breq	800043d0 <vTaskSwitchContext+0x24>
800043c6:	c1 18       	rjmp	800043e8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800043c8:	30 19       	mov	r9,1
800043ca:	49 68       	lddpc	r8,80004420 <vTaskSwitchContext+0x74>
800043cc:	91 09       	st.w	r8[0x0],r9
800043ce:	5e fc       	retal	r12
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800043d0:	49 28       	lddpc	r8,80004418 <vTaskSwitchContext+0x6c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043d2:	49 3a       	lddpc	r10,8000441c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800043d4:	70 09       	ld.w	r9,r8[0x0]
800043d6:	20 19       	sub	r9,1
800043d8:	91 09       	st.w	r8[0x0],r9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043da:	70 09       	ld.w	r9,r8[0x0]
800043dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800043e0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800043e4:	58 09       	cp.w	r9,0
800043e6:	cf 70       	breq	800043d4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800043e8:	48 c8       	lddpc	r8,80004418 <vTaskSwitchContext+0x6c>
800043ea:	70 08       	ld.w	r8,r8[0x0]
800043ec:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043f0:	48 b9       	lddpc	r9,8000441c <vTaskSwitchContext+0x70>
800043f2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800043f6:	70 19       	ld.w	r9,r8[0x4]
800043f8:	72 19       	ld.w	r9,r9[0x4]
800043fa:	91 19       	st.w	r8[0x4],r9
800043fc:	f0 ca ff f8 	sub	r10,r8,-8
80004400:	14 39       	cp.w	r9,r10
80004402:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80004406:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000440a:	70 18       	ld.w	r8,r8[0x4]
8000440c:	70 39       	ld.w	r9,r8[0xc]
8000440e:	48 68       	lddpc	r8,80004424 <vTaskSwitchContext+0x78>
80004410:	91 09       	st.w	r8[0x0],r9
80004412:	5e fc       	retal	r12
80004414:	00 00       	add	r0,r0
80004416:	09 8c       	ld.ub	r12,r4[0x0]
80004418:	00 00       	add	r0,r0
8000441a:	09 c4       	ld.ub	r4,r4[0x4]
8000441c:	00 00       	add	r0,r0
8000441e:	08 a8       	st.w	r4++,r8
80004420:	00 00       	add	r0,r0
80004422:	09 ac       	ld.ub	r12,r4[0x2]
80004424:	00 00       	add	r0,r0
80004426:	09 5c       	ld.sh	r12,--r4

80004428 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80004428:	eb cd 40 fe 	pushm	r1-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000442c:	4b a8       	lddpc	r8,80004514 <vTaskIncrementTick+0xec>
8000442e:	70 08       	ld.w	r8,r8[0x0]
80004430:	58 08       	cp.w	r8,0
80004432:	c6 a1       	brne	80004506 <vTaskIncrementTick+0xde>
	{
		++xTickCount;
80004434:	4b 98       	lddpc	r8,80004518 <vTaskIncrementTick+0xf0>
80004436:	70 09       	ld.w	r9,r8[0x0]
80004438:	2f f9       	sub	r9,-1
8000443a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000443c:	70 08       	ld.w	r8,r8[0x0]
8000443e:	58 08       	cp.w	r8,0
80004440:	c1 a1       	brne	80004474 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
80004442:	4b 78       	lddpc	r8,8000451c <vTaskIncrementTick+0xf4>
80004444:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80004446:	4b 79       	lddpc	r9,80004520 <vTaskIncrementTick+0xf8>
80004448:	72 0b       	ld.w	r11,r9[0x0]
8000444a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000444c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000444e:	4b 69       	lddpc	r9,80004524 <vTaskIncrementTick+0xfc>
80004450:	72 0a       	ld.w	r10,r9[0x0]
80004452:	2f fa       	sub	r10,-1
80004454:	93 0a       	st.w	r9[0x0],r10
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80004456:	70 08       	ld.w	r8,r8[0x0]
80004458:	70 08       	ld.w	r8,r8[0x0]
8000445a:	58 08       	cp.w	r8,0
8000445c:	c0 51       	brne	80004466 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000445e:	3f f9       	mov	r9,-1
80004460:	4b 28       	lddpc	r8,80004528 <vTaskIncrementTick+0x100>
80004462:	91 09       	st.w	r8[0x0],r9
80004464:	c0 88       	rjmp	80004474 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80004466:	4a e8       	lddpc	r8,8000451c <vTaskIncrementTick+0xf4>
80004468:	70 08       	ld.w	r8,r8[0x0]
8000446a:	70 38       	ld.w	r8,r8[0xc]
8000446c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000446e:	70 19       	ld.w	r9,r8[0x4]
80004470:	4a e8       	lddpc	r8,80004528 <vTaskIncrementTick+0x100>
80004472:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80004474:	4a 98       	lddpc	r8,80004518 <vTaskIncrementTick+0xf0>
80004476:	70 09       	ld.w	r9,r8[0x0]
80004478:	4a c8       	lddpc	r8,80004528 <vTaskIncrementTick+0x100>
8000447a:	70 08       	ld.w	r8,r8[0x0]
8000447c:	10 39       	cp.w	r9,r8
8000447e:	c4 83       	brcs	8000450e <vTaskIncrementTick+0xe6>
80004480:	4a 78       	lddpc	r8,8000451c <vTaskIncrementTick+0xf4>
80004482:	70 08       	ld.w	r8,r8[0x0]
80004484:	70 08       	ld.w	r8,r8[0x0]
80004486:	58 08       	cp.w	r8,0
80004488:	c0 c0       	breq	800044a0 <vTaskIncrementTick+0x78>
8000448a:	4a 58       	lddpc	r8,8000451c <vTaskIncrementTick+0xf4>
8000448c:	70 08       	ld.w	r8,r8[0x0]
8000448e:	70 38       	ld.w	r8,r8[0xc]
80004490:	70 37       	ld.w	r7,r8[0xc]
80004492:	6e 18       	ld.w	r8,r7[0x4]
80004494:	4a 19       	lddpc	r9,80004518 <vTaskIncrementTick+0xf0>
80004496:	72 09       	ld.w	r9,r9[0x0]
80004498:	12 38       	cp.w	r8,r9
8000449a:	e0 88 00 14 	brls	800044c2 <vTaskIncrementTick+0x9a>
8000449e:	c0 e8       	rjmp	800044ba <vTaskIncrementTick+0x92>
800044a0:	3f f9       	mov	r9,-1
800044a2:	4a 28       	lddpc	r8,80004528 <vTaskIncrementTick+0x100>
800044a4:	91 09       	st.w	r8[0x0],r9
800044a6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044aa:	6a 08       	ld.w	r8,r5[0x0]
800044ac:	70 38       	ld.w	r8,r8[0xc]
800044ae:	70 37       	ld.w	r7,r8[0xc]
800044b0:	6e 18       	ld.w	r8,r7[0x4]
800044b2:	64 09       	ld.w	r9,r2[0x0]
800044b4:	12 38       	cp.w	r8,r9
800044b6:	e0 88 00 0b 	brls	800044cc <vTaskIncrementTick+0xa4>
800044ba:	49 c9       	lddpc	r9,80004528 <vTaskIncrementTick+0x100>
800044bc:	93 08       	st.w	r9[0x0],r8
800044be:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800044c2:	49 b4       	lddpc	r4,8000452c <vTaskIncrementTick+0x104>
800044c4:	08 91       	mov	r1,r4
800044c6:	49 b3       	lddpc	r3,80004530 <vTaskIncrementTick+0x108>
800044c8:	49 55       	lddpc	r5,8000451c <vTaskIncrementTick+0xf4>
800044ca:	49 42       	lddpc	r2,80004518 <vTaskIncrementTick+0xf0>
800044cc:	ee c6 ff fc 	sub	r6,r7,-4
800044d0:	0c 9c       	mov	r12,r6
800044d2:	f0 1f 00 19 	mcall	80004534 <vTaskIncrementTick+0x10c>
800044d6:	6e a8       	ld.w	r8,r7[0x28]
800044d8:	58 08       	cp.w	r8,0
800044da:	c0 50       	breq	800044e4 <vTaskIncrementTick+0xbc>
800044dc:	ee cc ff e8 	sub	r12,r7,-24
800044e0:	f0 1f 00 15 	mcall	80004534 <vTaskIncrementTick+0x10c>
800044e4:	6e bc       	ld.w	r12,r7[0x2c]
800044e6:	68 08       	ld.w	r8,r4[0x0]
800044e8:	10 3c       	cp.w	r12,r8
800044ea:	e3 fc ba 00 	st.whi	r1[0x0],r12
800044ee:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800044f2:	0c 9b       	mov	r11,r6
800044f4:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800044f8:	f0 1f 00 10 	mcall	80004538 <vTaskIncrementTick+0x110>
800044fc:	6a 08       	ld.w	r8,r5[0x0]
800044fe:	70 08       	ld.w	r8,r8[0x0]
80004500:	58 08       	cp.w	r8,0
80004502:	cd 41       	brne	800044aa <vTaskIncrementTick+0x82>
80004504:	cc eb       	rjmp	800044a0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80004506:	48 e8       	lddpc	r8,8000453c <vTaskIncrementTick+0x114>
80004508:	70 09       	ld.w	r9,r8[0x0]
8000450a:	2f f9       	sub	r9,-1
8000450c:	91 09       	st.w	r8[0x0],r9
8000450e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004512:	00 00       	add	r0,r0
80004514:	00 00       	add	r0,r0
80004516:	09 8c       	ld.ub	r12,r4[0x0]
80004518:	00 00       	add	r0,r0
8000451a:	09 88       	ld.ub	r8,r4[0x0]
8000451c:	00 00       	add	r0,r0
8000451e:	08 94       	mov	r4,r4
80004520:	00 00       	add	r0,r0
80004522:	08 a4       	st.w	r4++,r4
80004524:	00 00       	add	r0,r0
80004526:	08 a0       	st.w	r4++,r0
80004528:	00 00       	add	r0,r0
8000452a:	00 f8       	st.b	--r0,r8
8000452c:	00 00       	add	r0,r0
8000452e:	09 c4       	ld.ub	r4,r4[0x4]
80004530:	00 00       	add	r0,r0
80004532:	08 a8       	st.w	r4++,r8
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	40 b2       	lddsp	r2,sp[0x2c]
80004538:	80 00       	ld.sh	r0,r0[0x0]
8000453a:	40 62       	lddsp	r2,sp[0x18]
8000453c:	00 00       	add	r0,r0
8000453e:	08 8c       	andn	r12,r4

80004540 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80004540:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80004542:	f0 1f 00 2c 	mcall	800045f0 <xTaskResumeAll+0xb0>
	{
		--uxSchedulerSuspended;
80004546:	4a c8       	lddpc	r8,800045f4 <xTaskResumeAll+0xb4>
80004548:	70 09       	ld.w	r9,r8[0x0]
8000454a:	20 19       	sub	r9,1
8000454c:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000454e:	70 08       	ld.w	r8,r8[0x0]
80004550:	58 08       	cp.w	r8,0
80004552:	c4 a1       	brne	800045e6 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80004554:	4a 98       	lddpc	r8,800045f8 <xTaskResumeAll+0xb8>
80004556:	70 08       	ld.w	r8,r8[0x0]
80004558:	58 08       	cp.w	r8,0
8000455a:	c4 60       	breq	800045e6 <xTaskResumeAll+0xa6>
8000455c:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000455e:	4a 85       	lddpc	r5,800045fc <xTaskResumeAll+0xbc>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80004560:	4a 83       	lddpc	r3,80004600 <xTaskResumeAll+0xc0>
80004562:	06 90       	mov	r0,r3
80004564:	4a 82       	lddpc	r2,80004604 <xTaskResumeAll+0xc4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004566:	4a 91       	lddpc	r1,80004608 <xTaskResumeAll+0xc8>
80004568:	c1 e8       	rjmp	800045a4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000456a:	6a 38       	ld.w	r8,r5[0xc]
8000456c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000456e:	ee cc ff e8 	sub	r12,r7,-24
80004572:	f0 1f 00 27 	mcall	8000460c <xTaskResumeAll+0xcc>
					vListRemove( &( pxTCB->xGenericListItem ) );
80004576:	ee c6 ff fc 	sub	r6,r7,-4
8000457a:	0c 9c       	mov	r12,r6
8000457c:	f0 1f 00 24 	mcall	8000460c <xTaskResumeAll+0xcc>
					prvAddTaskToReadyQueue( pxTCB );
80004580:	6e bc       	ld.w	r12,r7[0x2c]
80004582:	66 08       	ld.w	r8,r3[0x0]
80004584:	10 3c       	cp.w	r12,r8
80004586:	e1 fc ba 00 	st.whi	r0[0x0],r12
8000458a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000458e:	0c 9b       	mov	r11,r6
80004590:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80004594:	f0 1f 00 1f 	mcall	80004610 <xTaskResumeAll+0xd0>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80004598:	62 08       	ld.w	r8,r1[0x0]
8000459a:	6e b9       	ld.w	r9,r7[0x2c]
8000459c:	70 b8       	ld.w	r8,r8[0x2c]
8000459e:	10 39       	cp.w	r9,r8
800045a0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800045a4:	6a 08       	ld.w	r8,r5[0x0]
800045a6:	58 08       	cp.w	r8,0
800045a8:	ce 11       	brne	8000456a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800045aa:	49 b8       	lddpc	r8,80004614 <xTaskResumeAll+0xd4>
800045ac:	70 08       	ld.w	r8,r8[0x0]
800045ae:	58 08       	cp.w	r8,0
800045b0:	c0 f0       	breq	800045ce <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800045b2:	49 98       	lddpc	r8,80004614 <xTaskResumeAll+0xd4>
800045b4:	70 08       	ld.w	r8,r8[0x0]
800045b6:	58 08       	cp.w	r8,0
800045b8:	c1 10       	breq	800045da <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800045ba:	49 77       	lddpc	r7,80004614 <xTaskResumeAll+0xd4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800045bc:	f0 1f 00 17 	mcall	80004618 <xTaskResumeAll+0xd8>
						--uxMissedTicks;
800045c0:	6e 08       	ld.w	r8,r7[0x0]
800045c2:	20 18       	sub	r8,1
800045c4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800045c6:	6e 08       	ld.w	r8,r7[0x0]
800045c8:	58 08       	cp.w	r8,0
800045ca:	cf 91       	brne	800045bc <xTaskResumeAll+0x7c>
800045cc:	c0 78       	rjmp	800045da <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800045ce:	58 14       	cp.w	r4,1
800045d0:	c0 50       	breq	800045da <xTaskResumeAll+0x9a>
800045d2:	49 38       	lddpc	r8,8000461c <xTaskResumeAll+0xdc>
800045d4:	70 08       	ld.w	r8,r8[0x0]
800045d6:	58 18       	cp.w	r8,1
800045d8:	c0 71       	brne	800045e6 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800045da:	30 09       	mov	r9,0
800045dc:	49 08       	lddpc	r8,8000461c <xTaskResumeAll+0xdc>
800045de:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800045e0:	d7 33       	scall
800045e2:	30 17       	mov	r7,1
800045e4:	c0 28       	rjmp	800045e8 <xTaskResumeAll+0xa8>
800045e6:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800045e8:	f0 1f 00 0e 	mcall	80004620 <xTaskResumeAll+0xe0>

	return xAlreadyYielded;
}
800045ec:	0e 9c       	mov	r12,r7
800045ee:	d8 32       	popm	r0-r7,pc
800045f0:	80 00       	ld.sh	r0,r0[0x0]
800045f2:	41 6c       	lddsp	r12,sp[0x58]
800045f4:	00 00       	add	r0,r0
800045f6:	09 8c       	ld.ub	r12,r4[0x0]
800045f8:	00 00       	add	r0,r0
800045fa:	09 a8       	ld.ub	r8,r4[0x2]
800045fc:	00 00       	add	r0,r0
800045fe:	09 60       	ld.uh	r0,--r4
80004600:	00 00       	add	r0,r0
80004602:	09 c4       	ld.ub	r4,r4[0x4]
80004604:	00 00       	add	r0,r0
80004606:	08 a8       	st.w	r4++,r8
80004608:	00 00       	add	r0,r0
8000460a:	09 5c       	ld.sh	r12,--r4
8000460c:	80 00       	ld.sh	r0,r0[0x0]
8000460e:	40 b2       	lddsp	r2,sp[0x2c]
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	40 62       	lddsp	r2,sp[0x18]
80004614:	00 00       	add	r0,r0
80004616:	08 8c       	andn	r12,r4
80004618:	80 00       	ld.sh	r0,r0[0x0]
8000461a:	44 28       	lddsp	r8,sp[0x108]
8000461c:	00 00       	add	r0,r0
8000461e:	09 ac       	ld.ub	r12,r4[0x2]
80004620:	80 00       	ld.sh	r0,r0[0x0]
80004622:	42 78       	lddsp	r8,sp[0x9c]

80004624 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004624:	eb cd 40 80 	pushm	r7,lr
80004628:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000462a:	49 08       	lddpc	r8,80004668 <prvAddCurrentTaskToDelayedList+0x44>
8000462c:	70 08       	ld.w	r8,r8[0x0]
8000462e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80004630:	48 f8       	lddpc	r8,8000466c <prvAddCurrentTaskToDelayedList+0x48>
80004632:	70 08       	ld.w	r8,r8[0x0]
80004634:	10 3c       	cp.w	r12,r8
80004636:	c0 a2       	brcc	8000464a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004638:	48 c8       	lddpc	r8,80004668 <prvAddCurrentTaskToDelayedList+0x44>
8000463a:	70 0b       	ld.w	r11,r8[0x0]
8000463c:	48 d8       	lddpc	r8,80004670 <prvAddCurrentTaskToDelayedList+0x4c>
8000463e:	70 0c       	ld.w	r12,r8[0x0]
80004640:	2f cb       	sub	r11,-4
80004642:	f0 1f 00 0d 	mcall	80004674 <prvAddCurrentTaskToDelayedList+0x50>
80004646:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000464a:	48 88       	lddpc	r8,80004668 <prvAddCurrentTaskToDelayedList+0x44>
8000464c:	70 0b       	ld.w	r11,r8[0x0]
8000464e:	48 b8       	lddpc	r8,80004678 <prvAddCurrentTaskToDelayedList+0x54>
80004650:	70 0c       	ld.w	r12,r8[0x0]
80004652:	2f cb       	sub	r11,-4
80004654:	f0 1f 00 08 	mcall	80004674 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80004658:	48 98       	lddpc	r8,8000467c <prvAddCurrentTaskToDelayedList+0x58>
8000465a:	70 08       	ld.w	r8,r8[0x0]
8000465c:	10 37       	cp.w	r7,r8
8000465e:	c0 32       	brcc	80004664 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80004660:	48 78       	lddpc	r8,8000467c <prvAddCurrentTaskToDelayedList+0x58>
80004662:	91 07       	st.w	r8[0x0],r7
80004664:	e3 cd 80 80 	ldm	sp++,r7,pc
80004668:	00 00       	add	r0,r0
8000466a:	09 5c       	ld.sh	r12,--r4
8000466c:	00 00       	add	r0,r0
8000466e:	09 88       	ld.ub	r8,r4[0x0]
80004670:	00 00       	add	r0,r0
80004672:	08 a4       	st.w	r4++,r4
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	40 7e       	lddsp	lr,sp[0x1c]
80004678:	00 00       	add	r0,r0
8000467a:	08 94       	mov	r4,r4
8000467c:	00 00       	add	r0,r0
8000467e:	00 f8       	st.b	--r0,r8

80004680 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80004680:	eb cd 40 c0 	pushm	r6-r7,lr
80004684:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80004686:	58 0c       	cp.w	r12,0
80004688:	c1 10       	breq	800046aa <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000468a:	f0 1f 00 0a 	mcall	800046b0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000468e:	48 a8       	lddpc	r8,800046b4 <vTaskDelay+0x34>
80004690:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004692:	48 a8       	lddpc	r8,800046b8 <vTaskDelay+0x38>
80004694:	70 0c       	ld.w	r12,r8[0x0]
80004696:	2f cc       	sub	r12,-4
80004698:	f0 1f 00 09 	mcall	800046bc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000469c:	ee 06 00 0c 	add	r12,r7,r6
800046a0:	f0 1f 00 08 	mcall	800046c0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800046a4:	f0 1f 00 08 	mcall	800046c4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800046a8:	c0 21       	brne	800046ac <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800046aa:	d7 33       	scall
800046ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046b0:	80 00       	ld.sh	r0,r0[0x0]
800046b2:	43 9c       	lddsp	r12,sp[0xe4]
800046b4:	00 00       	add	r0,r0
800046b6:	09 88       	ld.ub	r8,r4[0x0]
800046b8:	00 00       	add	r0,r0
800046ba:	09 5c       	ld.sh	r12,--r4
800046bc:	80 00       	ld.sh	r0,r0[0x0]
800046be:	40 b2       	lddsp	r2,sp[0x2c]
800046c0:	80 00       	ld.sh	r0,r0[0x0]
800046c2:	46 24       	lddsp	r4,sp[0x188]
800046c4:	80 00       	ld.sh	r0,r0[0x0]
800046c6:	45 40       	lddsp	r0,sp[0x150]

800046c8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800046c8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800046cc:	49 57       	lddpc	r7,80004720 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800046ce:	49 64       	lddpc	r4,80004724 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800046d0:	49 63       	lddpc	r3,80004728 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800046d2:	49 75       	lddpc	r5,8000472c <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800046d4:	6e 08       	ld.w	r8,r7[0x0]
800046d6:	58 08       	cp.w	r8,0
800046d8:	c1 e0       	breq	80004714 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800046da:	f0 1f 00 16 	mcall	80004730 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800046de:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800046e0:	f0 1f 00 15 	mcall	80004734 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
800046e4:	58 06       	cp.w	r6,0
800046e6:	c1 70       	breq	80004714 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800046e8:	f0 1f 00 14 	mcall	80004738 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800046ec:	68 38       	ld.w	r8,r4[0xc]
800046ee:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800046f0:	ec cc ff fc 	sub	r12,r6,-4
800046f4:	f0 1f 00 12 	mcall	8000473c <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
800046f8:	66 08       	ld.w	r8,r3[0x0]
800046fa:	20 18       	sub	r8,1
800046fc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800046fe:	6e 08       	ld.w	r8,r7[0x0]
80004700:	20 18       	sub	r8,1
80004702:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80004704:	f0 1f 00 0f 	mcall	80004740 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80004708:	6c cc       	ld.w	r12,r6[0x30]
8000470a:	f0 1f 00 0f 	mcall	80004744 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
8000470e:	0c 9c       	mov	r12,r6
80004710:	f0 1f 00 0d 	mcall	80004744 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80004714:	6a 08       	ld.w	r8,r5[0x0]
80004716:	58 18       	cp.w	r8,1
80004718:	fe 98 ff de 	brls	800046d4 <prvIdleTask+0xc>
			{
				taskYIELD();
8000471c:	d7 33       	scall
8000471e:	cd bb       	rjmp	800046d4 <prvIdleTask+0xc>
80004720:	00 00       	add	r0,r0
80004722:	08 9c       	mov	r12,r4
80004724:	00 00       	add	r0,r0
80004726:	09 48       	ld.w	r8,--r4
80004728:	00 00       	add	r0,r0
8000472a:	09 a8       	ld.ub	r8,r4[0x2]
8000472c:	00 00       	add	r0,r0
8000472e:	08 a8       	st.w	r4++,r8
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	43 9c       	lddsp	r12,sp[0xe4]
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	45 40       	lddsp	r0,sp[0x150]
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	41 6c       	lddsp	r12,sp[0x58]
8000473c:	80 00       	ld.sh	r0,r0[0x0]
8000473e:	40 b2       	lddsp	r2,sp[0x2c]
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	42 78       	lddsp	r8,sp[0x9c]
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	43 4c       	lddsp	r12,sp[0xd0]

80004748 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004748:	d4 31       	pushm	r0-r7,lr
8000474a:	20 1d       	sub	sp,4
8000474c:	fa c4 ff d8 	sub	r4,sp,-40
80004750:	50 0c       	stdsp	sp[0x0],r12
80004752:	16 91       	mov	r1,r11
80004754:	14 97       	mov	r7,r10
80004756:	12 90       	mov	r0,r9
80004758:	10 93       	mov	r3,r8
8000475a:	68 02       	ld.w	r2,r4[0x0]
8000475c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000475e:	34 4c       	mov	r12,68
80004760:	f0 1f 00 5b 	mcall	800048cc <xTaskGenericCreate+0x184>
80004764:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004766:	c0 31       	brne	8000476c <xTaskGenericCreate+0x24>
80004768:	3f fc       	mov	r12,-1
8000476a:	ca d8       	rjmp	800048c4 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000476c:	58 06       	cp.w	r6,0
8000476e:	e0 81 00 ad 	brne	800048c8 <xTaskGenericCreate+0x180>
80004772:	0e 9c       	mov	r12,r7
80004774:	5c 7c       	castu.h	r12
80004776:	a3 6c       	lsl	r12,0x2
80004778:	f0 1f 00 55 	mcall	800048cc <xTaskGenericCreate+0x184>
8000477c:	18 96       	mov	r6,r12
8000477e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004780:	c0 61       	brne	8000478c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004782:	0a 9c       	mov	r12,r5
80004784:	f0 1f 00 53 	mcall	800048d0 <xTaskGenericCreate+0x188>
80004788:	3f fc       	mov	r12,-1
8000478a:	c9 d8       	rjmp	800048c4 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000478c:	5c 77       	castu.h	r7
8000478e:	ee 0a 15 02 	lsl	r10,r7,0x2
80004792:	e0 6b 00 a5 	mov	r11,165
80004796:	0c 9c       	mov	r12,r6
80004798:	f0 1f 00 4f 	mcall	800048d4 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000479c:	ee c6 00 01 	sub	r6,r7,1
800047a0:	6a c8       	ld.w	r8,r5[0x30]
800047a2:	f0 06 00 26 	add	r6,r8,r6<<0x2
800047a6:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800047aa:	31 0a       	mov	r10,16
800047ac:	02 9b       	mov	r11,r1
800047ae:	ea cc ff cc 	sub	r12,r5,-52
800047b2:	f0 1f 00 4a 	mcall	800048d8 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800047b6:	30 08       	mov	r8,0
800047b8:	eb 68 00 43 	st.b	r5[67],r8
800047bc:	58 73       	cp.w	r3,7
800047be:	e6 07 17 80 	movls	r7,r3
800047c2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800047c6:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800047c8:	ea c4 ff fc 	sub	r4,r5,-4
800047cc:	08 9c       	mov	r12,r4
800047ce:	f0 1f 00 44 	mcall	800048dc <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800047d2:	ea cc ff e8 	sub	r12,r5,-24
800047d6:	f0 1f 00 42 	mcall	800048dc <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800047da:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800047dc:	ee 07 11 08 	rsub	r7,r7,8
800047e0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800047e2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800047e4:	00 9a       	mov	r10,r0
800047e6:	40 0b       	lddsp	r11,sp[0x0]
800047e8:	0c 9c       	mov	r12,r6
800047ea:	f0 1f 00 3e 	mcall	800048e0 <xTaskGenericCreate+0x198>
800047ee:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800047f0:	58 02       	cp.w	r2,0
800047f2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800047f6:	f0 1f 00 3c 	mcall	800048e4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
800047fa:	4b c8       	lddpc	r8,800048e8 <xTaskGenericCreate+0x1a0>
800047fc:	70 09       	ld.w	r9,r8[0x0]
800047fe:	2f f9       	sub	r9,-1
80004800:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80004802:	4b b8       	lddpc	r8,800048ec <xTaskGenericCreate+0x1a4>
80004804:	70 08       	ld.w	r8,r8[0x0]
80004806:	58 08       	cp.w	r8,0
80004808:	c2 61       	brne	80004854 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000480a:	4b 98       	lddpc	r8,800048ec <xTaskGenericCreate+0x1a4>
8000480c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000480e:	4b 78       	lddpc	r8,800048e8 <xTaskGenericCreate+0x1a0>
80004810:	70 08       	ld.w	r8,r8[0x0]
80004812:	58 18       	cp.w	r8,1
80004814:	c2 b1       	brne	8000486a <xTaskGenericCreate+0x122>
80004816:	4b 77       	lddpc	r7,800048f0 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80004818:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000481c:	0e 9c       	mov	r12,r7
8000481e:	f0 1f 00 36 	mcall	800048f4 <xTaskGenericCreate+0x1ac>
80004822:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004824:	0c 37       	cp.w	r7,r6
80004826:	cf b1       	brne	8000481c <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004828:	4b 47       	lddpc	r7,800048f8 <xTaskGenericCreate+0x1b0>
8000482a:	0e 9c       	mov	r12,r7
8000482c:	f0 1f 00 32 	mcall	800048f4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004830:	4b 36       	lddpc	r6,800048fc <xTaskGenericCreate+0x1b4>
80004832:	0c 9c       	mov	r12,r6
80004834:	f0 1f 00 30 	mcall	800048f4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004838:	4b 2c       	lddpc	r12,80004900 <xTaskGenericCreate+0x1b8>
8000483a:	f0 1f 00 2f 	mcall	800048f4 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000483e:	4b 2c       	lddpc	r12,80004904 <xTaskGenericCreate+0x1bc>
80004840:	f0 1f 00 2d 	mcall	800048f4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004844:	4b 1c       	lddpc	r12,80004908 <xTaskGenericCreate+0x1c0>
80004846:	f0 1f 00 2c 	mcall	800048f4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000484a:	4b 18       	lddpc	r8,8000490c <xTaskGenericCreate+0x1c4>
8000484c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000484e:	4b 18       	lddpc	r8,80004910 <xTaskGenericCreate+0x1c8>
80004850:	91 06       	st.w	r8[0x0],r6
80004852:	c0 c8       	rjmp	8000486a <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004854:	4b 08       	lddpc	r8,80004914 <xTaskGenericCreate+0x1cc>
80004856:	70 08       	ld.w	r8,r8[0x0]
80004858:	58 08       	cp.w	r8,0
8000485a:	c0 81       	brne	8000486a <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000485c:	4a 48       	lddpc	r8,800048ec <xTaskGenericCreate+0x1a4>
8000485e:	70 08       	ld.w	r8,r8[0x0]
80004860:	70 b8       	ld.w	r8,r8[0x2c]
80004862:	10 33       	cp.w	r3,r8
80004864:	c0 33       	brcs	8000486a <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004866:	4a 28       	lddpc	r8,800048ec <xTaskGenericCreate+0x1a4>
80004868:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000486a:	6a b8       	ld.w	r8,r5[0x2c]
8000486c:	4a b9       	lddpc	r9,80004918 <xTaskGenericCreate+0x1d0>
8000486e:	72 09       	ld.w	r9,r9[0x0]
80004870:	12 38       	cp.w	r8,r9
80004872:	e0 88 00 04 	brls	8000487a <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004876:	4a 99       	lddpc	r9,80004918 <xTaskGenericCreate+0x1d0>
80004878:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000487a:	4a 98       	lddpc	r8,8000491c <xTaskGenericCreate+0x1d4>
8000487c:	70 09       	ld.w	r9,r8[0x0]
8000487e:	2f f9       	sub	r9,-1
80004880:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004882:	6a b8       	ld.w	r8,r5[0x2c]
80004884:	4a 79       	lddpc	r9,80004920 <xTaskGenericCreate+0x1d8>
80004886:	72 09       	ld.w	r9,r9[0x0]
80004888:	12 38       	cp.w	r8,r9
8000488a:	e0 88 00 04 	brls	80004892 <xTaskGenericCreate+0x14a>
8000488e:	4a 59       	lddpc	r9,80004920 <xTaskGenericCreate+0x1d8>
80004890:	93 08       	st.w	r9[0x0],r8
80004892:	6a bc       	ld.w	r12,r5[0x2c]
80004894:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004898:	08 9b       	mov	r11,r4
8000489a:	49 68       	lddpc	r8,800048f0 <xTaskGenericCreate+0x1a8>
8000489c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800048a0:	f0 1f 00 21 	mcall	80004924 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800048a4:	f0 1f 00 21 	mcall	80004928 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800048a8:	49 b8       	lddpc	r8,80004914 <xTaskGenericCreate+0x1cc>
800048aa:	70 08       	ld.w	r8,r8[0x0]
800048ac:	58 08       	cp.w	r8,0
800048ae:	c0 a0       	breq	800048c2 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800048b0:	48 f8       	lddpc	r8,800048ec <xTaskGenericCreate+0x1a4>
800048b2:	70 08       	ld.w	r8,r8[0x0]
800048b4:	70 b8       	ld.w	r8,r8[0x2c]
800048b6:	10 33       	cp.w	r3,r8
800048b8:	e0 88 00 05 	brls	800048c2 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
800048bc:	d7 33       	scall
800048be:	30 1c       	mov	r12,1
800048c0:	c0 28       	rjmp	800048c4 <xTaskGenericCreate+0x17c>
800048c2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800048c4:	2f fd       	sub	sp,-4
800048c6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800048c8:	99 c6       	st.w	r12[0x30],r6
800048ca:	c6 1b       	rjmp	8000478c <xTaskGenericCreate+0x44>
800048cc:	80 00       	ld.sh	r0,r0[0x0]
800048ce:	43 74       	lddsp	r4,sp[0xdc]
800048d0:	80 00       	ld.sh	r0,r0[0x0]
800048d2:	43 4c       	lddsp	r12,sp[0xd0]
800048d4:	80 00       	ld.sh	r0,r0[0x0]
800048d6:	50 48       	stdsp	sp[0x10],r8
800048d8:	80 00       	ld.sh	r0,r0[0x0]
800048da:	51 bc       	stdsp	sp[0x6c],r12
800048dc:	80 00       	ld.sh	r0,r0[0x0]
800048de:	40 5c       	lddsp	r12,sp[0x14]
800048e0:	80 00       	ld.sh	r0,r0[0x0]
800048e2:	40 d8       	lddsp	r8,sp[0x34]
800048e4:	80 00       	ld.sh	r0,r0[0x0]
800048e6:	41 6c       	lddsp	r12,sp[0x58]
800048e8:	00 00       	add	r0,r0
800048ea:	09 a8       	ld.ub	r8,r4[0x2]
800048ec:	00 00       	add	r0,r0
800048ee:	09 5c       	ld.sh	r12,--r4
800048f0:	00 00       	add	r0,r0
800048f2:	08 a8       	st.w	r4++,r8
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	40 48       	lddsp	r8,sp[0x10]
800048f8:	00 00       	add	r0,r0
800048fa:	09 74       	ld.ub	r4,--r4
800048fc:	00 00       	add	r0,r0
800048fe:	09 90       	ld.ub	r0,r4[0x1]
80004900:	00 00       	add	r0,r0
80004902:	09 60       	ld.uh	r0,--r4
80004904:	00 00       	add	r0,r0
80004906:	09 48       	ld.w	r8,--r4
80004908:	00 00       	add	r0,r0
8000490a:	09 b0       	ld.ub	r0,r4[0x3]
8000490c:	00 00       	add	r0,r0
8000490e:	08 94       	mov	r4,r4
80004910:	00 00       	add	r0,r0
80004912:	08 a4       	st.w	r4++,r4
80004914:	00 00       	add	r0,r0
80004916:	08 98       	mov	r8,r4
80004918:	00 00       	add	r0,r0
8000491a:	08 90       	mov	r0,r4
8000491c:	00 00       	add	r0,r0
8000491e:	09 a4       	ld.ub	r4,r4[0x2]
80004920:	00 00       	add	r0,r0
80004922:	09 c4       	ld.ub	r4,r4[0x4]
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	40 62       	lddsp	r2,sp[0x18]
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	42 78       	lddsp	r8,sp[0x9c]

8000492c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000492c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000492e:	30 09       	mov	r9,0
80004930:	1a d9       	st.w	--sp,r9
80004932:	1a d9       	st.w	--sp,r9
80004934:	1a d9       	st.w	--sp,r9
80004936:	12 98       	mov	r8,r9
80004938:	e0 6a 01 00 	mov	r10,256
8000493c:	48 9b       	lddpc	r11,80004960 <vTaskStartScheduler+0x34>
8000493e:	48 ac       	lddpc	r12,80004964 <vTaskStartScheduler+0x38>
80004940:	f0 1f 00 0a 	mcall	80004968 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80004944:	2f dd       	sub	sp,-12
80004946:	58 1c       	cp.w	r12,1
80004948:	c0 a1       	brne	8000495c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000494a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000494c:	30 19       	mov	r9,1
8000494e:	48 88       	lddpc	r8,8000496c <vTaskStartScheduler+0x40>
80004950:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80004952:	30 09       	mov	r9,0
80004954:	48 78       	lddpc	r8,80004970 <vTaskStartScheduler+0x44>
80004956:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80004958:	f0 1f 00 07 	mcall	80004974 <vTaskStartScheduler+0x48>
8000495c:	d8 02       	popm	pc
8000495e:	00 00       	add	r0,r0
80004960:	80 00       	ld.sh	r0,r0[0x0]
80004962:	5f 08       	sreq	r8
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	46 c8       	lddsp	r8,sp[0x1b0]
80004968:	80 00       	ld.sh	r0,r0[0x0]
8000496a:	47 48       	lddsp	r8,sp[0x1d0]
8000496c:	00 00       	add	r0,r0
8000496e:	08 98       	mov	r8,r4
80004970:	00 00       	add	r0,r0
80004972:	09 88       	ld.ub	r8,r4[0x0]
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	41 7c       	lddsp	r12,sp[0x5c]

80004978 <busy_delay_ms>:
#define TEST_C      AVR32_PIN_PA27
#define RESPONSE_C  AVR32_PIN_PB00


void busy_delay_ms(int delay){
    for(; delay != 0; delay--){
80004978:	58 0c       	cp.w	r12,0
8000497a:	c0 91       	brne	8000498c <busy_delay_ms+0x14>
8000497c:	5e fc       	retal	r12
        for(int i = 0; i < 2108; i++){
8000497e:	2f f8       	sub	r8,-1
80004980:	e0 48 08 3c 	cp.w	r8,2108
80004984:	cf d1       	brne	8000497e <busy_delay_ms+0x6>
#define TEST_C      AVR32_PIN_PA27
#define RESPONSE_C  AVR32_PIN_PB00


void busy_delay_ms(int delay){
    for(; delay != 0; delay--){
80004986:	20 1c       	sub	r12,1
80004988:	c0 31       	brne	8000498e <busy_delay_ms+0x16>
8000498a:	5e fc       	retal	r12
8000498c:	30 09       	mov	r9,0
8000498e:	12 98       	mov	r8,r9
80004990:	cf 7b       	rjmp	8000497e <busy_delay_ms+0x6>
80004992:	d7 03       	nop

80004994 <responseTask>:
		uint32_t test;
		uint32_t response;
	} pin;
	uint16_t busy_time_ms;
};
static void responseTask(void* args){
80004994:	eb cd 40 f8 	pushm	r3-r7,lr
	struct responseTaskArgs a = *(struct responseTaskArgs*)args;
80004998:	78 16       	ld.w	r6,r12[0x4]
8000499a:	78 07       	ld.w	r7,r12[0x0]
			busy_delay_ms(a.busy_time_ms);
			gpio_set_pin_low(a.pin.response);
		} else {
			//busy_delay_ms(a.busy_time_ms);
			gpio_set_pin_high(a.pin.response);
			vTaskDelay(1);
8000499c:	30 14       	mov	r4,1
};
static void responseTask(void* args){
	struct responseTaskArgs a = *(struct responseTaskArgs*)args;
	while(1){
		if(gpio_pin_is_low(a.pin.test)){
			busy_delay_ms(a.busy_time_ms);
8000499e:	98 c3       	ld.uh	r3,r12[0x8]
		} else {
			//busy_delay_ms(a.busy_time_ms);
			gpio_set_pin_high(a.pin.response);
			vTaskDelay(1);
		}
		vTaskDelay(0);
800049a0:	30 05       	mov	r5,0
	uint16_t busy_time_ms;
};
static void responseTask(void* args){
	struct responseTaskArgs a = *(struct responseTaskArgs*)args;
	while(1){
		if(gpio_pin_is_low(a.pin.test)){
800049a2:	0e 9c       	mov	r12,r7
800049a4:	f0 1f 00 0a 	mcall	800049cc <responseTask+0x38>
800049a8:	c0 81       	brne	800049b8 <responseTask+0x24>
			busy_delay_ms(a.busy_time_ms);
800049aa:	06 9c       	mov	r12,r3
800049ac:	f0 1f 00 09 	mcall	800049d0 <responseTask+0x3c>
			gpio_set_pin_low(a.pin.response);
800049b0:	0c 9c       	mov	r12,r6
800049b2:	f0 1f 00 09 	mcall	800049d4 <responseTask+0x40>
800049b6:	c0 78       	rjmp	800049c4 <responseTask+0x30>
		} else {
			//busy_delay_ms(a.busy_time_ms);
			gpio_set_pin_high(a.pin.response);
800049b8:	0c 9c       	mov	r12,r6
800049ba:	f0 1f 00 08 	mcall	800049d8 <responseTask+0x44>
			vTaskDelay(1);
800049be:	08 9c       	mov	r12,r4
800049c0:	f0 1f 00 07 	mcall	800049dc <responseTask+0x48>
		}
		vTaskDelay(0);
800049c4:	0a 9c       	mov	r12,r5
800049c6:	f0 1f 00 06 	mcall	800049dc <responseTask+0x48>
	}
800049ca:	ce cb       	rjmp	800049a2 <responseTask+0xe>
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	21 f4       	sub	r4,31
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	49 78       	lddpc	r8,80004a2c <init+0xc>
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	22 20       	sub	r0,34
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	22 0a       	sub	r10,32
800049dc:	80 00       	ld.sh	r0,r0[0x0]
800049de:	46 80       	lddsp	r0,sp[0x1a0]

800049e0 <led1_toggle_200ms>:
		
		vTaskDelay(delay);
	}
}

static void led1_toggle_200ms(void* args){
800049e0:	eb cd 40 c0 	pushm	r6-r7,lr
	const portTickType delay = 200 / portTICK_RATE_MS;
	
	int iter = 0;

	while(1){
		gpio_toggle_pin(LED1_GPIO);
800049e4:	34 96       	mov	r6,73
		//printf("tick %d\n", iter++);
		
		vTaskDelay(delay);
800049e6:	e0 67 00 c8 	mov	r7,200
	const portTickType delay = 200 / portTICK_RATE_MS;
	
	int iter = 0;

	while(1){
		gpio_toggle_pin(LED1_GPIO);
800049ea:	0c 9c       	mov	r12,r6
800049ec:	f0 1f 00 03 	mcall	800049f8 <led1_toggle_200ms+0x18>
		//printf("tick %d\n", iter++);
		
		vTaskDelay(delay);
800049f0:	0e 9c       	mov	r12,r7
800049f2:	f0 1f 00 03 	mcall	800049fc <led1_toggle_200ms+0x1c>
800049f6:	cf ab       	rjmp	800049ea <led1_toggle_200ms+0xa>
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	22 36       	sub	r6,35
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	46 80       	lddsp	r0,sp[0x1a0]

80004a00 <led0_toggle_500ms>:
	    setbuf(stdout, NULL);
	    setbuf(stdin,  NULL);
    #endif
}

static void led0_toggle_500ms(void* args){
80004a00:	eb cd 40 c0 	pushm	r6-r7,lr
	const portTickType delay = 500 / portTICK_RATE_MS;
	
    int iter = 0;

	while(1){
		gpio_toggle_pin(LED0_GPIO);
80004a04:	32 36       	mov	r6,35
		//printf("tick %d\n", iter++);
		
		vTaskDelay(delay);
80004a06:	e0 67 01 f4 	mov	r7,500
	const portTickType delay = 500 / portTICK_RATE_MS;
	
    int iter = 0;

	while(1){
		gpio_toggle_pin(LED0_GPIO);
80004a0a:	0c 9c       	mov	r12,r6
80004a0c:	f0 1f 00 03 	mcall	80004a18 <led0_toggle_500ms+0x18>
		//printf("tick %d\n", iter++);
		
		vTaskDelay(delay);
80004a10:	0e 9c       	mov	r12,r7
80004a12:	f0 1f 00 03 	mcall	80004a1c <led0_toggle_500ms+0x1c>
80004a16:	cf ab       	rjmp	80004a0a <led0_toggle_500ms+0xa>
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	22 36       	sub	r6,35
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	46 80       	lddsp	r0,sp[0x1a0]

80004a20 <init>:
    for(int i = 0; i < 10; i++){
        asm volatile ("" ::: "memory");
    }
}

void init(){
80004a20:	eb cd 40 80 	pushm	r7,lr
	board_init();
80004a24:	f0 1f 00 1a 	mcall	80004a8c <init+0x6c>
	
    gpio_configure_pin(TEST_A, GPIO_DIR_INPUT);
80004a28:	30 0b       	mov	r11,0
80004a2a:	31 fc       	mov	r12,31
80004a2c:	f0 1f 00 19 	mcall	80004a90 <init+0x70>
    gpio_configure_pin(TEST_B, GPIO_DIR_INPUT);
80004a30:	30 0b       	mov	r11,0
80004a32:	31 dc       	mov	r12,29
80004a34:	f0 1f 00 17 	mcall	80004a90 <init+0x70>
    gpio_configure_pin(TEST_C, GPIO_DIR_INPUT);
80004a38:	30 0b       	mov	r11,0
80004a3a:	31 bc       	mov	r12,27
80004a3c:	f0 1f 00 15 	mcall	80004a90 <init+0x70>
    gpio_configure_pin(RESPONSE_A, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004a40:	30 3b       	mov	r11,3
80004a42:	31 ec       	mov	r12,30
80004a44:	f0 1f 00 13 	mcall	80004a90 <init+0x70>
    gpio_configure_pin(RESPONSE_B, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004a48:	30 3b       	mov	r11,3
80004a4a:	31 cc       	mov	r12,28
80004a4c:	f0 1f 00 11 	mcall	80004a90 <init+0x70>
    gpio_configure_pin(RESPONSE_C, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004a50:	30 3b       	mov	r11,3
80004a52:	32 0c       	mov	r12,32
80004a54:	f0 1f 00 0f 	mcall	80004a90 <init+0x70>

	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
80004a58:	30 3a       	mov	r10,3
80004a5a:	e0 6b 1b 00 	mov	r11,6912
80004a5e:	ea 1b 00 b7 	orh	r11,0xb7
80004a62:	30 0c       	mov	r12,0
80004a64:	f0 1f 00 0c 	mcall	80004a94 <init+0x74>
	
	stdio_usb_init(&CONFIG_USART_IF);
80004a68:	fe 7c 1c 00 	mov	r12,-58368
80004a6c:	f0 1f 00 0b 	mcall	80004a98 <init+0x78>

    #if defined(__GNUC__) && defined(__AVR32__)
	    setbuf(stdout, NULL);
80004a70:	48 b7       	lddpc	r7,80004a9c <init+0x7c>
80004a72:	6e 08       	ld.w	r8,r7[0x0]
80004a74:	30 0b       	mov	r11,0
80004a76:	70 1c       	ld.w	r12,r8[0x4]
80004a78:	f0 1f 00 0a 	mcall	80004aa0 <init+0x80>
	    setbuf(stdin,  NULL);
80004a7c:	6e 08       	ld.w	r8,r7[0x0]
80004a7e:	30 0b       	mov	r11,0
80004a80:	70 0c       	ld.w	r12,r8[0x0]
80004a82:	f0 1f 00 08 	mcall	80004aa0 <init+0x80>
    #endif
}
80004a86:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a8a:	00 00       	add	r0,r0
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	21 0c       	sub	r12,16
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	21 3c       	sub	r12,19
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	23 c4       	sub	r4,60
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	3f 70       	mov	r0,-9
80004a9c:	00 00       	add	r0,r0
80004a9e:	01 ec       	ld.ub	r12,r0[0x6]
80004aa0:	80 00       	ld.sh	r0,r0[0x0]
80004aa2:	50 80       	stdsp	sp[0x20],r0

80004aa4 <main>:
		vTaskDelay(0);
	}
}


int main(){
80004aa4:	eb cd 40 e0 	pushm	r5-r7,lr
80004aa8:	20 9d       	sub	sp,36
	init();
80004aaa:	f0 1f 00 2f 	mcall	80004b64 <main+0xc0>
        
	xTaskCreate(led0_toggle_500ms, "", 1024, NULL, tskIDLE_PRIORITY + 1, NULL);
80004aae:	4a f6       	lddpc	r6,80004b68 <main+0xc4>
80004ab0:	30 07       	mov	r7,0
80004ab2:	1a d7       	st.w	--sp,r7
80004ab4:	1a d7       	st.w	--sp,r7
80004ab6:	1a d7       	st.w	--sp,r7
80004ab8:	30 18       	mov	r8,1
80004aba:	0e 99       	mov	r9,r7
80004abc:	e0 6a 04 00 	mov	r10,1024
80004ac0:	0c 9b       	mov	r11,r6
80004ac2:	4a bc       	lddpc	r12,80004b6c <main+0xc8>
80004ac4:	f0 1f 00 2b 	mcall	80004b70 <main+0xcc>
	xTaskCreate(led1_toggle_200ms, "", 1024, NULL, tskIDLE_PRIORITY + 1, NULL);
80004ac8:	1a d7       	st.w	--sp,r7
80004aca:	1a d7       	st.w	--sp,r7
80004acc:	1a d7       	st.w	--sp,r7
80004ace:	30 18       	mov	r8,1
80004ad0:	0e 99       	mov	r9,r7
80004ad2:	e0 6a 04 00 	mov	r10,1024
80004ad6:	0c 9b       	mov	r11,r6
80004ad8:	4a 7c       	lddpc	r12,80004b74 <main+0xd0>
80004ada:	f0 1f 00 26 	mcall	80004b70 <main+0xcc>
	
	xTaskCreate(responseTask, "", 1024,
80004ade:	4a 78       	lddpc	r8,80004b78 <main+0xd4>
80004ae0:	fa c9 ff e8 	sub	r9,sp,-24
80004ae4:	f0 ea 00 00 	ld.d	r10,r8[0]
80004ae8:	f2 eb 00 00 	st.d	r9[0],r10
80004aec:	70 28       	ld.w	r8,r8[0x8]
80004aee:	93 28       	st.w	r9[0x8],r8
80004af0:	4a 35       	lddpc	r5,80004b7c <main+0xd8>
80004af2:	1a d7       	st.w	--sp,r7
80004af4:	1a d7       	st.w	--sp,r7
80004af6:	1a d7       	st.w	--sp,r7
80004af8:	30 28       	mov	r8,2
80004afa:	e0 6a 04 00 	mov	r10,1024
80004afe:	0c 9b       	mov	r11,r6
80004b00:	0a 9c       	mov	r12,r5
80004b02:	f0 1f 00 1c 	mcall	80004b70 <main+0xcc>
		(&(struct responseTaskArgs){{TEST_A, RESPONSE_A}, 0}),
		tskIDLE_PRIORITY + 2, NULL);
	xTaskCreate(responseTask, "", 1024,
80004b06:	49 f8       	lddpc	r8,80004b80 <main+0xdc>
80004b08:	fa c9 ff d0 	sub	r9,sp,-48
80004b0c:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b10:	f2 eb 00 00 	st.d	r9[0],r10
80004b14:	70 28       	ld.w	r8,r8[0x8]
80004b16:	93 28       	st.w	r9[0x8],r8
80004b18:	2f 7d       	sub	sp,-36
80004b1a:	1a d7       	st.w	--sp,r7
80004b1c:	1a d7       	st.w	--sp,r7
80004b1e:	1a d7       	st.w	--sp,r7
80004b20:	30 28       	mov	r8,2
80004b22:	e0 6a 04 00 	mov	r10,1024
80004b26:	0c 9b       	mov	r11,r6
80004b28:	0a 9c       	mov	r12,r5
80004b2a:	f0 1f 00 12 	mcall	80004b70 <main+0xcc>
		(&(struct responseTaskArgs){{TEST_B, RESPONSE_B}, 0}),
		tskIDLE_PRIORITY + 2, NULL);
	xTaskCreate(responseTask, "", 1024,
80004b2e:	49 68       	lddpc	r8,80004b84 <main+0xe0>
80004b30:	fa c9 ff dc 	sub	r9,sp,-36
80004b34:	f0 ea 00 00 	ld.d	r10,r8[0]
80004b38:	f2 eb 00 00 	st.d	r9[0],r10
80004b3c:	70 28       	ld.w	r8,r8[0x8]
80004b3e:	93 28       	st.w	r9[0x8],r8
80004b40:	1a d7       	st.w	--sp,r7
80004b42:	1a d7       	st.w	--sp,r7
80004b44:	1a d7       	st.w	--sp,r7
80004b46:	30 18       	mov	r8,1
80004b48:	e0 6a 04 00 	mov	r10,1024
80004b4c:	0c 9b       	mov	r11,r6
80004b4e:	0a 9c       	mov	r12,r5
80004b50:	f0 1f 00 08 	mcall	80004b70 <main+0xcc>
		(&(struct responseTaskArgs){{TEST_C, RESPONSE_C}, 3}),
		tskIDLE_PRIORITY + 1, NULL);

	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
80004b54:	f0 1f 00 0d 	mcall	80004b88 <main+0xe4>
80004b58:	2f ad       	sub	sp,-24
    
80004b5a:	0e 9c       	mov	r12,r7
80004b5c:	2f 7d       	sub	sp,-36
80004b5e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004b62:	00 00       	add	r0,r0
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	4a 20       	lddpc	r0,80004bec <malloc+0xc>
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	5f 0c       	sreq	r12
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	4a 00       	lddpc	r0,80004bec <malloc+0xc>
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	47 48       	lddsp	r8,sp[0x1d0]
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	49 e0       	lddpc	r0,80004bec <malloc+0xc>
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	5f 10       	srne	r0
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	49 94       	lddpc	r4,80004be0 <malloc>
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	5f 1c       	srne	r12
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	5f 28       	srhs	r8
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	49 2c       	lddpc	r12,80004bd0 <free+0x8>

80004b8c <atexit>:
80004b8c:	d4 01       	pushm	lr
80004b8e:	30 09       	mov	r9,0
80004b90:	18 9b       	mov	r11,r12
80004b92:	12 9a       	mov	r10,r9
80004b94:	12 9c       	mov	r12,r9
80004b96:	f0 1f 00 02 	mcall	80004b9c <atexit+0x10>
80004b9a:	d8 02       	popm	pc
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	52 60       	stdsp	sp[0x98],r0

80004ba0 <exit>:
80004ba0:	d4 21       	pushm	r4-r7,lr
80004ba2:	30 0b       	mov	r11,0
80004ba4:	18 97       	mov	r7,r12
80004ba6:	f0 1f 00 06 	mcall	80004bbc <exit+0x1c>
80004baa:	48 68       	lddpc	r8,80004bc0 <exit+0x20>
80004bac:	70 0c       	ld.w	r12,r8[0x0]
80004bae:	78 a8       	ld.w	r8,r12[0x28]
80004bb0:	58 08       	cp.w	r8,0
80004bb2:	c0 20       	breq	80004bb6 <exit+0x16>
80004bb4:	5d 18       	icall	r8
80004bb6:	0e 9c       	mov	r12,r7
80004bb8:	f0 1f 00 03 	mcall	80004bc4 <exit+0x24>
80004bbc:	80 00       	ld.sh	r0,r0[0x0]
80004bbe:	53 0c       	stdsp	sp[0xc0],r12
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	5f 38       	srlo	r8
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	51 e6       	stdsp	sp[0x78],r6

80004bc8 <free>:
80004bc8:	d4 01       	pushm	lr
80004bca:	48 48       	lddpc	r8,80004bd8 <free+0x10>
80004bcc:	18 9b       	mov	r11,r12
80004bce:	70 0c       	ld.w	r12,r8[0x0]
80004bd0:	f0 1f 00 03 	mcall	80004bdc <free+0x14>
80004bd4:	d8 02       	popm	pc
80004bd6:	00 00       	add	r0,r0
80004bd8:	00 00       	add	r0,r0
80004bda:	01 ec       	ld.ub	r12,r0[0x6]
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	57 20       	stdsp	sp[0x1c8],r0

80004be0 <malloc>:
80004be0:	d4 01       	pushm	lr
80004be2:	48 48       	lddpc	r8,80004bf0 <malloc+0x10>
80004be4:	18 9b       	mov	r11,r12
80004be6:	70 0c       	ld.w	r12,r8[0x0]
80004be8:	f0 1f 00 03 	mcall	80004bf4 <malloc+0x14>
80004bec:	d8 02       	popm	pc
80004bee:	00 00       	add	r0,r0
80004bf0:	00 00       	add	r0,r0
80004bf2:	01 ec       	ld.ub	r12,r0[0x6]
80004bf4:	80 00       	ld.sh	r0,r0[0x0]
80004bf6:	4b f8       	lddpc	r8,80004cf0 <_malloc_r+0xf8>

80004bf8 <_malloc_r>:
80004bf8:	d4 31       	pushm	r0-r7,lr
80004bfa:	f6 c8 ff f5 	sub	r8,r11,-11
80004bfe:	18 95       	mov	r5,r12
80004c00:	10 97       	mov	r7,r8
80004c02:	e0 17 ff f8 	andl	r7,0xfff8
80004c06:	59 68       	cp.w	r8,22
80004c08:	f9 b7 08 10 	movls	r7,16
80004c0c:	16 37       	cp.w	r7,r11
80004c0e:	5f 38       	srlo	r8
80004c10:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004c14:	c0 50       	breq	80004c1e <_malloc_r+0x26>
80004c16:	30 c8       	mov	r8,12
80004c18:	99 38       	st.w	r12[0xc],r8
80004c1a:	e0 8f 01 f3 	bral	80005000 <_malloc_r+0x408>
80004c1e:	f0 1f 00 50 	mcall	80004d5c <_malloc_r+0x164>
80004c22:	e0 47 01 f7 	cp.w	r7,503
80004c26:	e0 8b 00 1c 	brhi	80004c5e <_malloc_r+0x66>
80004c2a:	ee 03 16 03 	lsr	r3,r7,0x3
80004c2e:	4c d8       	lddpc	r8,80004d60 <_malloc_r+0x168>
80004c30:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004c34:	70 36       	ld.w	r6,r8[0xc]
80004c36:	10 36       	cp.w	r6,r8
80004c38:	c0 61       	brne	80004c44 <_malloc_r+0x4c>
80004c3a:	ec c8 ff f8 	sub	r8,r6,-8
80004c3e:	70 36       	ld.w	r6,r8[0xc]
80004c40:	10 36       	cp.w	r6,r8
80004c42:	c0 c0       	breq	80004c5a <_malloc_r+0x62>
80004c44:	6c 18       	ld.w	r8,r6[0x4]
80004c46:	e0 18 ff fc 	andl	r8,0xfffc
80004c4a:	6c 3a       	ld.w	r10,r6[0xc]
80004c4c:	ec 08 00 09 	add	r9,r6,r8
80004c50:	0a 9c       	mov	r12,r5
80004c52:	6c 28       	ld.w	r8,r6[0x8]
80004c54:	95 28       	st.w	r10[0x8],r8
80004c56:	91 3a       	st.w	r8[0xc],r10
80004c58:	c4 68       	rjmp	80004ce4 <_malloc_r+0xec>
80004c5a:	2f e3       	sub	r3,-2
80004c5c:	c4 c8       	rjmp	80004cf4 <_malloc_r+0xfc>
80004c5e:	ee 03 16 09 	lsr	r3,r7,0x9
80004c62:	c0 41       	brne	80004c6a <_malloc_r+0x72>
80004c64:	ee 03 16 03 	lsr	r3,r7,0x3
80004c68:	c2 68       	rjmp	80004cb4 <_malloc_r+0xbc>
80004c6a:	58 43       	cp.w	r3,4
80004c6c:	e0 8b 00 06 	brhi	80004c78 <_malloc_r+0x80>
80004c70:	ee 03 16 06 	lsr	r3,r7,0x6
80004c74:	2c 83       	sub	r3,-56
80004c76:	c1 f8       	rjmp	80004cb4 <_malloc_r+0xbc>
80004c78:	59 43       	cp.w	r3,20
80004c7a:	e0 8b 00 04 	brhi	80004c82 <_malloc_r+0x8a>
80004c7e:	2a 53       	sub	r3,-91
80004c80:	c1 a8       	rjmp	80004cb4 <_malloc_r+0xbc>
80004c82:	e0 43 00 54 	cp.w	r3,84
80004c86:	e0 8b 00 06 	brhi	80004c92 <_malloc_r+0x9a>
80004c8a:	ee 03 16 0c 	lsr	r3,r7,0xc
80004c8e:	29 23       	sub	r3,-110
80004c90:	c1 28       	rjmp	80004cb4 <_malloc_r+0xbc>
80004c92:	e0 43 01 54 	cp.w	r3,340
80004c96:	e0 8b 00 06 	brhi	80004ca2 <_malloc_r+0xaa>
80004c9a:	ee 03 16 0f 	lsr	r3,r7,0xf
80004c9e:	28 93       	sub	r3,-119
80004ca0:	c0 a8       	rjmp	80004cb4 <_malloc_r+0xbc>
80004ca2:	e0 43 05 54 	cp.w	r3,1364
80004ca6:	e0 88 00 04 	brls	80004cae <_malloc_r+0xb6>
80004caa:	37 e3       	mov	r3,126
80004cac:	c0 48       	rjmp	80004cb4 <_malloc_r+0xbc>
80004cae:	ee 03 16 12 	lsr	r3,r7,0x12
80004cb2:	28 43       	sub	r3,-124
80004cb4:	4a ba       	lddpc	r10,80004d60 <_malloc_r+0x168>
80004cb6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004cba:	74 36       	ld.w	r6,r10[0xc]
80004cbc:	c1 98       	rjmp	80004cee <_malloc_r+0xf6>
80004cbe:	6c 19       	ld.w	r9,r6[0x4]
80004cc0:	e0 19 ff fc 	andl	r9,0xfffc
80004cc4:	f2 07 01 0b 	sub	r11,r9,r7
80004cc8:	58 fb       	cp.w	r11,15
80004cca:	e0 8a 00 04 	brle	80004cd2 <_malloc_r+0xda>
80004cce:	20 13       	sub	r3,1
80004cd0:	c1 18       	rjmp	80004cf2 <_malloc_r+0xfa>
80004cd2:	6c 38       	ld.w	r8,r6[0xc]
80004cd4:	58 0b       	cp.w	r11,0
80004cd6:	c0 b5       	brlt	80004cec <_malloc_r+0xf4>
80004cd8:	6c 2a       	ld.w	r10,r6[0x8]
80004cda:	ec 09 00 09 	add	r9,r6,r9
80004cde:	0a 9c       	mov	r12,r5
80004ce0:	91 2a       	st.w	r8[0x8],r10
80004ce2:	95 38       	st.w	r10[0xc],r8
80004ce4:	72 18       	ld.w	r8,r9[0x4]
80004ce6:	a1 a8       	sbr	r8,0x0
80004ce8:	93 18       	st.w	r9[0x4],r8
80004cea:	cb c8       	rjmp	80004e62 <_malloc_r+0x26a>
80004cec:	10 96       	mov	r6,r8
80004cee:	14 36       	cp.w	r6,r10
80004cf0:	ce 71       	brne	80004cbe <_malloc_r+0xc6>
80004cf2:	2f f3       	sub	r3,-1
80004cf4:	49 ba       	lddpc	r10,80004d60 <_malloc_r+0x168>
80004cf6:	f4 cc ff f8 	sub	r12,r10,-8
80004cfa:	78 26       	ld.w	r6,r12[0x8]
80004cfc:	18 36       	cp.w	r6,r12
80004cfe:	c6 e0       	breq	80004dda <_malloc_r+0x1e2>
80004d00:	6c 19       	ld.w	r9,r6[0x4]
80004d02:	e0 19 ff fc 	andl	r9,0xfffc
80004d06:	f2 07 01 08 	sub	r8,r9,r7
80004d0a:	58 f8       	cp.w	r8,15
80004d0c:	e0 89 00 90 	brgt	80004e2c <_malloc_r+0x234>
80004d10:	99 3c       	st.w	r12[0xc],r12
80004d12:	99 2c       	st.w	r12[0x8],r12
80004d14:	58 08       	cp.w	r8,0
80004d16:	c0 55       	brlt	80004d20 <_malloc_r+0x128>
80004d18:	ec 09 00 09 	add	r9,r6,r9
80004d1c:	0a 9c       	mov	r12,r5
80004d1e:	ce 3b       	rjmp	80004ce4 <_malloc_r+0xec>
80004d20:	e0 49 01 ff 	cp.w	r9,511
80004d24:	e0 8b 00 13 	brhi	80004d4a <_malloc_r+0x152>
80004d28:	a3 99       	lsr	r9,0x3
80004d2a:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004d2e:	70 2b       	ld.w	r11,r8[0x8]
80004d30:	8d 38       	st.w	r6[0xc],r8
80004d32:	8d 2b       	st.w	r6[0x8],r11
80004d34:	97 36       	st.w	r11[0xc],r6
80004d36:	91 26       	st.w	r8[0x8],r6
80004d38:	a3 49       	asr	r9,0x2
80004d3a:	74 18       	ld.w	r8,r10[0x4]
80004d3c:	30 1b       	mov	r11,1
80004d3e:	f6 09 09 49 	lsl	r9,r11,r9
80004d42:	f1 e9 10 09 	or	r9,r8,r9
80004d46:	95 19       	st.w	r10[0x4],r9
80004d48:	c4 98       	rjmp	80004dda <_malloc_r+0x1e2>
80004d4a:	f2 0a 16 09 	lsr	r10,r9,0x9
80004d4e:	58 4a       	cp.w	r10,4
80004d50:	e0 8b 00 0a 	brhi	80004d64 <_malloc_r+0x16c>
80004d54:	f2 0a 16 06 	lsr	r10,r9,0x6
80004d58:	2c 8a       	sub	r10,-56
80004d5a:	c2 38       	rjmp	80004da0 <_malloc_r+0x1a8>
80004d5c:	80 00       	ld.sh	r0,r0[0x0]
80004d5e:	43 1c       	lddsp	r12,sp[0xc4]
80004d60:	00 00       	add	r0,r0
80004d62:	01 f0       	ld.ub	r0,r0[0x7]
80004d64:	59 4a       	cp.w	r10,20
80004d66:	e0 8b 00 04 	brhi	80004d6e <_malloc_r+0x176>
80004d6a:	2a 5a       	sub	r10,-91
80004d6c:	c1 a8       	rjmp	80004da0 <_malloc_r+0x1a8>
80004d6e:	e0 4a 00 54 	cp.w	r10,84
80004d72:	e0 8b 00 06 	brhi	80004d7e <_malloc_r+0x186>
80004d76:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004d7a:	29 2a       	sub	r10,-110
80004d7c:	c1 28       	rjmp	80004da0 <_malloc_r+0x1a8>
80004d7e:	e0 4a 01 54 	cp.w	r10,340
80004d82:	e0 8b 00 06 	brhi	80004d8e <_malloc_r+0x196>
80004d86:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004d8a:	28 9a       	sub	r10,-119
80004d8c:	c0 a8       	rjmp	80004da0 <_malloc_r+0x1a8>
80004d8e:	e0 4a 05 54 	cp.w	r10,1364
80004d92:	e0 88 00 04 	brls	80004d9a <_malloc_r+0x1a2>
80004d96:	37 ea       	mov	r10,126
80004d98:	c0 48       	rjmp	80004da0 <_malloc_r+0x1a8>
80004d9a:	f2 0a 16 12 	lsr	r10,r9,0x12
80004d9e:	28 4a       	sub	r10,-124
80004da0:	4c 8b       	lddpc	r11,80004ec0 <_malloc_r+0x2c8>
80004da2:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004da6:	68 28       	ld.w	r8,r4[0x8]
80004da8:	08 38       	cp.w	r8,r4
80004daa:	c0 e1       	brne	80004dc6 <_malloc_r+0x1ce>
80004dac:	76 19       	ld.w	r9,r11[0x4]
80004dae:	a3 4a       	asr	r10,0x2
80004db0:	30 1e       	mov	lr,1
80004db2:	fc 0a 09 4a 	lsl	r10,lr,r10
80004db6:	f3 ea 10 0a 	or	r10,r9,r10
80004dba:	10 99       	mov	r9,r8
80004dbc:	97 1a       	st.w	r11[0x4],r10
80004dbe:	c0 a8       	rjmp	80004dd2 <_malloc_r+0x1da>
80004dc0:	70 28       	ld.w	r8,r8[0x8]
80004dc2:	08 38       	cp.w	r8,r4
80004dc4:	c0 60       	breq	80004dd0 <_malloc_r+0x1d8>
80004dc6:	70 1a       	ld.w	r10,r8[0x4]
80004dc8:	e0 1a ff fc 	andl	r10,0xfffc
80004dcc:	14 39       	cp.w	r9,r10
80004dce:	cf 93       	brcs	80004dc0 <_malloc_r+0x1c8>
80004dd0:	70 39       	ld.w	r9,r8[0xc]
80004dd2:	8d 39       	st.w	r6[0xc],r9
80004dd4:	8d 28       	st.w	r6[0x8],r8
80004dd6:	91 36       	st.w	r8[0xc],r6
80004dd8:	93 26       	st.w	r9[0x8],r6
80004dda:	e6 08 14 02 	asr	r8,r3,0x2
80004dde:	30 1b       	mov	r11,1
80004de0:	4b 84       	lddpc	r4,80004ec0 <_malloc_r+0x2c8>
80004de2:	f6 08 09 4b 	lsl	r11,r11,r8
80004de6:	68 18       	ld.w	r8,r4[0x4]
80004de8:	10 3b       	cp.w	r11,r8
80004dea:	e0 8b 00 6f 	brhi	80004ec8 <_malloc_r+0x2d0>
80004dee:	f7 e8 00 09 	and	r9,r11,r8
80004df2:	c0 b1       	brne	80004e08 <_malloc_r+0x210>
80004df4:	e0 13 ff fc 	andl	r3,0xfffc
80004df8:	a1 7b       	lsl	r11,0x1
80004dfa:	2f c3       	sub	r3,-4
80004dfc:	c0 38       	rjmp	80004e02 <_malloc_r+0x20a>
80004dfe:	2f c3       	sub	r3,-4
80004e00:	a1 7b       	lsl	r11,0x1
80004e02:	f7 e8 00 09 	and	r9,r11,r8
80004e06:	cf c0       	breq	80004dfe <_malloc_r+0x206>
80004e08:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004e0c:	06 92       	mov	r2,r3
80004e0e:	1c 91       	mov	r1,lr
80004e10:	62 36       	ld.w	r6,r1[0xc]
80004e12:	c2 e8       	rjmp	80004e6e <_malloc_r+0x276>
80004e14:	6c 1a       	ld.w	r10,r6[0x4]
80004e16:	e0 1a ff fc 	andl	r10,0xfffc
80004e1a:	f4 07 01 08 	sub	r8,r10,r7
80004e1e:	58 f8       	cp.w	r8,15
80004e20:	e0 8a 00 15 	brle	80004e4a <_malloc_r+0x252>
80004e24:	6c 3a       	ld.w	r10,r6[0xc]
80004e26:	6c 29       	ld.w	r9,r6[0x8]
80004e28:	95 29       	st.w	r10[0x8],r9
80004e2a:	93 3a       	st.w	r9[0xc],r10
80004e2c:	0e 99       	mov	r9,r7
80004e2e:	ec 07 00 07 	add	r7,r6,r7
80004e32:	a1 a9       	sbr	r9,0x0
80004e34:	99 37       	st.w	r12[0xc],r7
80004e36:	99 27       	st.w	r12[0x8],r7
80004e38:	8d 19       	st.w	r6[0x4],r9
80004e3a:	ee 08 09 08 	st.w	r7[r8],r8
80004e3e:	8f 2c       	st.w	r7[0x8],r12
80004e40:	8f 3c       	st.w	r7[0xc],r12
80004e42:	a1 a8       	sbr	r8,0x0
80004e44:	0a 9c       	mov	r12,r5
80004e46:	8f 18       	st.w	r7[0x4],r8
80004e48:	c0 d8       	rjmp	80004e62 <_malloc_r+0x26a>
80004e4a:	6c 39       	ld.w	r9,r6[0xc]
80004e4c:	58 08       	cp.w	r8,0
80004e4e:	c0 f5       	brlt	80004e6c <_malloc_r+0x274>
80004e50:	ec 0a 00 0a 	add	r10,r6,r10
80004e54:	74 18       	ld.w	r8,r10[0x4]
80004e56:	a1 a8       	sbr	r8,0x0
80004e58:	0a 9c       	mov	r12,r5
80004e5a:	95 18       	st.w	r10[0x4],r8
80004e5c:	6c 28       	ld.w	r8,r6[0x8]
80004e5e:	93 28       	st.w	r9[0x8],r8
80004e60:	91 39       	st.w	r8[0xc],r9
80004e62:	f0 1f 00 19 	mcall	80004ec4 <_malloc_r+0x2cc>
80004e66:	ec cc ff f8 	sub	r12,r6,-8
80004e6a:	d8 32       	popm	r0-r7,pc
80004e6c:	12 96       	mov	r6,r9
80004e6e:	02 36       	cp.w	r6,r1
80004e70:	cd 21       	brne	80004e14 <_malloc_r+0x21c>
80004e72:	2f f2       	sub	r2,-1
80004e74:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004e78:	c0 30       	breq	80004e7e <_malloc_r+0x286>
80004e7a:	2f 81       	sub	r1,-8
80004e7c:	cc ab       	rjmp	80004e10 <_malloc_r+0x218>
80004e7e:	1c 98       	mov	r8,lr
80004e80:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004e84:	c0 81       	brne	80004e94 <_malloc_r+0x29c>
80004e86:	68 19       	ld.w	r9,r4[0x4]
80004e88:	f6 08 11 ff 	rsub	r8,r11,-1
80004e8c:	f3 e8 00 08 	and	r8,r9,r8
80004e90:	89 18       	st.w	r4[0x4],r8
80004e92:	c0 78       	rjmp	80004ea0 <_malloc_r+0x2a8>
80004e94:	f0 c9 00 08 	sub	r9,r8,8
80004e98:	20 13       	sub	r3,1
80004e9a:	70 08       	ld.w	r8,r8[0x0]
80004e9c:	12 38       	cp.w	r8,r9
80004e9e:	cf 10       	breq	80004e80 <_malloc_r+0x288>
80004ea0:	a1 7b       	lsl	r11,0x1
80004ea2:	68 18       	ld.w	r8,r4[0x4]
80004ea4:	10 3b       	cp.w	r11,r8
80004ea6:	e0 8b 00 11 	brhi	80004ec8 <_malloc_r+0x2d0>
80004eaa:	58 0b       	cp.w	r11,0
80004eac:	c0 e0       	breq	80004ec8 <_malloc_r+0x2d0>
80004eae:	04 93       	mov	r3,r2
80004eb0:	c0 38       	rjmp	80004eb6 <_malloc_r+0x2be>
80004eb2:	2f c3       	sub	r3,-4
80004eb4:	a1 7b       	lsl	r11,0x1
80004eb6:	f7 e8 00 09 	and	r9,r11,r8
80004eba:	ca 71       	brne	80004e08 <_malloc_r+0x210>
80004ebc:	cf bb       	rjmp	80004eb2 <_malloc_r+0x2ba>
80004ebe:	00 00       	add	r0,r0
80004ec0:	00 00       	add	r0,r0
80004ec2:	01 f0       	ld.ub	r0,r0[0x7]
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	43 28       	lddsp	r8,sp[0xc8]
80004ec8:	68 23       	ld.w	r3,r4[0x8]
80004eca:	66 12       	ld.w	r2,r3[0x4]
80004ecc:	e0 12 ff fc 	andl	r2,0xfffc
80004ed0:	0e 32       	cp.w	r2,r7
80004ed2:	5f 39       	srlo	r9
80004ed4:	e4 07 01 08 	sub	r8,r2,r7
80004ed8:	58 f8       	cp.w	r8,15
80004eda:	5f aa       	srle	r10
80004edc:	f5 e9 10 09 	or	r9,r10,r9
80004ee0:	e0 80 00 a2 	breq	80005024 <_malloc_r+0x42c>
80004ee4:	4c 88       	lddpc	r8,80005004 <_malloc_r+0x40c>
80004ee6:	70 01       	ld.w	r1,r8[0x0]
80004ee8:	4c 88       	lddpc	r8,80005008 <_malloc_r+0x410>
80004eea:	2f 01       	sub	r1,-16
80004eec:	70 08       	ld.w	r8,r8[0x0]
80004eee:	0e 01       	add	r1,r7
80004ef0:	5b f8       	cp.w	r8,-1
80004ef2:	c0 40       	breq	80004efa <_malloc_r+0x302>
80004ef4:	28 11       	sub	r1,-127
80004ef6:	e0 11 ff 80 	andl	r1,0xff80
80004efa:	02 9b       	mov	r11,r1
80004efc:	0a 9c       	mov	r12,r5
80004efe:	f0 1f 00 44 	mcall	8000500c <_malloc_r+0x414>
80004f02:	18 96       	mov	r6,r12
80004f04:	5b fc       	cp.w	r12,-1
80004f06:	c6 e0       	breq	80004fe2 <_malloc_r+0x3ea>
80004f08:	e6 02 00 08 	add	r8,r3,r2
80004f0c:	10 3c       	cp.w	r12,r8
80004f0e:	c0 32       	brcc	80004f14 <_malloc_r+0x31c>
80004f10:	08 33       	cp.w	r3,r4
80004f12:	c6 81       	brne	80004fe2 <_malloc_r+0x3ea>
80004f14:	4b fa       	lddpc	r10,80005010 <_malloc_r+0x418>
80004f16:	74 09       	ld.w	r9,r10[0x0]
80004f18:	e2 09 00 09 	add	r9,r1,r9
80004f1c:	95 09       	st.w	r10[0x0],r9
80004f1e:	10 36       	cp.w	r6,r8
80004f20:	c0 a1       	brne	80004f34 <_malloc_r+0x33c>
80004f22:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004f26:	c0 71       	brne	80004f34 <_malloc_r+0x33c>
80004f28:	e2 02 00 02 	add	r2,r1,r2
80004f2c:	68 28       	ld.w	r8,r4[0x8]
80004f2e:	a1 a2       	sbr	r2,0x0
80004f30:	91 12       	st.w	r8[0x4],r2
80004f32:	c4 c8       	rjmp	80004fca <_malloc_r+0x3d2>
80004f34:	4b 5a       	lddpc	r10,80005008 <_malloc_r+0x410>
80004f36:	74 0b       	ld.w	r11,r10[0x0]
80004f38:	5b fb       	cp.w	r11,-1
80004f3a:	c0 31       	brne	80004f40 <_malloc_r+0x348>
80004f3c:	95 06       	st.w	r10[0x0],r6
80004f3e:	c0 68       	rjmp	80004f4a <_malloc_r+0x352>
80004f40:	ec 09 00 09 	add	r9,r6,r9
80004f44:	4b 3a       	lddpc	r10,80005010 <_malloc_r+0x418>
80004f46:	10 19       	sub	r9,r8
80004f48:	95 09       	st.w	r10[0x0],r9
80004f4a:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80004f4e:	f0 09 11 08 	rsub	r9,r8,8
80004f52:	58 08       	cp.w	r8,0
80004f54:	f2 08 17 10 	movne	r8,r9
80004f58:	ed d8 e1 06 	addne	r6,r6,r8
80004f5c:	28 08       	sub	r8,-128
80004f5e:	ec 01 00 01 	add	r1,r6,r1
80004f62:	0a 9c       	mov	r12,r5
80004f64:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80004f68:	f0 01 01 01 	sub	r1,r8,r1
80004f6c:	02 9b       	mov	r11,r1
80004f6e:	f0 1f 00 28 	mcall	8000500c <_malloc_r+0x414>
80004f72:	4a 88       	lddpc	r8,80005010 <_malloc_r+0x418>
80004f74:	5b fc       	cp.w	r12,-1
80004f76:	ec 0c 17 00 	moveq	r12,r6
80004f7a:	f9 b1 00 00 	moveq	r1,0
80004f7e:	70 09       	ld.w	r9,r8[0x0]
80004f80:	0c 1c       	sub	r12,r6
80004f82:	89 26       	st.w	r4[0x8],r6
80004f84:	02 0c       	add	r12,r1
80004f86:	12 01       	add	r1,r9
80004f88:	a1 ac       	sbr	r12,0x0
80004f8a:	91 01       	st.w	r8[0x0],r1
80004f8c:	8d 1c       	st.w	r6[0x4],r12
80004f8e:	08 33       	cp.w	r3,r4
80004f90:	c1 d0       	breq	80004fca <_malloc_r+0x3d2>
80004f92:	58 f2       	cp.w	r2,15
80004f94:	e0 8b 00 05 	brhi	80004f9e <_malloc_r+0x3a6>
80004f98:	30 18       	mov	r8,1
80004f9a:	8d 18       	st.w	r6[0x4],r8
80004f9c:	c2 38       	rjmp	80004fe2 <_malloc_r+0x3ea>
80004f9e:	30 59       	mov	r9,5
80004fa0:	20 c2       	sub	r2,12
80004fa2:	e0 12 ff f8 	andl	r2,0xfff8
80004fa6:	e6 02 00 08 	add	r8,r3,r2
80004faa:	91 29       	st.w	r8[0x8],r9
80004fac:	91 19       	st.w	r8[0x4],r9
80004fae:	66 18       	ld.w	r8,r3[0x4]
80004fb0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004fb4:	e5 e8 10 08 	or	r8,r2,r8
80004fb8:	87 18       	st.w	r3[0x4],r8
80004fba:	58 f2       	cp.w	r2,15
80004fbc:	e0 88 00 07 	brls	80004fca <_malloc_r+0x3d2>
80004fc0:	e6 cb ff f8 	sub	r11,r3,-8
80004fc4:	0a 9c       	mov	r12,r5
80004fc6:	f0 1f 00 14 	mcall	80005014 <_malloc_r+0x41c>
80004fca:	49 49       	lddpc	r9,80005018 <_malloc_r+0x420>
80004fcc:	72 0a       	ld.w	r10,r9[0x0]
80004fce:	49 18       	lddpc	r8,80005010 <_malloc_r+0x418>
80004fd0:	70 08       	ld.w	r8,r8[0x0]
80004fd2:	14 38       	cp.w	r8,r10
80004fd4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004fd8:	49 19       	lddpc	r9,8000501c <_malloc_r+0x424>
80004fda:	72 0a       	ld.w	r10,r9[0x0]
80004fdc:	14 38       	cp.w	r8,r10
80004fde:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80004fe2:	68 28       	ld.w	r8,r4[0x8]
80004fe4:	70 18       	ld.w	r8,r8[0x4]
80004fe6:	e0 18 ff fc 	andl	r8,0xfffc
80004fea:	0e 38       	cp.w	r8,r7
80004fec:	5f 39       	srlo	r9
80004fee:	0e 18       	sub	r8,r7
80004ff0:	58 f8       	cp.w	r8,15
80004ff2:	5f aa       	srle	r10
80004ff4:	f5 e9 10 09 	or	r9,r10,r9
80004ff8:	c1 60       	breq	80005024 <_malloc_r+0x42c>
80004ffa:	0a 9c       	mov	r12,r5
80004ffc:	f0 1f 00 09 	mcall	80005020 <_malloc_r+0x428>
80005000:	d8 3a       	popm	r0-r7,pc,r12=0
80005002:	00 00       	add	r0,r0
80005004:	00 00       	add	r0,r0
80005006:	09 d0       	ld.ub	r0,r4[0x5]
80005008:	00 00       	add	r0,r0
8000500a:	05 fc       	ld.ub	r12,r2[0x7]
8000500c:	80 00       	ld.sh	r0,r0[0x0]
8000500e:	50 58       	stdsp	sp[0x14],r8
80005010:	00 00       	add	r0,r0
80005012:	09 d4       	ld.ub	r4,r4[0x5]
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	57 20       	stdsp	sp[0x1c8],r0
80005018:	00 00       	add	r0,r0
8000501a:	09 cc       	ld.ub	r12,r4[0x4]
8000501c:	00 00       	add	r0,r0
8000501e:	09 c8       	ld.ub	r8,r4[0x4]
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	43 28       	lddsp	r8,sp[0xc8]
80005024:	68 26       	ld.w	r6,r4[0x8]
80005026:	a1 a8       	sbr	r8,0x0
80005028:	0e 99       	mov	r9,r7
8000502a:	a1 a9       	sbr	r9,0x0
8000502c:	8d 19       	st.w	r6[0x4],r9
8000502e:	ec 07 00 07 	add	r7,r6,r7
80005032:	0a 9c       	mov	r12,r5
80005034:	89 27       	st.w	r4[0x8],r7
80005036:	8f 18       	st.w	r7[0x4],r8
80005038:	f0 1f 00 03 	mcall	80005044 <_malloc_r+0x44c>
8000503c:	ec cc ff f8 	sub	r12,r6,-8
80005040:	d8 32       	popm	r0-r7,pc
80005042:	00 00       	add	r0,r0
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	43 28       	lddsp	r8,sp[0xc8]

80005048 <memset>:
80005048:	18 98       	mov	r8,r12
8000504a:	c0 38       	rjmp	80005050 <memset+0x8>
8000504c:	10 cb       	st.b	r8++,r11
8000504e:	20 1a       	sub	r10,1
80005050:	58 0a       	cp.w	r10,0
80005052:	cf d1       	brne	8000504c <memset+0x4>
80005054:	5e fc       	retal	r12
80005056:	d7 03       	nop

80005058 <_sbrk_r>:
80005058:	d4 21       	pushm	r4-r7,lr
8000505a:	30 08       	mov	r8,0
8000505c:	18 97       	mov	r7,r12
8000505e:	48 76       	lddpc	r6,80005078 <_sbrk_r+0x20>
80005060:	16 9c       	mov	r12,r11
80005062:	8d 08       	st.w	r6[0x0],r8
80005064:	f0 1f 00 06 	mcall	8000507c <_sbrk_r+0x24>
80005068:	5b fc       	cp.w	r12,-1
8000506a:	c0 51       	brne	80005074 <_sbrk_r+0x1c>
8000506c:	6c 08       	ld.w	r8,r6[0x0]
8000506e:	58 08       	cp.w	r8,0
80005070:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005074:	d8 22       	popm	r4-r7,pc
80005076:	00 00       	add	r0,r0
80005078:	00 00       	add	r0,r0
8000507a:	0a 2c       	rsub	r12,r5
8000507c:	80 00       	ld.sh	r0,r0[0x0]
8000507e:	52 20       	stdsp	sp[0x88],r0

80005080 <setbuf>:
80005080:	d4 01       	pushm	lr
80005082:	e0 69 04 00 	mov	r9,1024
80005086:	58 0b       	cp.w	r11,0
80005088:	f9 ba 00 02 	moveq	r10,2
8000508c:	f9 ba 01 00 	movne	r10,0
80005090:	f0 1f 00 02 	mcall	80005098 <setbuf+0x18>
80005094:	d8 02       	popm	pc
80005096:	00 00       	add	r0,r0
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	50 9c       	stdsp	sp[0x24],r12

8000509c <setvbuf>:
8000509c:	d4 31       	pushm	r0-r7,lr
8000509e:	4b f8       	lddpc	r8,80005198 <setvbuf+0xfc>
800050a0:	18 97       	mov	r7,r12
800050a2:	16 96       	mov	r6,r11
800050a4:	14 95       	mov	r5,r10
800050a6:	12 94       	mov	r4,r9
800050a8:	70 0c       	ld.w	r12,r8[0x0]
800050aa:	58 0c       	cp.w	r12,0
800050ac:	c0 60       	breq	800050b8 <setvbuf+0x1c>
800050ae:	78 68       	ld.w	r8,r12[0x18]
800050b0:	58 08       	cp.w	r8,0
800050b2:	c0 31       	brne	800050b8 <setvbuf+0x1c>
800050b4:	f0 1f 00 3a 	mcall	8000519c <setvbuf+0x100>
800050b8:	4b a8       	lddpc	r8,800051a0 <setvbuf+0x104>
800050ba:	10 37       	cp.w	r7,r8
800050bc:	c0 51       	brne	800050c6 <setvbuf+0x2a>
800050be:	4b 78       	lddpc	r8,80005198 <setvbuf+0xfc>
800050c0:	70 08       	ld.w	r8,r8[0x0]
800050c2:	70 07       	ld.w	r7,r8[0x0]
800050c4:	c0 e8       	rjmp	800050e0 <setvbuf+0x44>
800050c6:	4b 88       	lddpc	r8,800051a4 <setvbuf+0x108>
800050c8:	10 37       	cp.w	r7,r8
800050ca:	c0 51       	brne	800050d4 <setvbuf+0x38>
800050cc:	4b 38       	lddpc	r8,80005198 <setvbuf+0xfc>
800050ce:	70 08       	ld.w	r8,r8[0x0]
800050d0:	70 17       	ld.w	r7,r8[0x4]
800050d2:	c0 78       	rjmp	800050e0 <setvbuf+0x44>
800050d4:	4b 58       	lddpc	r8,800051a8 <setvbuf+0x10c>
800050d6:	10 37       	cp.w	r7,r8
800050d8:	c0 41       	brne	800050e0 <setvbuf+0x44>
800050da:	4b 08       	lddpc	r8,80005198 <setvbuf+0xfc>
800050dc:	70 08       	ld.w	r8,r8[0x0]
800050de:	70 27       	ld.w	r7,r8[0x8]
800050e0:	58 25       	cp.w	r5,2
800050e2:	5f b8       	srhi	r8
800050e4:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
800050e8:	c0 20       	breq	800050ec <setvbuf+0x50>
800050ea:	dc 3a       	popm	r0-r7,pc,r12=-1
800050ec:	4a b3       	lddpc	r3,80005198 <setvbuf+0xfc>
800050ee:	0e 9b       	mov	r11,r7
800050f0:	66 0c       	ld.w	r12,r3[0x0]
800050f2:	f0 1f 00 2f 	mcall	800051ac <setvbuf+0x110>
800050f6:	30 08       	mov	r8,0
800050f8:	8f 68       	st.w	r7[0x18],r8
800050fa:	8f 18       	st.w	r7[0x4],r8
800050fc:	8e 68       	ld.sh	r8,r7[0xc]
800050fe:	ed b8 00 07 	bld	r8,0x7
80005102:	c0 51       	brne	8000510c <setvbuf+0x70>
80005104:	66 0c       	ld.w	r12,r3[0x0]
80005106:	6e 4b       	ld.w	r11,r7[0x10]
80005108:	f0 1f 00 2a 	mcall	800051b0 <setvbuf+0x114>
8000510c:	8e 68       	ld.sh	r8,r7[0xc]
8000510e:	e0 18 ff 7c 	andl	r8,0xff7c
80005112:	ae 68       	st.h	r7[0xc],r8
80005114:	58 25       	cp.w	r5,2
80005116:	c0 31       	brne	8000511c <setvbuf+0x80>
80005118:	30 0c       	mov	r12,0
8000511a:	c1 38       	rjmp	80005140 <setvbuf+0xa4>
8000511c:	58 06       	cp.w	r6,0
8000511e:	c2 11       	brne	80005160 <setvbuf+0xc4>
80005120:	e0 63 04 00 	mov	r3,1024
80005124:	58 04       	cp.w	r4,0
80005126:	e6 04 17 00 	moveq	r4,r3
8000512a:	08 9c       	mov	r12,r4
8000512c:	f0 1f 00 22 	mcall	800051b4 <setvbuf+0x118>
80005130:	18 96       	mov	r6,r12
80005132:	c1 41       	brne	8000515a <setvbuf+0xbe>
80005134:	06 9c       	mov	r12,r3
80005136:	f0 1f 00 20 	mcall	800051b4 <setvbuf+0x118>
8000513a:	18 96       	mov	r6,r12
8000513c:	c0 e1       	brne	80005158 <setvbuf+0xbc>
8000513e:	3f fc       	mov	r12,-1
80005140:	8e 68       	ld.sh	r8,r7[0xc]
80005142:	a1 b8       	sbr	r8,0x1
80005144:	ae 68       	st.h	r7[0xc],r8
80005146:	ee c8 ff b9 	sub	r8,r7,-71
8000514a:	8f 48       	st.w	r7[0x10],r8
8000514c:	8f 08       	st.w	r7[0x0],r8
8000514e:	30 08       	mov	r8,0
80005150:	8f 28       	st.w	r7[0x8],r8
80005152:	30 18       	mov	r8,1
80005154:	8f 58       	st.w	r7[0x14],r8
80005156:	d8 32       	popm	r0-r7,pc
80005158:	06 94       	mov	r4,r3
8000515a:	8e 68       	ld.sh	r8,r7[0xc]
8000515c:	a7 b8       	sbr	r8,0x7
8000515e:	ae 68       	st.h	r7[0xc],r8
80005160:	58 15       	cp.w	r5,1
80005162:	c0 71       	brne	80005170 <setvbuf+0xd4>
80005164:	8e 68       	ld.sh	r8,r7[0xc]
80005166:	a1 a8       	sbr	r8,0x0
80005168:	ae 68       	st.h	r7[0xc],r8
8000516a:	e8 08 11 00 	rsub	r8,r4,0
8000516e:	8f 68       	st.w	r7[0x18],r8
80005170:	48 a8       	lddpc	r8,80005198 <setvbuf+0xfc>
80005172:	49 29       	lddpc	r9,800051b8 <setvbuf+0x11c>
80005174:	70 08       	ld.w	r8,r8[0x0]
80005176:	8f 46       	st.w	r7[0x10],r6
80005178:	91 a9       	st.w	r8[0x28],r9
8000517a:	8f 06       	st.w	r7[0x0],r6
8000517c:	8f 54       	st.w	r7[0x14],r4
8000517e:	8e 68       	ld.sh	r8,r7[0xc]
80005180:	10 9c       	mov	r12,r8
80005182:	e2 1c 00 08 	andl	r12,0x8,COH
80005186:	c0 70       	breq	80005194 <setvbuf+0xf8>
80005188:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000518c:	30 0c       	mov	r12,0
8000518e:	f9 b4 01 00 	movne	r4,0
80005192:	8f 24       	st.w	r7[0x8],r4
80005194:	d8 32       	popm	r0-r7,pc
80005196:	00 00       	add	r0,r0
80005198:	00 00       	add	r0,r0
8000519a:	01 ec       	ld.ub	r12,r0[0x6]
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	55 c8       	stdsp	sp[0x170],r8
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	5f 3c       	srlo	r12
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	5f 5c       	srlt	r12
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	5f 7c       	srpl	r12
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	53 ec       	stdsp	sp[0xf8],r12
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	57 20       	stdsp	sp[0x1c8],r0
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	4b e0       	lddpc	r0,800052ac <__register_exitproc+0x4c>
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	55 08       	stdsp	sp[0x140],r8

800051bc <strncpy>:
800051bc:	30 08       	mov	r8,0
800051be:	10 3a       	cp.w	r10,r8
800051c0:	5e 0c       	reteq	r12
800051c2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800051c6:	f8 08 0b 09 	st.b	r12[r8],r9
800051ca:	2f f8       	sub	r8,-1
800051cc:	58 09       	cp.w	r9,0
800051ce:	cf 81       	brne	800051be <strncpy+0x2>
800051d0:	10 3a       	cp.w	r10,r8
800051d2:	5e 0c       	reteq	r12
800051d4:	f8 08 0b 09 	st.b	r12[r8],r9
800051d8:	2f f8       	sub	r8,-1
800051da:	cf bb       	rjmp	800051d0 <strncpy+0x14>

800051dc <_init_argv>:
800051dc:	30 e8       	mov	r8,14
800051de:	d6 73       	breakpoint
800051e0:	3f fc       	mov	r12,-1
800051e2:	35 8b       	mov	r11,88
800051e4:	5e fc       	retal	r12

800051e6 <_exit>:
800051e6:	30 d8       	mov	r8,13
800051e8:	d6 73       	breakpoint
800051ea:	3f fc       	mov	r12,-1
800051ec:	35 8b       	mov	r11,88
800051ee:	c0 08       	rjmp	800051ee <_exit+0x8>

800051f0 <_close>:
800051f0:	30 28       	mov	r8,2
800051f2:	d6 73       	breakpoint
800051f4:	3f fc       	mov	r12,-1
800051f6:	35 8b       	mov	r11,88
800051f8:	58 0c       	cp.w	r12,0
800051fa:	5e 4c       	retge	r12
800051fc:	48 2a       	lddpc	r10,80005204 <_close+0x14>
800051fe:	95 0b       	st.w	r10[0x0],r11
80005200:	5e fc       	retal	r12
80005202:	00 00       	add	r0,r0
80005204:	00 00       	add	r0,r0
80005206:	0a 2c       	rsub	r12,r5

80005208 <_lseek>:
80005208:	30 58       	mov	r8,5
8000520a:	d6 73       	breakpoint
8000520c:	3f fc       	mov	r12,-1
8000520e:	35 8b       	mov	r11,88
80005210:	58 0c       	cp.w	r12,0
80005212:	5e 4c       	retge	r12
80005214:	48 2a       	lddpc	r10,8000521c <_lseek+0x14>
80005216:	95 0b       	st.w	r10[0x0],r11
80005218:	5e fc       	retal	r12
8000521a:	00 00       	add	r0,r0
8000521c:	00 00       	add	r0,r0
8000521e:	0a 2c       	rsub	r12,r5

80005220 <_sbrk>:
80005220:	d4 01       	pushm	lr
80005222:	48 c8       	lddpc	r8,80005250 <_sbrk+0x30>
80005224:	70 09       	ld.w	r9,r8[0x0]
80005226:	58 09       	cp.w	r9,0
80005228:	c0 31       	brne	8000522e <_sbrk+0xe>
8000522a:	48 b9       	lddpc	r9,80005254 <_sbrk+0x34>
8000522c:	91 09       	st.w	r8[0x0],r9
8000522e:	48 99       	lddpc	r9,80005250 <_sbrk+0x30>
80005230:	48 aa       	lddpc	r10,80005258 <_sbrk+0x38>
80005232:	72 08       	ld.w	r8,r9[0x0]
80005234:	f0 0c 00 0c 	add	r12,r8,r12
80005238:	14 3c       	cp.w	r12,r10
8000523a:	e0 8b 00 04 	brhi	80005242 <_sbrk+0x22>
8000523e:	93 0c       	st.w	r9[0x0],r12
80005240:	c0 68       	rjmp	8000524c <_sbrk+0x2c>
80005242:	f0 1f 00 07 	mcall	8000525c <_sbrk+0x3c>
80005246:	30 c8       	mov	r8,12
80005248:	99 08       	st.w	r12[0x0],r8
8000524a:	3f f8       	mov	r8,-1
8000524c:	10 9c       	mov	r12,r8
8000524e:	d8 02       	popm	pc
80005250:	00 00       	add	r0,r0
80005252:	09 fc       	ld.ub	r12,r4[0x7]
80005254:	00 00       	add	r0,r0
80005256:	0a 30       	cp.w	r0,r5
80005258:	00 00       	add	r0,r0
8000525a:	f0 00       	*unknown*
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	53 e0       	stdsp	sp[0xf8],r0

80005260 <__register_exitproc>:
80005260:	d4 31       	pushm	r0-r7,lr
80005262:	4a 98       	lddpc	r8,80005304 <__register_exitproc+0xa4>
80005264:	70 03       	ld.w	r3,r8[0x0]
80005266:	67 24       	ld.w	r4,r3[0x48]
80005268:	e6 c8 ff b4 	sub	r8,r3,-76
8000526c:	58 04       	cp.w	r4,0
8000526e:	f0 04 17 00 	moveq	r4,r8
80005272:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80005276:	18 97       	mov	r7,r12
80005278:	16 96       	mov	r6,r11
8000527a:	14 95       	mov	r5,r10
8000527c:	12 92       	mov	r2,r9
8000527e:	68 18       	ld.w	r8,r4[0x4]
80005280:	59 f8       	cp.w	r8,31
80005282:	e0 8a 00 0e 	brle	8000529e <__register_exitproc+0x3e>
80005286:	e0 6c 00 8c 	mov	r12,140
8000528a:	f0 1f 00 20 	mcall	80005308 <__register_exitproc+0xa8>
8000528e:	18 94       	mov	r4,r12
80005290:	c3 80       	breq	80005300 <__register_exitproc+0xa0>
80005292:	67 28       	ld.w	r8,r3[0x48]
80005294:	99 08       	st.w	r12[0x0],r8
80005296:	e7 4c 00 48 	st.w	r3[72],r12
8000529a:	30 08       	mov	r8,0
8000529c:	99 18       	st.w	r12[0x4],r8
8000529e:	58 07       	cp.w	r7,0
800052a0:	c2 70       	breq	800052ee <__register_exitproc+0x8e>
800052a2:	e8 fc 00 88 	ld.w	r12,r4[136]
800052a6:	58 0c       	cp.w	r12,0
800052a8:	c0 d1       	brne	800052c2 <__register_exitproc+0x62>
800052aa:	e0 6c 01 08 	mov	r12,264
800052ae:	f0 1f 00 17 	mcall	80005308 <__register_exitproc+0xa8>
800052b2:	c2 70       	breq	80005300 <__register_exitproc+0xa0>
800052b4:	30 08       	mov	r8,0
800052b6:	e9 4c 00 88 	st.w	r4[136],r12
800052ba:	f9 48 01 04 	st.w	r12[260],r8
800052be:	f9 48 01 00 	st.w	r12[256],r8
800052c2:	68 18       	ld.w	r8,r4[0x4]
800052c4:	f0 c9 ff e0 	sub	r9,r8,-32
800052c8:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
800052cc:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
800052d0:	30 1a       	mov	r10,1
800052d2:	f8 f9 01 00 	ld.w	r9,r12[256]
800052d6:	f4 08 09 48 	lsl	r8,r10,r8
800052da:	10 49       	or	r9,r8
800052dc:	f9 49 01 00 	st.w	r12[256],r9
800052e0:	58 27       	cp.w	r7,2
800052e2:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
800052e6:	f3 d8 e0 38 	oreq	r8,r9,r8
800052ea:	f9 f8 0a 41 	st.weq	r12[0x104],r8
800052ee:	68 18       	ld.w	r8,r4[0x4]
800052f0:	30 0c       	mov	r12,0
800052f2:	f0 c9 ff ff 	sub	r9,r8,-1
800052f6:	2f e8       	sub	r8,-2
800052f8:	89 19       	st.w	r4[0x4],r9
800052fa:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
800052fe:	d8 32       	popm	r0-r7,pc
80005300:	dc 3a       	popm	r0-r7,pc,r12=-1
80005302:	00 00       	add	r0,r0
80005304:	80 00       	ld.sh	r0,r0[0x0]
80005306:	5f 38       	srlo	r8
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	4b e0       	lddpc	r0,80005400 <_fflush_r+0x14>

8000530c <__call_exitprocs>:
8000530c:	d4 31       	pushm	r0-r7,lr
8000530e:	20 3d       	sub	sp,12
80005310:	4b 28       	lddpc	r8,800053d8 <__call_exitprocs+0xcc>
80005312:	50 2c       	stdsp	sp[0x8],r12
80005314:	70 08       	ld.w	r8,r8[0x0]
80005316:	16 91       	mov	r1,r11
80005318:	50 08       	stdsp	sp[0x0],r8
8000531a:	2b 88       	sub	r8,-72
8000531c:	50 18       	stdsp	sp[0x4],r8
8000531e:	40 0a       	lddsp	r10,sp[0x0]
80005320:	40 14       	lddsp	r4,sp[0x4]
80005322:	75 27       	ld.w	r7,r10[0x48]
80005324:	c5 58       	rjmp	800053ce <__call_exitprocs+0xc2>
80005326:	6e 15       	ld.w	r5,r7[0x4]
80005328:	ee f6 00 88 	ld.w	r6,r7[136]
8000532c:	ea c2 ff ff 	sub	r2,r5,-1
80005330:	20 15       	sub	r5,1
80005332:	ee 02 00 22 	add	r2,r7,r2<<0x2
80005336:	ec 05 00 23 	add	r3,r6,r5<<0x2
8000533a:	c3 58       	rjmp	800053a4 <__call_exitprocs+0x98>
8000533c:	58 01       	cp.w	r1,0
8000533e:	c0 70       	breq	8000534c <__call_exitprocs+0x40>
80005340:	58 06       	cp.w	r6,0
80005342:	c2 e0       	breq	8000539e <__call_exitprocs+0x92>
80005344:	e6 f8 00 80 	ld.w	r8,r3[128]
80005348:	02 38       	cp.w	r8,r1
8000534a:	c2 a1       	brne	8000539e <__call_exitprocs+0x92>
8000534c:	6e 19       	ld.w	r9,r7[0x4]
8000534e:	64 08       	ld.w	r8,r2[0x0]
80005350:	20 19       	sub	r9,1
80005352:	12 35       	cp.w	r5,r9
80005354:	ef f5 0a 01 	st.weq	r7[0x4],r5
80005358:	f9 b9 01 00 	movne	r9,0
8000535c:	e5 f9 1a 00 	st.wne	r2[0x0],r9
80005360:	58 08       	cp.w	r8,0
80005362:	c1 e0       	breq	8000539e <__call_exitprocs+0x92>
80005364:	6e 10       	ld.w	r0,r7[0x4]
80005366:	58 06       	cp.w	r6,0
80005368:	c0 90       	breq	8000537a <__call_exitprocs+0x6e>
8000536a:	30 1a       	mov	r10,1
8000536c:	f4 05 09 49 	lsl	r9,r10,r5
80005370:	ec fa 01 00 	ld.w	r10,r6[256]
80005374:	f3 ea 00 0a 	and	r10,r9,r10
80005378:	c0 31       	brne	8000537e <__call_exitprocs+0x72>
8000537a:	5d 18       	icall	r8
8000537c:	c0 b8       	rjmp	80005392 <__call_exitprocs+0x86>
8000537e:	ec fa 01 04 	ld.w	r10,r6[260]
80005382:	66 0b       	ld.w	r11,r3[0x0]
80005384:	14 69       	and	r9,r10
80005386:	c0 41       	brne	8000538e <__call_exitprocs+0x82>
80005388:	40 2c       	lddsp	r12,sp[0x8]
8000538a:	5d 18       	icall	r8
8000538c:	c0 38       	rjmp	80005392 <__call_exitprocs+0x86>
8000538e:	16 9c       	mov	r12,r11
80005390:	5d 18       	icall	r8
80005392:	6e 18       	ld.w	r8,r7[0x4]
80005394:	10 30       	cp.w	r0,r8
80005396:	cc 41       	brne	8000531e <__call_exitprocs+0x12>
80005398:	68 08       	ld.w	r8,r4[0x0]
8000539a:	0e 38       	cp.w	r8,r7
8000539c:	cc 11       	brne	8000531e <__call_exitprocs+0x12>
8000539e:	20 15       	sub	r5,1
800053a0:	20 43       	sub	r3,4
800053a2:	20 42       	sub	r2,4
800053a4:	58 05       	cp.w	r5,0
800053a6:	cc b4       	brge	8000533c <__call_exitprocs+0x30>
800053a8:	6e 18       	ld.w	r8,r7[0x4]
800053aa:	58 08       	cp.w	r8,0
800053ac:	c0 f1       	brne	800053ca <__call_exitprocs+0xbe>
800053ae:	6e 08       	ld.w	r8,r7[0x0]
800053b0:	58 08       	cp.w	r8,0
800053b2:	c0 c0       	breq	800053ca <__call_exitprocs+0xbe>
800053b4:	89 08       	st.w	r4[0x0],r8
800053b6:	58 06       	cp.w	r6,0
800053b8:	c0 40       	breq	800053c0 <__call_exitprocs+0xb4>
800053ba:	0c 9c       	mov	r12,r6
800053bc:	f0 1f 00 08 	mcall	800053dc <__call_exitprocs+0xd0>
800053c0:	0e 9c       	mov	r12,r7
800053c2:	f0 1f 00 07 	mcall	800053dc <__call_exitprocs+0xd0>
800053c6:	68 07       	ld.w	r7,r4[0x0]
800053c8:	c0 38       	rjmp	800053ce <__call_exitprocs+0xc2>
800053ca:	0e 94       	mov	r4,r7
800053cc:	6e 07       	ld.w	r7,r7[0x0]
800053ce:	58 07       	cp.w	r7,0
800053d0:	ca b1       	brne	80005326 <__call_exitprocs+0x1a>
800053d2:	2f dd       	sub	sp,-12
800053d4:	d8 32       	popm	r0-r7,pc
800053d6:	00 00       	add	r0,r0
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	5f 38       	srlo	r8
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	4b c8       	lddpc	r8,800054cc <_fflush_r+0xe0>

800053e0 <__errno>:
800053e0:	48 28       	lddpc	r8,800053e8 <__errno+0x8>
800053e2:	70 0c       	ld.w	r12,r8[0x0]
800053e4:	2f 4c       	sub	r12,-12
800053e6:	5e fc       	retal	r12
800053e8:	00 00       	add	r0,r0
800053ea:	01 ec       	ld.ub	r12,r0[0x6]

800053ec <_fflush_r>:
800053ec:	d4 21       	pushm	r4-r7,lr
800053ee:	16 97       	mov	r7,r11
800053f0:	18 96       	mov	r6,r12
800053f2:	76 48       	ld.w	r8,r11[0x10]
800053f4:	58 08       	cp.w	r8,0
800053f6:	c7 d0       	breq	800054f0 <_fflush_r+0x104>
800053f8:	58 0c       	cp.w	r12,0
800053fa:	c0 60       	breq	80005406 <_fflush_r+0x1a>
800053fc:	78 68       	ld.w	r8,r12[0x18]
800053fe:	58 08       	cp.w	r8,0
80005400:	c0 31       	brne	80005406 <_fflush_r+0x1a>
80005402:	f0 1f 00 3d 	mcall	800054f4 <_fflush_r+0x108>
80005406:	4b d8       	lddpc	r8,800054f8 <_fflush_r+0x10c>
80005408:	10 37       	cp.w	r7,r8
8000540a:	c0 31       	brne	80005410 <_fflush_r+0x24>
8000540c:	6c 07       	ld.w	r7,r6[0x0]
8000540e:	c0 a8       	rjmp	80005422 <_fflush_r+0x36>
80005410:	4b b8       	lddpc	r8,800054fc <_fflush_r+0x110>
80005412:	10 37       	cp.w	r7,r8
80005414:	c0 31       	brne	8000541a <_fflush_r+0x2e>
80005416:	6c 17       	ld.w	r7,r6[0x4]
80005418:	c0 58       	rjmp	80005422 <_fflush_r+0x36>
8000541a:	4b a8       	lddpc	r8,80005500 <_fflush_r+0x114>
8000541c:	10 37       	cp.w	r7,r8
8000541e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80005422:	8e 6a       	ld.sh	r10,r7[0xc]
80005424:	14 98       	mov	r8,r10
80005426:	ed ba 00 03 	bld	r10,0x3
8000542a:	c4 20       	breq	800054ae <_fflush_r+0xc2>
8000542c:	ab ba       	sbr	r10,0xb
8000542e:	ae 6a       	st.h	r7[0xc],r10
80005430:	6e 18       	ld.w	r8,r7[0x4]
80005432:	58 08       	cp.w	r8,0
80005434:	e0 89 00 06 	brgt	80005440 <_fflush_r+0x54>
80005438:	6f 08       	ld.w	r8,r7[0x40]
8000543a:	58 08       	cp.w	r8,0
8000543c:	e0 8a 00 5a 	brle	800054f0 <_fflush_r+0x104>
80005440:	6e b8       	ld.w	r8,r7[0x2c]
80005442:	58 08       	cp.w	r8,0
80005444:	c5 60       	breq	800054f0 <_fflush_r+0x104>
80005446:	e2 1a 10 00 	andl	r10,0x1000,COH
8000544a:	c0 30       	breq	80005450 <_fflush_r+0x64>
8000544c:	6f 55       	ld.w	r5,r7[0x54]
8000544e:	c0 f8       	rjmp	8000546c <_fflush_r+0x80>
80005450:	30 19       	mov	r9,1
80005452:	6e 8b       	ld.w	r11,r7[0x20]
80005454:	0c 9c       	mov	r12,r6
80005456:	5d 18       	icall	r8
80005458:	18 95       	mov	r5,r12
8000545a:	5b fc       	cp.w	r12,-1
8000545c:	c0 81       	brne	8000546c <_fflush_r+0x80>
8000545e:	6c 38       	ld.w	r8,r6[0xc]
80005460:	59 d8       	cp.w	r8,29
80005462:	c4 70       	breq	800054f0 <_fflush_r+0x104>
80005464:	8e 68       	ld.sh	r8,r7[0xc]
80005466:	a7 a8       	sbr	r8,0x6
80005468:	ae 68       	st.h	r7[0xc],r8
8000546a:	d8 22       	popm	r4-r7,pc
8000546c:	8e 68       	ld.sh	r8,r7[0xc]
8000546e:	ed b8 00 02 	bld	r8,0x2
80005472:	c0 91       	brne	80005484 <_fflush_r+0x98>
80005474:	6e 18       	ld.w	r8,r7[0x4]
80005476:	10 15       	sub	r5,r8
80005478:	6e d8       	ld.w	r8,r7[0x34]
8000547a:	58 08       	cp.w	r8,0
8000547c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80005480:	eb d8 e1 15 	subne	r5,r5,r8
80005484:	6e b8       	ld.w	r8,r7[0x2c]
80005486:	0c 9c       	mov	r12,r6
80005488:	30 09       	mov	r9,0
8000548a:	0a 9a       	mov	r10,r5
8000548c:	6e 8b       	ld.w	r11,r7[0x20]
8000548e:	5d 18       	icall	r8
80005490:	8e 68       	ld.sh	r8,r7[0xc]
80005492:	0a 3c       	cp.w	r12,r5
80005494:	c2 61       	brne	800054e0 <_fflush_r+0xf4>
80005496:	ab d8       	cbr	r8,0xb
80005498:	30 0c       	mov	r12,0
8000549a:	6e 49       	ld.w	r9,r7[0x10]
8000549c:	ae 68       	st.h	r7[0xc],r8
8000549e:	8f 1c       	st.w	r7[0x4],r12
800054a0:	8f 09       	st.w	r7[0x0],r9
800054a2:	ed b8 00 0c 	bld	r8,0xc
800054a6:	c2 51       	brne	800054f0 <_fflush_r+0x104>
800054a8:	ef 45 00 54 	st.w	r7[84],r5
800054ac:	d8 22       	popm	r4-r7,pc
800054ae:	6e 45       	ld.w	r5,r7[0x10]
800054b0:	58 05       	cp.w	r5,0
800054b2:	c1 f0       	breq	800054f0 <_fflush_r+0x104>
800054b4:	6e 04       	ld.w	r4,r7[0x0]
800054b6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800054ba:	8f 05       	st.w	r7[0x0],r5
800054bc:	f9 b8 01 00 	movne	r8,0
800054c0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
800054c4:	0a 14       	sub	r4,r5
800054c6:	8f 28       	st.w	r7[0x8],r8
800054c8:	c1 18       	rjmp	800054ea <_fflush_r+0xfe>
800054ca:	08 99       	mov	r9,r4
800054cc:	0a 9a       	mov	r10,r5
800054ce:	6e a8       	ld.w	r8,r7[0x28]
800054d0:	6e 8b       	ld.w	r11,r7[0x20]
800054d2:	0c 9c       	mov	r12,r6
800054d4:	5d 18       	icall	r8
800054d6:	18 14       	sub	r4,r12
800054d8:	58 0c       	cp.w	r12,0
800054da:	e0 89 00 07 	brgt	800054e8 <_fflush_r+0xfc>
800054de:	8e 68       	ld.sh	r8,r7[0xc]
800054e0:	a7 a8       	sbr	r8,0x6
800054e2:	3f fc       	mov	r12,-1
800054e4:	ae 68       	st.h	r7[0xc],r8
800054e6:	d8 22       	popm	r4-r7,pc
800054e8:	18 05       	add	r5,r12
800054ea:	58 04       	cp.w	r4,0
800054ec:	fe 99 ff ef 	brgt	800054ca <_fflush_r+0xde>
800054f0:	d8 2a       	popm	r4-r7,pc,r12=0
800054f2:	00 00       	add	r0,r0
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	55 c8       	stdsp	sp[0x170],r8
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	5f 3c       	srlo	r12
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	5f 5c       	srlt	r12
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	5f 7c       	srpl	r12

80005504 <__sfp_lock_acquire>:
80005504:	5e fc       	retal	r12

80005506 <__sfp_lock_release>:
80005506:	5e fc       	retal	r12

80005508 <_cleanup_r>:
80005508:	d4 01       	pushm	lr
8000550a:	48 3b       	lddpc	r11,80005514 <_cleanup_r+0xc>
8000550c:	f0 1f 00 03 	mcall	80005518 <_cleanup_r+0x10>
80005510:	d8 02       	popm	pc
80005512:	00 00       	add	r0,r0
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	5a cc       	cp.w	r12,-20
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	58 c0       	cp.w	r0,12

8000551c <__sfmoreglue>:
8000551c:	d4 21       	pushm	r4-r7,lr
8000551e:	16 95       	mov	r5,r11
80005520:	f6 06 10 5c 	mul	r6,r11,92
80005524:	ec cb ff f4 	sub	r11,r6,-12
80005528:	f0 1f 00 07 	mcall	80005544 <__sfmoreglue+0x28>
8000552c:	18 97       	mov	r7,r12
8000552e:	c0 90       	breq	80005540 <__sfmoreglue+0x24>
80005530:	99 15       	st.w	r12[0x4],r5
80005532:	30 0b       	mov	r11,0
80005534:	2f 4c       	sub	r12,-12
80005536:	0c 9a       	mov	r10,r6
80005538:	8f 2c       	st.w	r7[0x8],r12
8000553a:	8f 0b       	st.w	r7[0x0],r11
8000553c:	f0 1f 00 03 	mcall	80005548 <__sfmoreglue+0x2c>
80005540:	0e 9c       	mov	r12,r7
80005542:	d8 22       	popm	r4-r7,pc
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	4b f8       	lddpc	r8,80005640 <__sinit+0x78>
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	50 48       	stdsp	sp[0x10],r8

8000554c <__sfp>:
8000554c:	d4 21       	pushm	r4-r7,lr
8000554e:	49 c8       	lddpc	r8,800055bc <__sfp+0x70>
80005550:	18 96       	mov	r6,r12
80005552:	70 07       	ld.w	r7,r8[0x0]
80005554:	6e 68       	ld.w	r8,r7[0x18]
80005556:	58 08       	cp.w	r8,0
80005558:	c0 41       	brne	80005560 <__sfp+0x14>
8000555a:	0e 9c       	mov	r12,r7
8000555c:	f0 1f 00 19 	mcall	800055c0 <__sfp+0x74>
80005560:	ee c7 ff 28 	sub	r7,r7,-216
80005564:	30 05       	mov	r5,0
80005566:	6e 2c       	ld.w	r12,r7[0x8]
80005568:	6e 18       	ld.w	r8,r7[0x4]
8000556a:	c0 68       	rjmp	80005576 <__sfp+0x2a>
8000556c:	98 69       	ld.sh	r9,r12[0xc]
8000556e:	ea 09 19 00 	cp.h	r9,r5
80005572:	c1 20       	breq	80005596 <__sfp+0x4a>
80005574:	2a 4c       	sub	r12,-92
80005576:	20 18       	sub	r8,1
80005578:	cf a7       	brpl	8000556c <__sfp+0x20>
8000557a:	6e 08       	ld.w	r8,r7[0x0]
8000557c:	58 08       	cp.w	r8,0
8000557e:	c0 71       	brne	8000558c <__sfp+0x40>
80005580:	30 4b       	mov	r11,4
80005582:	0c 9c       	mov	r12,r6
80005584:	f0 1f 00 10 	mcall	800055c4 <__sfp+0x78>
80005588:	8f 0c       	st.w	r7[0x0],r12
8000558a:	c0 30       	breq	80005590 <__sfp+0x44>
8000558c:	6e 07       	ld.w	r7,r7[0x0]
8000558e:	ce cb       	rjmp	80005566 <__sfp+0x1a>
80005590:	30 c8       	mov	r8,12
80005592:	8d 38       	st.w	r6[0xc],r8
80005594:	d8 22       	popm	r4-r7,pc
80005596:	30 08       	mov	r8,0
80005598:	f9 48 00 4c 	st.w	r12[76],r8
8000559c:	99 08       	st.w	r12[0x0],r8
8000559e:	99 28       	st.w	r12[0x8],r8
800055a0:	99 18       	st.w	r12[0x4],r8
800055a2:	99 48       	st.w	r12[0x10],r8
800055a4:	99 58       	st.w	r12[0x14],r8
800055a6:	99 68       	st.w	r12[0x18],r8
800055a8:	99 d8       	st.w	r12[0x34],r8
800055aa:	99 e8       	st.w	r12[0x38],r8
800055ac:	f9 48 00 48 	st.w	r12[72],r8
800055b0:	3f f8       	mov	r8,-1
800055b2:	b8 78       	st.h	r12[0xe],r8
800055b4:	30 18       	mov	r8,1
800055b6:	b8 68       	st.h	r12[0xc],r8
800055b8:	d8 22       	popm	r4-r7,pc
800055ba:	00 00       	add	r0,r0
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	5f 38       	srlo	r8
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	55 c8       	stdsp	sp[0x170],r8
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	55 1c       	stdsp	sp[0x144],r12

800055c8 <__sinit>:
800055c8:	d4 21       	pushm	r4-r7,lr
800055ca:	18 96       	mov	r6,r12
800055cc:	78 67       	ld.w	r7,r12[0x18]
800055ce:	58 07       	cp.w	r7,0
800055d0:	c4 71       	brne	8000565e <__sinit+0x96>
800055d2:	4a 48       	lddpc	r8,80005660 <__sinit+0x98>
800055d4:	30 15       	mov	r5,1
800055d6:	99 a8       	st.w	r12[0x28],r8
800055d8:	f9 47 00 d8 	st.w	r12[216],r7
800055dc:	f9 47 00 dc 	st.w	r12[220],r7
800055e0:	f9 47 00 e0 	st.w	r12[224],r7
800055e4:	99 65       	st.w	r12[0x18],r5
800055e6:	f0 1f 00 20 	mcall	80005664 <__sinit+0x9c>
800055ea:	8d 0c       	st.w	r6[0x0],r12
800055ec:	0c 9c       	mov	r12,r6
800055ee:	f0 1f 00 1e 	mcall	80005664 <__sinit+0x9c>
800055f2:	8d 1c       	st.w	r6[0x4],r12
800055f4:	0c 9c       	mov	r12,r6
800055f6:	f0 1f 00 1c 	mcall	80005664 <__sinit+0x9c>
800055fa:	6c 09       	ld.w	r9,r6[0x0]
800055fc:	30 48       	mov	r8,4
800055fe:	93 07       	st.w	r9[0x0],r7
80005600:	b2 68       	st.h	r9[0xc],r8
80005602:	93 17       	st.w	r9[0x4],r7
80005604:	93 27       	st.w	r9[0x8],r7
80005606:	6c 18       	ld.w	r8,r6[0x4]
80005608:	b2 77       	st.h	r9[0xe],r7
8000560a:	93 47       	st.w	r9[0x10],r7
8000560c:	93 57       	st.w	r9[0x14],r7
8000560e:	93 67       	st.w	r9[0x18],r7
80005610:	93 89       	st.w	r9[0x20],r9
80005612:	91 07       	st.w	r8[0x0],r7
80005614:	91 17       	st.w	r8[0x4],r7
80005616:	91 27       	st.w	r8[0x8],r7
80005618:	49 4e       	lddpc	lr,80005668 <__sinit+0xa0>
8000561a:	49 5b       	lddpc	r11,8000566c <__sinit+0xa4>
8000561c:	93 9e       	st.w	r9[0x24],lr
8000561e:	93 ab       	st.w	r9[0x28],r11
80005620:	49 4a       	lddpc	r10,80005670 <__sinit+0xa8>
80005622:	49 54       	lddpc	r4,80005674 <__sinit+0xac>
80005624:	93 ba       	st.w	r9[0x2c],r10
80005626:	93 c4       	st.w	r9[0x30],r4
80005628:	30 99       	mov	r9,9
8000562a:	b0 69       	st.h	r8[0xc],r9
8000562c:	b0 75       	st.h	r8[0xe],r5
8000562e:	91 c4       	st.w	r8[0x30],r4
80005630:	91 47       	st.w	r8[0x10],r7
80005632:	91 57       	st.w	r8[0x14],r7
80005634:	91 67       	st.w	r8[0x18],r7
80005636:	91 88       	st.w	r8[0x20],r8
80005638:	91 9e       	st.w	r8[0x24],lr
8000563a:	91 ab       	st.w	r8[0x28],r11
8000563c:	91 ba       	st.w	r8[0x2c],r10
8000563e:	8d 2c       	st.w	r6[0x8],r12
80005640:	31 28       	mov	r8,18
80005642:	99 07       	st.w	r12[0x0],r7
80005644:	b8 68       	st.h	r12[0xc],r8
80005646:	99 17       	st.w	r12[0x4],r7
80005648:	99 27       	st.w	r12[0x8],r7
8000564a:	30 28       	mov	r8,2
8000564c:	b8 78       	st.h	r12[0xe],r8
8000564e:	99 c4       	st.w	r12[0x30],r4
80005650:	99 67       	st.w	r12[0x18],r7
80005652:	99 9e       	st.w	r12[0x24],lr
80005654:	99 ab       	st.w	r12[0x28],r11
80005656:	99 ba       	st.w	r12[0x2c],r10
80005658:	99 47       	st.w	r12[0x10],r7
8000565a:	99 57       	st.w	r12[0x14],r7
8000565c:	99 8c       	st.w	r12[0x20],r12
8000565e:	d8 22       	popm	r4-r7,pc
80005660:	80 00       	ld.sh	r0,r0[0x0]
80005662:	55 08       	stdsp	sp[0x140],r8
80005664:	80 00       	ld.sh	r0,r0[0x0]
80005666:	55 4c       	stdsp	sp[0x150],r12
80005668:	80 00       	ld.sh	r0,r0[0x0]
8000566a:	59 84       	cp.w	r4,24
8000566c:	80 00       	ld.sh	r0,r0[0x0]
8000566e:	59 4c       	cp.w	r12,20
80005670:	80 00       	ld.sh	r0,r0[0x0]
80005672:	59 24       	cp.w	r4,18
80005674:	80 00       	ld.sh	r0,r0[0x0]
80005676:	59 14       	cp.w	r4,17

80005678 <_malloc_trim_r>:
80005678:	d4 21       	pushm	r4-r7,lr
8000567a:	16 95       	mov	r5,r11
8000567c:	18 97       	mov	r7,r12
8000567e:	f0 1f 00 23 	mcall	80005708 <_malloc_trim_r+0x90>
80005682:	4a 34       	lddpc	r4,8000570c <_malloc_trim_r+0x94>
80005684:	68 28       	ld.w	r8,r4[0x8]
80005686:	70 16       	ld.w	r6,r8[0x4]
80005688:	e0 16 ff fc 	andl	r6,0xfffc
8000568c:	ec c8 ff 91 	sub	r8,r6,-111
80005690:	f0 05 01 05 	sub	r5,r8,r5
80005694:	e0 15 ff 80 	andl	r5,0xff80
80005698:	ea c5 00 80 	sub	r5,r5,128
8000569c:	e0 45 00 7f 	cp.w	r5,127
800056a0:	e0 8a 00 23 	brle	800056e6 <_malloc_trim_r+0x6e>
800056a4:	30 0b       	mov	r11,0
800056a6:	0e 9c       	mov	r12,r7
800056a8:	f0 1f 00 1a 	mcall	80005710 <_malloc_trim_r+0x98>
800056ac:	68 28       	ld.w	r8,r4[0x8]
800056ae:	0c 08       	add	r8,r6
800056b0:	10 3c       	cp.w	r12,r8
800056b2:	c1 a1       	brne	800056e6 <_malloc_trim_r+0x6e>
800056b4:	ea 0b 11 00 	rsub	r11,r5,0
800056b8:	0e 9c       	mov	r12,r7
800056ba:	f0 1f 00 16 	mcall	80005710 <_malloc_trim_r+0x98>
800056be:	5b fc       	cp.w	r12,-1
800056c0:	c1 71       	brne	800056ee <_malloc_trim_r+0x76>
800056c2:	30 0b       	mov	r11,0
800056c4:	0e 9c       	mov	r12,r7
800056c6:	f0 1f 00 13 	mcall	80005710 <_malloc_trim_r+0x98>
800056ca:	68 28       	ld.w	r8,r4[0x8]
800056cc:	f8 08 01 09 	sub	r9,r12,r8
800056d0:	58 f9       	cp.w	r9,15
800056d2:	e0 8a 00 0a 	brle	800056e6 <_malloc_trim_r+0x6e>
800056d6:	a1 a9       	sbr	r9,0x0
800056d8:	91 19       	st.w	r8[0x4],r9
800056da:	48 f8       	lddpc	r8,80005714 <_malloc_trim_r+0x9c>
800056dc:	70 09       	ld.w	r9,r8[0x0]
800056de:	48 f8       	lddpc	r8,80005718 <_malloc_trim_r+0xa0>
800056e0:	f8 09 01 09 	sub	r9,r12,r9
800056e4:	91 09       	st.w	r8[0x0],r9
800056e6:	0e 9c       	mov	r12,r7
800056e8:	f0 1f 00 0d 	mcall	8000571c <_malloc_trim_r+0xa4>
800056ec:	d8 2a       	popm	r4-r7,pc,r12=0
800056ee:	68 28       	ld.w	r8,r4[0x8]
800056f0:	0a 16       	sub	r6,r5
800056f2:	a1 a6       	sbr	r6,0x0
800056f4:	91 16       	st.w	r8[0x4],r6
800056f6:	48 98       	lddpc	r8,80005718 <_malloc_trim_r+0xa0>
800056f8:	70 09       	ld.w	r9,r8[0x0]
800056fa:	0a 19       	sub	r9,r5
800056fc:	0e 9c       	mov	r12,r7
800056fe:	91 09       	st.w	r8[0x0],r9
80005700:	f0 1f 00 07 	mcall	8000571c <_malloc_trim_r+0xa4>
80005704:	da 2a       	popm	r4-r7,pc,r12=1
80005706:	00 00       	add	r0,r0
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	43 1c       	lddsp	r12,sp[0xc4]
8000570c:	00 00       	add	r0,r0
8000570e:	01 f0       	ld.ub	r0,r0[0x7]
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	50 58       	stdsp	sp[0x14],r8
80005714:	00 00       	add	r0,r0
80005716:	05 fc       	ld.ub	r12,r2[0x7]
80005718:	00 00       	add	r0,r0
8000571a:	09 d4       	ld.ub	r4,r4[0x5]
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	43 28       	lddsp	r8,sp[0xc8]

80005720 <_free_r>:
80005720:	d4 21       	pushm	r4-r7,lr
80005722:	16 96       	mov	r6,r11
80005724:	18 97       	mov	r7,r12
80005726:	58 0b       	cp.w	r11,0
80005728:	e0 80 00 c8 	breq	800058b8 <_free_r+0x198>
8000572c:	f0 1f 00 4c 	mcall	8000585c <_free_r+0x13c>
80005730:	20 86       	sub	r6,8
80005732:	4c ca       	lddpc	r10,80005860 <_free_r+0x140>
80005734:	6c 18       	ld.w	r8,r6[0x4]
80005736:	74 2e       	ld.w	lr,r10[0x8]
80005738:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000573c:	a1 c8       	cbr	r8,0x0
8000573e:	ec 08 00 09 	add	r9,r6,r8
80005742:	72 1b       	ld.w	r11,r9[0x4]
80005744:	e0 1b ff fc 	andl	r11,0xfffc
80005748:	1c 39       	cp.w	r9,lr
8000574a:	c1 d1       	brne	80005784 <_free_r+0x64>
8000574c:	f6 08 00 08 	add	r8,r11,r8
80005750:	58 0c       	cp.w	r12,0
80005752:	c0 81       	brne	80005762 <_free_r+0x42>
80005754:	6c 09       	ld.w	r9,r6[0x0]
80005756:	12 16       	sub	r6,r9
80005758:	12 08       	add	r8,r9
8000575a:	6c 3b       	ld.w	r11,r6[0xc]
8000575c:	6c 29       	ld.w	r9,r6[0x8]
8000575e:	97 29       	st.w	r11[0x8],r9
80005760:	93 3b       	st.w	r9[0xc],r11
80005762:	10 99       	mov	r9,r8
80005764:	95 26       	st.w	r10[0x8],r6
80005766:	a1 a9       	sbr	r9,0x0
80005768:	8d 19       	st.w	r6[0x4],r9
8000576a:	4b f9       	lddpc	r9,80005864 <_free_r+0x144>
8000576c:	72 09       	ld.w	r9,r9[0x0]
8000576e:	12 38       	cp.w	r8,r9
80005770:	c0 63       	brcs	8000577c <_free_r+0x5c>
80005772:	4b e8       	lddpc	r8,80005868 <_free_r+0x148>
80005774:	0e 9c       	mov	r12,r7
80005776:	70 0b       	ld.w	r11,r8[0x0]
80005778:	f0 1f 00 3d 	mcall	8000586c <_free_r+0x14c>
8000577c:	0e 9c       	mov	r12,r7
8000577e:	f0 1f 00 3d 	mcall	80005870 <_free_r+0x150>
80005782:	d8 22       	popm	r4-r7,pc
80005784:	93 1b       	st.w	r9[0x4],r11
80005786:	58 0c       	cp.w	r12,0
80005788:	c0 30       	breq	8000578e <_free_r+0x6e>
8000578a:	30 0c       	mov	r12,0
8000578c:	c1 08       	rjmp	800057ac <_free_r+0x8c>
8000578e:	6c 0e       	ld.w	lr,r6[0x0]
80005790:	f4 c5 ff f8 	sub	r5,r10,-8
80005794:	1c 16       	sub	r6,lr
80005796:	1c 08       	add	r8,lr
80005798:	6c 2e       	ld.w	lr,r6[0x8]
8000579a:	0a 3e       	cp.w	lr,r5
8000579c:	f9 bc 00 01 	moveq	r12,1
800057a0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800057a4:	eb fe 1a 02 	st.wne	r5[0x8],lr
800057a8:	fd f5 1a 03 	st.wne	lr[0xc],r5
800057ac:	f2 0b 00 0e 	add	lr,r9,r11
800057b0:	7c 1e       	ld.w	lr,lr[0x4]
800057b2:	ed be 00 00 	bld	lr,0x0
800057b6:	c1 30       	breq	800057dc <_free_r+0xbc>
800057b8:	16 08       	add	r8,r11
800057ba:	58 0c       	cp.w	r12,0
800057bc:	c0 c1       	brne	800057d4 <_free_r+0xb4>
800057be:	4a 9e       	lddpc	lr,80005860 <_free_r+0x140>
800057c0:	72 2b       	ld.w	r11,r9[0x8]
800057c2:	2f 8e       	sub	lr,-8
800057c4:	1c 3b       	cp.w	r11,lr
800057c6:	c0 71       	brne	800057d4 <_free_r+0xb4>
800057c8:	97 36       	st.w	r11[0xc],r6
800057ca:	97 26       	st.w	r11[0x8],r6
800057cc:	8d 2b       	st.w	r6[0x8],r11
800057ce:	8d 3b       	st.w	r6[0xc],r11
800057d0:	30 1c       	mov	r12,1
800057d2:	c0 58       	rjmp	800057dc <_free_r+0xbc>
800057d4:	72 2b       	ld.w	r11,r9[0x8]
800057d6:	72 39       	ld.w	r9,r9[0xc]
800057d8:	93 2b       	st.w	r9[0x8],r11
800057da:	97 39       	st.w	r11[0xc],r9
800057dc:	10 99       	mov	r9,r8
800057de:	ec 08 09 08 	st.w	r6[r8],r8
800057e2:	a1 a9       	sbr	r9,0x0
800057e4:	8d 19       	st.w	r6[0x4],r9
800057e6:	58 0c       	cp.w	r12,0
800057e8:	c6 51       	brne	800058b2 <_free_r+0x192>
800057ea:	e0 48 01 ff 	cp.w	r8,511
800057ee:	e0 8b 00 13 	brhi	80005814 <_free_r+0xf4>
800057f2:	a3 98       	lsr	r8,0x3
800057f4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800057f8:	72 2b       	ld.w	r11,r9[0x8]
800057fa:	8d 39       	st.w	r6[0xc],r9
800057fc:	8d 2b       	st.w	r6[0x8],r11
800057fe:	97 36       	st.w	r11[0xc],r6
80005800:	93 26       	st.w	r9[0x8],r6
80005802:	a3 48       	asr	r8,0x2
80005804:	74 19       	ld.w	r9,r10[0x4]
80005806:	30 1b       	mov	r11,1
80005808:	f6 08 09 48 	lsl	r8,r11,r8
8000580c:	f3 e8 10 08 	or	r8,r9,r8
80005810:	95 18       	st.w	r10[0x4],r8
80005812:	c5 08       	rjmp	800058b2 <_free_r+0x192>
80005814:	f0 0b 16 09 	lsr	r11,r8,0x9
80005818:	58 4b       	cp.w	r11,4
8000581a:	e0 8b 00 06 	brhi	80005826 <_free_r+0x106>
8000581e:	f0 0b 16 06 	lsr	r11,r8,0x6
80005822:	2c 8b       	sub	r11,-56
80005824:	c2 b8       	rjmp	8000587a <_free_r+0x15a>
80005826:	59 4b       	cp.w	r11,20
80005828:	e0 8b 00 04 	brhi	80005830 <_free_r+0x110>
8000582c:	2a 5b       	sub	r11,-91
8000582e:	c2 68       	rjmp	8000587a <_free_r+0x15a>
80005830:	e0 4b 00 54 	cp.w	r11,84
80005834:	e0 8b 00 06 	brhi	80005840 <_free_r+0x120>
80005838:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000583c:	29 2b       	sub	r11,-110
8000583e:	c1 e8       	rjmp	8000587a <_free_r+0x15a>
80005840:	e0 4b 01 54 	cp.w	r11,340
80005844:	e0 8b 00 06 	brhi	80005850 <_free_r+0x130>
80005848:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000584c:	28 9b       	sub	r11,-119
8000584e:	c1 68       	rjmp	8000587a <_free_r+0x15a>
80005850:	e0 4b 05 54 	cp.w	r11,1364
80005854:	e0 88 00 10 	brls	80005874 <_free_r+0x154>
80005858:	37 eb       	mov	r11,126
8000585a:	c1 08       	rjmp	8000587a <_free_r+0x15a>
8000585c:	80 00       	ld.sh	r0,r0[0x0]
8000585e:	43 1c       	lddsp	r12,sp[0xc4]
80005860:	00 00       	add	r0,r0
80005862:	01 f0       	ld.ub	r0,r0[0x7]
80005864:	00 00       	add	r0,r0
80005866:	05 f8       	ld.ub	r8,r2[0x7]
80005868:	00 00       	add	r0,r0
8000586a:	09 d0       	ld.ub	r0,r4[0x5]
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	56 78       	stdsp	sp[0x19c],r8
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	43 28       	lddsp	r8,sp[0xc8]
80005874:	f0 0b 16 12 	lsr	r11,r8,0x12
80005878:	28 4b       	sub	r11,-124
8000587a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000587e:	78 29       	ld.w	r9,r12[0x8]
80005880:	18 39       	cp.w	r9,r12
80005882:	c0 e1       	brne	8000589e <_free_r+0x17e>
80005884:	74 18       	ld.w	r8,r10[0x4]
80005886:	a3 4b       	asr	r11,0x2
80005888:	30 1c       	mov	r12,1
8000588a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000588e:	f1 eb 10 0b 	or	r11,r8,r11
80005892:	12 98       	mov	r8,r9
80005894:	95 1b       	st.w	r10[0x4],r11
80005896:	c0 a8       	rjmp	800058aa <_free_r+0x18a>
80005898:	72 29       	ld.w	r9,r9[0x8]
8000589a:	18 39       	cp.w	r9,r12
8000589c:	c0 60       	breq	800058a8 <_free_r+0x188>
8000589e:	72 1a       	ld.w	r10,r9[0x4]
800058a0:	e0 1a ff fc 	andl	r10,0xfffc
800058a4:	14 38       	cp.w	r8,r10
800058a6:	cf 93       	brcs	80005898 <_free_r+0x178>
800058a8:	72 38       	ld.w	r8,r9[0xc]
800058aa:	8d 38       	st.w	r6[0xc],r8
800058ac:	8d 29       	st.w	r6[0x8],r9
800058ae:	93 36       	st.w	r9[0xc],r6
800058b0:	91 26       	st.w	r8[0x8],r6
800058b2:	0e 9c       	mov	r12,r7
800058b4:	f0 1f 00 02 	mcall	800058bc <_free_r+0x19c>
800058b8:	d8 22       	popm	r4-r7,pc
800058ba:	00 00       	add	r0,r0
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	43 28       	lddsp	r8,sp[0xc8]

800058c0 <_fwalk>:
800058c0:	d4 31       	pushm	r0-r7,lr
800058c2:	30 05       	mov	r5,0
800058c4:	16 91       	mov	r1,r11
800058c6:	f8 c7 ff 28 	sub	r7,r12,-216
800058ca:	0a 92       	mov	r2,r5
800058cc:	f0 1f 00 10 	mcall	8000590c <_fwalk+0x4c>
800058d0:	3f f3       	mov	r3,-1
800058d2:	c1 68       	rjmp	800058fe <_fwalk+0x3e>
800058d4:	6e 26       	ld.w	r6,r7[0x8]
800058d6:	6e 14       	ld.w	r4,r7[0x4]
800058d8:	2f 46       	sub	r6,-12
800058da:	c0 c8       	rjmp	800058f2 <_fwalk+0x32>
800058dc:	8c 08       	ld.sh	r8,r6[0x0]
800058de:	e4 08 19 00 	cp.h	r8,r2
800058e2:	c0 70       	breq	800058f0 <_fwalk+0x30>
800058e4:	8c 18       	ld.sh	r8,r6[0x2]
800058e6:	e6 08 19 00 	cp.h	r8,r3
800058ea:	c0 30       	breq	800058f0 <_fwalk+0x30>
800058ec:	5d 11       	icall	r1
800058ee:	18 45       	or	r5,r12
800058f0:	2a 46       	sub	r6,-92
800058f2:	20 14       	sub	r4,1
800058f4:	ec cc 00 0c 	sub	r12,r6,12
800058f8:	58 04       	cp.w	r4,0
800058fa:	cf 14       	brge	800058dc <_fwalk+0x1c>
800058fc:	6e 07       	ld.w	r7,r7[0x0]
800058fe:	58 07       	cp.w	r7,0
80005900:	ce a1       	brne	800058d4 <_fwalk+0x14>
80005902:	f0 1f 00 04 	mcall	80005910 <_fwalk+0x50>
80005906:	0a 9c       	mov	r12,r5
80005908:	d8 32       	popm	r0-r7,pc
8000590a:	00 00       	add	r0,r0
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	55 04       	stdsp	sp[0x140],r4
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	55 06       	stdsp	sp[0x140],r6

80005914 <__sclose>:
80005914:	d4 01       	pushm	lr
80005916:	96 7b       	ld.sh	r11,r11[0xe]
80005918:	f0 1f 00 02 	mcall	80005920 <__sclose+0xc>
8000591c:	d8 02       	popm	pc
8000591e:	00 00       	add	r0,r0
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	59 d4       	cp.w	r4,29

80005924 <__sseek>:
80005924:	d4 21       	pushm	r4-r7,lr
80005926:	16 97       	mov	r7,r11
80005928:	96 7b       	ld.sh	r11,r11[0xe]
8000592a:	f0 1f 00 08 	mcall	80005948 <__sseek+0x24>
8000592e:	8e 68       	ld.sh	r8,r7[0xc]
80005930:	10 99       	mov	r9,r8
80005932:	ad c8       	cbr	r8,0xc
80005934:	ad a9       	sbr	r9,0xc
80005936:	5b fc       	cp.w	r12,-1
80005938:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000593c:	ef f9 1c 06 	st.hne	r7[0xc],r9
80005940:	ef fc 1a 15 	st.wne	r7[0x54],r12
80005944:	d8 22       	popm	r4-r7,pc
80005946:	00 00       	add	r0,r0
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	5a e4       	cp.w	r4,-18

8000594c <__swrite>:
8000594c:	d4 21       	pushm	r4-r7,lr
8000594e:	96 68       	ld.sh	r8,r11[0xc]
80005950:	16 97       	mov	r7,r11
80005952:	14 95       	mov	r5,r10
80005954:	12 94       	mov	r4,r9
80005956:	e2 18 01 00 	andl	r8,0x100,COH
8000595a:	18 96       	mov	r6,r12
8000595c:	c0 60       	breq	80005968 <__swrite+0x1c>
8000595e:	30 29       	mov	r9,2
80005960:	30 0a       	mov	r10,0
80005962:	96 7b       	ld.sh	r11,r11[0xe]
80005964:	f0 1f 00 06 	mcall	8000597c <__swrite+0x30>
80005968:	8e 68       	ld.sh	r8,r7[0xc]
8000596a:	ad c8       	cbr	r8,0xc
8000596c:	08 99       	mov	r9,r4
8000596e:	0a 9a       	mov	r10,r5
80005970:	8e 7b       	ld.sh	r11,r7[0xe]
80005972:	0c 9c       	mov	r12,r6
80005974:	ae 68       	st.h	r7[0xc],r8
80005976:	f0 1f 00 03 	mcall	80005980 <__swrite+0x34>
8000597a:	d8 22       	popm	r4-r7,pc
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	5a e4       	cp.w	r4,-18
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	59 a8       	cp.w	r8,26

80005984 <__sread>:
80005984:	d4 21       	pushm	r4-r7,lr
80005986:	16 97       	mov	r7,r11
80005988:	96 7b       	ld.sh	r11,r11[0xe]
8000598a:	f0 1f 00 07 	mcall	800059a4 <__sread+0x20>
8000598e:	c0 65       	brlt	8000599a <__sread+0x16>
80005990:	6f 58       	ld.w	r8,r7[0x54]
80005992:	18 08       	add	r8,r12
80005994:	ef 48 00 54 	st.w	r7[84],r8
80005998:	d8 22       	popm	r4-r7,pc
8000599a:	8e 68       	ld.sh	r8,r7[0xc]
8000599c:	ad c8       	cbr	r8,0xc
8000599e:	ae 68       	st.h	r7[0xc],r8
800059a0:	d8 22       	popm	r4-r7,pc
800059a2:	00 00       	add	r0,r0
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	5b 10       	cp.w	r0,-15

800059a8 <_write_r>:
800059a8:	d4 21       	pushm	r4-r7,lr
800059aa:	16 98       	mov	r8,r11
800059ac:	18 97       	mov	r7,r12
800059ae:	10 9c       	mov	r12,r8
800059b0:	30 08       	mov	r8,0
800059b2:	14 9b       	mov	r11,r10
800059b4:	48 66       	lddpc	r6,800059cc <_write_r+0x24>
800059b6:	12 9a       	mov	r10,r9
800059b8:	8d 08       	st.w	r6[0x0],r8
800059ba:	f0 1f 00 06 	mcall	800059d0 <_write_r+0x28>
800059be:	5b fc       	cp.w	r12,-1
800059c0:	c0 51       	brne	800059ca <_write_r+0x22>
800059c2:	6c 08       	ld.w	r8,r6[0x0]
800059c4:	58 08       	cp.w	r8,0
800059c6:	ef f8 1a 03 	st.wne	r7[0xc],r8
800059ca:	d8 22       	popm	r4-r7,pc
800059cc:	00 00       	add	r0,r0
800059ce:	0a 2c       	rsub	r12,r5
800059d0:	80 00       	ld.sh	r0,r0[0x0]
800059d2:	40 04       	lddsp	r4,sp[0x0]

800059d4 <_close_r>:
800059d4:	d4 21       	pushm	r4-r7,lr
800059d6:	30 08       	mov	r8,0
800059d8:	18 97       	mov	r7,r12
800059da:	48 76       	lddpc	r6,800059f4 <_close_r+0x20>
800059dc:	16 9c       	mov	r12,r11
800059de:	8d 08       	st.w	r6[0x0],r8
800059e0:	f0 1f 00 06 	mcall	800059f8 <_close_r+0x24>
800059e4:	5b fc       	cp.w	r12,-1
800059e6:	c0 51       	brne	800059f0 <_close_r+0x1c>
800059e8:	6c 08       	ld.w	r8,r6[0x0]
800059ea:	58 08       	cp.w	r8,0
800059ec:	ef f8 1a 03 	st.wne	r7[0xc],r8
800059f0:	d8 22       	popm	r4-r7,pc
800059f2:	00 00       	add	r0,r0
800059f4:	00 00       	add	r0,r0
800059f6:	0a 2c       	rsub	r12,r5
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	51 f0       	stdsp	sp[0x7c],r0

800059fc <_fclose_r>:
800059fc:	d4 21       	pushm	r4-r7,lr
800059fe:	18 96       	mov	r6,r12
80005a00:	16 97       	mov	r7,r11
80005a02:	58 0b       	cp.w	r11,0
80005a04:	c0 31       	brne	80005a0a <_fclose_r+0xe>
80005a06:	16 95       	mov	r5,r11
80005a08:	c5 08       	rjmp	80005aa8 <_fclose_r+0xac>
80005a0a:	f0 1f 00 29 	mcall	80005aac <_fclose_r+0xb0>
80005a0e:	58 06       	cp.w	r6,0
80005a10:	c0 70       	breq	80005a1e <_fclose_r+0x22>
80005a12:	6c 68       	ld.w	r8,r6[0x18]
80005a14:	58 08       	cp.w	r8,0
80005a16:	c0 41       	brne	80005a1e <_fclose_r+0x22>
80005a18:	0c 9c       	mov	r12,r6
80005a1a:	f0 1f 00 26 	mcall	80005ab0 <_fclose_r+0xb4>
80005a1e:	4a 68       	lddpc	r8,80005ab4 <_fclose_r+0xb8>
80005a20:	10 37       	cp.w	r7,r8
80005a22:	c0 31       	brne	80005a28 <_fclose_r+0x2c>
80005a24:	6c 07       	ld.w	r7,r6[0x0]
80005a26:	c0 a8       	rjmp	80005a3a <_fclose_r+0x3e>
80005a28:	4a 48       	lddpc	r8,80005ab8 <_fclose_r+0xbc>
80005a2a:	10 37       	cp.w	r7,r8
80005a2c:	c0 31       	brne	80005a32 <_fclose_r+0x36>
80005a2e:	6c 17       	ld.w	r7,r6[0x4]
80005a30:	c0 58       	rjmp	80005a3a <_fclose_r+0x3e>
80005a32:	4a 38       	lddpc	r8,80005abc <_fclose_r+0xc0>
80005a34:	10 37       	cp.w	r7,r8
80005a36:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80005a3a:	8e 69       	ld.sh	r9,r7[0xc]
80005a3c:	30 08       	mov	r8,0
80005a3e:	f0 09 19 00 	cp.h	r9,r8
80005a42:	c0 51       	brne	80005a4c <_fclose_r+0x50>
80005a44:	f0 1f 00 1f 	mcall	80005ac0 <_fclose_r+0xc4>
80005a48:	30 05       	mov	r5,0
80005a4a:	c2 f8       	rjmp	80005aa8 <_fclose_r+0xac>
80005a4c:	0e 9b       	mov	r11,r7
80005a4e:	0c 9c       	mov	r12,r6
80005a50:	f0 1f 00 1d 	mcall	80005ac4 <_fclose_r+0xc8>
80005a54:	6e c8       	ld.w	r8,r7[0x30]
80005a56:	18 95       	mov	r5,r12
80005a58:	58 08       	cp.w	r8,0
80005a5a:	c0 60       	breq	80005a66 <_fclose_r+0x6a>
80005a5c:	6e 8b       	ld.w	r11,r7[0x20]
80005a5e:	0c 9c       	mov	r12,r6
80005a60:	5d 18       	icall	r8
80005a62:	f9 b5 05 ff 	movlt	r5,-1
80005a66:	8e 68       	ld.sh	r8,r7[0xc]
80005a68:	ed b8 00 07 	bld	r8,0x7
80005a6c:	c0 51       	brne	80005a76 <_fclose_r+0x7a>
80005a6e:	6e 4b       	ld.w	r11,r7[0x10]
80005a70:	0c 9c       	mov	r12,r6
80005a72:	f0 1f 00 16 	mcall	80005ac8 <_fclose_r+0xcc>
80005a76:	6e db       	ld.w	r11,r7[0x34]
80005a78:	58 0b       	cp.w	r11,0
80005a7a:	c0 a0       	breq	80005a8e <_fclose_r+0x92>
80005a7c:	ee c8 ff bc 	sub	r8,r7,-68
80005a80:	10 3b       	cp.w	r11,r8
80005a82:	c0 40       	breq	80005a8a <_fclose_r+0x8e>
80005a84:	0c 9c       	mov	r12,r6
80005a86:	f0 1f 00 11 	mcall	80005ac8 <_fclose_r+0xcc>
80005a8a:	30 08       	mov	r8,0
80005a8c:	8f d8       	st.w	r7[0x34],r8
80005a8e:	6f 2b       	ld.w	r11,r7[0x48]
80005a90:	58 0b       	cp.w	r11,0
80005a92:	c0 70       	breq	80005aa0 <_fclose_r+0xa4>
80005a94:	0c 9c       	mov	r12,r6
80005a96:	f0 1f 00 0d 	mcall	80005ac8 <_fclose_r+0xcc>
80005a9a:	30 08       	mov	r8,0
80005a9c:	ef 48 00 48 	st.w	r7[72],r8
80005aa0:	30 08       	mov	r8,0
80005aa2:	ae 68       	st.h	r7[0xc],r8
80005aa4:	f0 1f 00 07 	mcall	80005ac0 <_fclose_r+0xc4>
80005aa8:	0a 9c       	mov	r12,r5
80005aaa:	d8 22       	popm	r4-r7,pc
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	55 04       	stdsp	sp[0x140],r4
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	55 c8       	stdsp	sp[0x170],r8
80005ab4:	80 00       	ld.sh	r0,r0[0x0]
80005ab6:	5f 3c       	srlo	r12
80005ab8:	80 00       	ld.sh	r0,r0[0x0]
80005aba:	5f 5c       	srlt	r12
80005abc:	80 00       	ld.sh	r0,r0[0x0]
80005abe:	5f 7c       	srpl	r12
80005ac0:	80 00       	ld.sh	r0,r0[0x0]
80005ac2:	55 06       	stdsp	sp[0x140],r6
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	53 ec       	stdsp	sp[0xf8],r12
80005ac8:	80 00       	ld.sh	r0,r0[0x0]
80005aca:	57 20       	stdsp	sp[0x1c8],r0

80005acc <fclose>:
80005acc:	d4 01       	pushm	lr
80005ace:	48 48       	lddpc	r8,80005adc <fclose+0x10>
80005ad0:	18 9b       	mov	r11,r12
80005ad2:	70 0c       	ld.w	r12,r8[0x0]
80005ad4:	f0 1f 00 03 	mcall	80005ae0 <fclose+0x14>
80005ad8:	d8 02       	popm	pc
80005ada:	00 00       	add	r0,r0
80005adc:	00 00       	add	r0,r0
80005ade:	01 ec       	ld.ub	r12,r0[0x6]
80005ae0:	80 00       	ld.sh	r0,r0[0x0]
80005ae2:	59 fc       	cp.w	r12,31

80005ae4 <_lseek_r>:
80005ae4:	d4 21       	pushm	r4-r7,lr
80005ae6:	16 98       	mov	r8,r11
80005ae8:	18 97       	mov	r7,r12
80005aea:	10 9c       	mov	r12,r8
80005aec:	30 08       	mov	r8,0
80005aee:	14 9b       	mov	r11,r10
80005af0:	48 66       	lddpc	r6,80005b08 <_lseek_r+0x24>
80005af2:	12 9a       	mov	r10,r9
80005af4:	8d 08       	st.w	r6[0x0],r8
80005af6:	f0 1f 00 06 	mcall	80005b0c <_lseek_r+0x28>
80005afa:	5b fc       	cp.w	r12,-1
80005afc:	c0 51       	brne	80005b06 <_lseek_r+0x22>
80005afe:	6c 08       	ld.w	r8,r6[0x0]
80005b00:	58 08       	cp.w	r8,0
80005b02:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005b06:	d8 22       	popm	r4-r7,pc
80005b08:	00 00       	add	r0,r0
80005b0a:	0a 2c       	rsub	r12,r5
80005b0c:	80 00       	ld.sh	r0,r0[0x0]
80005b0e:	52 08       	stdsp	sp[0x80],r8

80005b10 <_read_r>:
80005b10:	d4 21       	pushm	r4-r7,lr
80005b12:	16 98       	mov	r8,r11
80005b14:	18 97       	mov	r7,r12
80005b16:	10 9c       	mov	r12,r8
80005b18:	30 08       	mov	r8,0
80005b1a:	14 9b       	mov	r11,r10
80005b1c:	48 66       	lddpc	r6,80005b34 <_read_r+0x24>
80005b1e:	12 9a       	mov	r10,r9
80005b20:	8d 08       	st.w	r6[0x0],r8
80005b22:	f0 1f 00 06 	mcall	80005b38 <_read_r+0x28>
80005b26:	5b fc       	cp.w	r12,-1
80005b28:	c0 51       	brne	80005b32 <_read_r+0x22>
80005b2a:	6c 08       	ld.w	r8,r6[0x0]
80005b2c:	58 08       	cp.w	r8,0
80005b2e:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005b32:	d8 22       	popm	r4-r7,pc
80005b34:	00 00       	add	r0,r0
80005b36:	0a 2c       	rsub	r12,r5
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	3e e8       	mov	r8,-18

80005b3c <__do_global_ctors_aux>:
80005b3c:	d4 21       	pushm	r4-r7,lr
80005b3e:	48 57       	lddpc	r7,80005b50 <__do_global_ctors_aux+0x14>
80005b40:	c0 28       	rjmp	80005b44 <__do_global_ctors_aux+0x8>
80005b42:	5d 18       	icall	r8
80005b44:	20 47       	sub	r7,4
80005b46:	6e 08       	ld.w	r8,r7[0x0]
80005b48:	5b f8       	cp.w	r8,-1
80005b4a:	cf c1       	brne	80005b42 <__do_global_ctors_aux+0x6>
80005b4c:	d8 22       	popm	r4-r7,pc
80005b4e:	00 00       	add	r0,r0
80005b50:	00 00       	add	r0,r0
80005b52:	00 0c       	add	r12,r0

Disassembly of section .exception:

80005c00 <_evba>:
80005c00:	c0 08       	rjmp	80005c00 <_evba>
	...

80005c04 <_handle_TLB_Multiple_Hit>:
80005c04:	c0 08       	rjmp	80005c04 <_handle_TLB_Multiple_Hit>
	...

80005c08 <_handle_Bus_Error_Data_Fetch>:
80005c08:	c0 08       	rjmp	80005c08 <_handle_Bus_Error_Data_Fetch>
	...

80005c0c <_handle_Bus_Error_Instruction_Fetch>:
80005c0c:	c0 08       	rjmp	80005c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80005c10 <_handle_NMI>:
80005c10:	c0 08       	rjmp	80005c10 <_handle_NMI>
	...

80005c14 <_handle_Instruction_Address>:
80005c14:	c0 08       	rjmp	80005c14 <_handle_Instruction_Address>
	...

80005c18 <_handle_ITLB_Protection>:
80005c18:	c0 08       	rjmp	80005c18 <_handle_ITLB_Protection>
	...

80005c1c <_handle_Breakpoint>:
80005c1c:	c0 08       	rjmp	80005c1c <_handle_Breakpoint>
	...

80005c20 <_handle_Illegal_Opcode>:
80005c20:	c0 08       	rjmp	80005c20 <_handle_Illegal_Opcode>
	...

80005c24 <_handle_Unimplemented_Instruction>:
80005c24:	c0 08       	rjmp	80005c24 <_handle_Unimplemented_Instruction>
	...

80005c28 <_handle_Privilege_Violation>:
80005c28:	c0 08       	rjmp	80005c28 <_handle_Privilege_Violation>
	...

80005c2c <_handle_Floating_Point>:
80005c2c:	c0 08       	rjmp	80005c2c <_handle_Floating_Point>
	...

80005c30 <_handle_Coprocessor_Absent>:
80005c30:	c0 08       	rjmp	80005c30 <_handle_Coprocessor_Absent>
	...

80005c34 <_handle_Data_Address_Read>:
80005c34:	c0 08       	rjmp	80005c34 <_handle_Data_Address_Read>
	...

80005c38 <_handle_Data_Address_Write>:
80005c38:	c0 08       	rjmp	80005c38 <_handle_Data_Address_Write>
	...

80005c3c <_handle_DTLB_Protection_Read>:
80005c3c:	c0 08       	rjmp	80005c3c <_handle_DTLB_Protection_Read>
	...

80005c40 <_handle_DTLB_Protection_Write>:
80005c40:	c0 08       	rjmp	80005c40 <_handle_DTLB_Protection_Write>
	...

80005c44 <_handle_DTLB_Modified>:
80005c44:	c0 08       	rjmp	80005c44 <_handle_DTLB_Modified>
	...

80005c50 <_handle_ITLB_Miss>:
80005c50:	c0 08       	rjmp	80005c50 <_handle_ITLB_Miss>
	...

80005c60 <_handle_DTLB_Miss_Read>:
80005c60:	c0 08       	rjmp	80005c60 <_handle_DTLB_Miss_Read>
	...

80005c70 <_handle_DTLB_Miss_Write>:
80005c70:	c0 08       	rjmp	80005c70 <_handle_DTLB_Miss_Write>
	...

80005d00 <_handle_Supervisor_Call>:
80005d00:	49 3f       	lddpc	pc,80005d4c <ipr_val+0x10>
	...

80005d04 <_int0>:
80005d04:	30 0c       	mov	r12,0
80005d06:	f0 1f 00 13 	mcall	80005d50 <ipr_val+0x14>
80005d0a:	58 0c       	cp.w	r12,0
80005d0c:	f8 0f 17 10 	movne	pc,r12
80005d10:	d6 03       	rete

80005d12 <_int1>:
80005d12:	30 1c       	mov	r12,1
80005d14:	f0 1f 00 0f 	mcall	80005d50 <ipr_val+0x14>
80005d18:	58 0c       	cp.w	r12,0
80005d1a:	f8 0f 17 10 	movne	pc,r12
80005d1e:	d6 03       	rete

80005d20 <_int2>:
80005d20:	30 2c       	mov	r12,2
80005d22:	f0 1f 00 0c 	mcall	80005d50 <ipr_val+0x14>
80005d26:	58 0c       	cp.w	r12,0
80005d28:	f8 0f 17 10 	movne	pc,r12
80005d2c:	d6 03       	rete

80005d2e <_int3>:
80005d2e:	30 3c       	mov	r12,3
80005d30:	f0 1f 00 08 	mcall	80005d50 <ipr_val+0x14>
80005d34:	58 0c       	cp.w	r12,0
80005d36:	f8 0f 17 10 	movne	pc,r12
80005d3a:	d6 03       	rete

80005d3c <ipr_val>:
80005d3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80005d4c:	80 00 41 d4 80 00 22 d4 00 00 00 00 00 00 00 00     ..A...".........
	...

Disassembly of section .fini:

80005e00 <_fini>:
80005e00:	eb cd 40 40 	pushm	r6,lr
80005e04:	48 26       	lddpc	r6,80005e0c <_fini+0xc>
80005e06:	1e 26       	rsub	r6,pc
80005e08:	c0 48       	rjmp	80005e10 <_fini+0x10>
80005e0a:	00 00       	add	r0,r0
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	5d ea       	*unknown*
80005e10:	f0 16 00 02 	mcall	r6[8]
80005e14:	e3 cd 80 40 	ldm	sp++,r6,pc
